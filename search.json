[{"url":"/article/Python-basics.html","content":"\n# 1. 基础语法\n\n## 1.1 行和缩进\n\n学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。\n\n缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。\n\n## 1.2 多行语句\n\nPython语句中一般以新行作为语句的结束符。\n\n但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示：\n```python\ntotal = item_one + \\\n        item_two + \\\n        item_three\n```\n\n语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：\n```python\ndays = ['Monday', 'Tuesday', 'Wednesday',\n        'Thursday', 'Friday']\n```\n\n## 1.3 Python空行\n\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n\n空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n记住：**空行也是程序代码的一部分**。\n\n## 1.4 同一行显示多条语句\n\nPython可以在同一行中使用多条语句，语句之间使用**分号(`;`)**分割，以下是一个简单的实例：\n\n```pyhton\nimport sys; x = 'runoob'; sys.stdout.write(x + '\\n')\n```\n\n## 1.5 print输出\n\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号` ,`。\n```python\nx=\"a\"\ny=\"b\"\n# 换行输出\nprint x\nprint y\n\nprint '---------'\n# 不换行输出\nprint x,\nprint y,\n\n# 不换行输出\nprint x,y\n```\n\n# 2. 变量类型\n\n## 2.1 变量赋值\n\nPython 中的变量赋值不需要类型声明。\n\n每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。\n\n**每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。**\n\n等号 `=` 用来给变量赋值。\n\n等号`=` 运算符左边是一个变量名，等号 `=` 运算符右边是存储在变量中的值。\n\n## 2.2 多个变量赋值\n\nPython允许你同时为多个变量赋值。例如：\n\n```python\na = b = c = 1\n```\n\n以上实例，创建一个整型对象，值为1，**三个变量被分配到相同的内存空间上**。\n\n也可以为多个对象指定多个变量。例如：\n\n```python\na, b, c = 1, 2, \"john\"\n```\n\n以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 \"john\" 分配给变量 c。\n\n## 2.3 标准数据类型\n\n在内存中存储的数据可以有多种类型。\n\n例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。\n\nPython 定义了一些标准类型，用于存储各种类型的数据。\n\nPython有五个标准的数据类型：\n\n- Numbers（数字）\n- String（字符串）\n- LIst（列表）\n- Tuple（元祖）\n- Dictionary（字典）\n\n## 2.4 Python 数字\n\n数字数据类型用于存储数值。\n\n**他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。**\n\n当你指定一个值时，Number 对象就会被创建。\n\n也可以使用del语句删除一些对象的引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n还可以通过使用del语句删除单个或多个对象的引用。例如：\n```python\ndel var\ndel var_a, var_b\n```\n\nPython支持四种不同的数字类型：\n\n- int（有符号整型）\n- long（长整型，也可以代表八进制和十六进制）\n- float（浮点型）\n- complex（复数）\n\nTips：\n\n- 长整型也可以使用小写 l，但是还是建议使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。\n- Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。\n\n> **注意：** long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。\n> \n\n## 2.5 Python 字符串\n\n字符串或串(String)是由数字、字母、下划线组成的一串字符。它是编程语言中表示文本的数据类型。\n\npython的字串列表有2种取值顺序:\n\n- 从左到右索引默认0开始的，最大范围是字符串长度少1\n- 从右到左索引默认-1开始的，最大范围是字符串开头\n\n![](Python-basics/python-string-slice.png)\n\n如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。\n\n[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。 ==>  **左闭右开**\n\n比如:\n\n```python\n>>> s = 'abcdef'\n>>> s[1:5]\n'bcde'\n>>> s[-3:]\n'def'\n```\n\n**加号（+）是字符串连接运算符，星号（*）是重复操作。**如下实例：\n\n```python\nstr = 'Hello World!'\n \nprint str           # 输出完整字符串\nprint str[0]        # 输出字符串中的第一个字符\nprint str[2:5]      # 输出字符串中第三个至第六个之间的字符串\nprint str[2:]       # 输出从第三个字符开始的字符串\nprint str * 2       # 输出字符串两次\nprint str + \"TEST\"  # 输出连接的字符串\n```\n\n以上实例输出结果：\n```python\nHello World!\nH\nllo\nllo World!\nHello World!Hello World!\nHello World!TEST\n```\n\nPython 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n![](Python-basics/python_list_slice_2.png)\n\n## 2.6 Python 列表\n\nList（列表） 是 Python 中使用最频繁的数据类型。\n\n列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。\n\n列表用 `[ ]`  标识，是 python 最通用的复合数据类型。\n\n列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。\n\n![](Python-basics/list_slicing1_new1.png)\n\n**加号 + 是列表连接运算符，星号 * 是重复操作。**如下实例：\n\n```python\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntinylist = [123, 'john']\n \nprint list               # 输出完整列表\nprint list[0]            # 输出列表的第一个元素\nprint list[1:3]          # 输出第二个至第三个元素 \nprint list[2:]           # 输出从第三个开始至列表末尾的所有元素\nprint tinylist * 2       # 输出列表两次\nprint list + tinylist    # 打印组合的列表\n```\n\n以上实例输出结果：\n```python\n['runoob', 786, 2.23, 'john', 70.2]\nrunoob\n[786, 2.23]\n[2.23, 'john', 70.2]\n[123, 'john', 123, 'john']\n['runoob', 786, 2.23, 'john', 70.2, 123, 'john']\n```\n\n## 2.7 Python 元组\n元组是另一个数据类型，类似于 List（列表）。\n\n元组用 `( ) ` 标识。内部元素用逗号隔开。**但是元组不能二次赋值，相当于只读列表。**\n\n```python\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\ntinytuple = (123, 'john')\n \nprint tuple               # 输出完整元组\nprint tuple[0]            # 输出元组的第一个元素\nprint tuple[1:3]          # 输出第二个至第四个（不包含）的元素 \nprint tuple[2:]           # 输出从第三个开始至列表末尾的所有元素\nprint tinytuple * 2       # 输出元组两次\nprint tuple + tinytuple   # 打印组合的元组\n```\n\n以上实例输出结果：\n\n```python\n('runoob', 786, 2.23, 'john', 70.2)\nrunoob\n(786, 2.23)\n(2.23, 'john', 70.2)\n(123, 'john', 123, 'john')\n('runoob', 786, 2.23, 'john', 70.2, 123, 'john')\n```\n\n**以下对元组的操作是无效的，因为元组不允许更新，而列表是允许更新的：**\n\n```python\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntuple[2] = 1000    # 元组中是非法应用\nlist[2] = 1000     # 列表中是合法应用\n```\n\n元组是不允许更新的，所以以上代码执行错误，结果如下：\n\n```python\nTraceback (most recent call last):\n  File \"test.py\", line 6, in <module>\n    tuple[2] = 1000    # 元组中是非法应用\nTypeError: 'tuple' object does not support item assignment\n```\n\n## 2.8 Python 字典\n字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。**列表是有序的对象集合，字典是无序的对象集合。**\n\n两者之间的区别在于：字典当中的**元素是通过键来存取的，而不是通过偏移存取。**\n\n字典用 `{ }` 标识。字典由 **索引(key)** 和它对应的 **值value** 组成。\n\n```python\ndict = {}\ndict['one'] = \"This is one\"\ndict[2] = \"This is two\"\n \ntinydict = {'name': 'runoob','code':6734, 'dept': 'sales'}\n \n \nprint dict['one']          # 输出键为'one' 的值\nprint dict[2]              # 输出键为 2 的值\nprint tinydict             # 输出完整的字典\nprint tinydict.keys()      # 输出所有键\nprint tinydict.values()    # 输出所有值\n```\n\n输出结果为：\n\n```python\nThis is one\nThis is two\n{'dept': 'sales', 'code': 6734, 'name': 'runoob'}\n['dept', 'code', 'name']\n['sales', 6734, 'runoob']\n```\n\n## 2.9 Python 数据类型转换\n有时候，我们需要对数据内置的类型进行转换，**数据类型的转换，你只需要将数据类型作为函数名即可**。\n\n以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。\n\n|函数|描述|备注|\n|-|-|-|\n|int(x [,base])|将x转换为一个整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|long(x [,base])|将x转换为一个长整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|float(x)|将x转换到一个浮点数||\n|complex(real [,imag])|创建一个复数|real -- int, long, float或字符串；imag -- int, long, float；|\n|str(x)|将对象 x 转换为字符串||\n|repr(x)|将对象 x 转换为表达式字符串||\n|eval(str)|用来计算在字符串中的有效Python表达式,并返回一个对象||\n|tuple(s)|将序列 s 转换为一个元组||\n|list(s)|将序列 s 转换为一个列表||\n|set(s)|转换为可变集合||\n|dict(d)|创建一个字典。d 必须是一个序列 (key,value)元组。||\n|frozenset(s)|转换为不可变集合||\n|chr(x)|将一个整数转换为一个字符||\n|unichr(x)|将一个整数转换为Unicode字符||\n|ord(x)|将一个字符转换为它的整数值||\n|hex(x)|将一个整数转换为一个十六进制字符串||\n|oct(x)|将一个整数转换为一个八进制字符串||\n\n# 3. 运算符\n\nPython语言支持以下类型的运算符:\n\n- 算术运算符\n- 比较（关系）运算符\n- 赋值运算符\n- 逻辑运算符\n- 位运算符\n- 成员运算符\n- 身份运算符\n- 运算符优先级\n\n## 3.1 算术运算符\n\n以下假设变量： a=10，b=20：\n\n|运算符|描述|实例|\n|-|-|-|\n|%|取模 - 返回除法的余数|b % a 输出结果 0|\n|\\*\\*|幂 - 返回x的y次幂|a\\*\\*b 为10的20次方， 输出结果 100000000000000000000|\n|//|取整除 - 返回商的整数部分（**向下取整**）|9//2 输出 4 ; -9//2 输出 -5|\n\n> **注意：**  `Python2.x` 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。\n> 在 `Python 3.x` 中 / 除法不再这么做了，对于整数之间的相除，结果也会是浮点数。\n\n## 3.2 位运算符\n\n按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n\n下表中变量 a 为 60，b 为 13，二进制格式如下：\n\n```python\na = 0011 1100\n\nb = 0000 1101\n\n-----------------\n\na&b = 0000 1100\n\na|b = 0011 1101\n\na^b = 0011 0001\n\n~a  = 1100 0011\n```\n|运算符|描述|实例|\n|-|-|-|\n|&|按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0|(a & b) 输出结果 12 ，二进制解释： 0000 1100|\n|\\||按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。|(a | b) 输出结果 61 ，二进制解释： 0011 1101|\n|^|按位异或运算符：当两对应的二进位相异时，结果为1|(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|\n|~|按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|\n|<<|左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。|a << 2 输出结果 240 ，二进制解释： 1111 0000|\n|>>|右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|\n\n## 3.3 逻辑运算符\n\nPython语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n> **注意：**关注and、or的返回值问题\n\n|运算符|逻辑表达式|描述|实例|\n|-|-|-|-|\n|and|x and y|布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它**返回 y 的计算值**。|(a and b) 返回 20。|\n|or|x or y|布尔\"或\" - **如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。**|(a or b) 返回 10。|\n|not|not x|布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|not(a and b) 返回 False|\n\n## 3.4 成员运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|in|如果在指定的序列中找到值返回 True，否则返回 False。|x 在 y 序列中 , 如果 x 在 y 序列中返回 True。|\n|not in|如果在指定的序列中没有找到值返回 True，否则返回 False。|x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。|\n\n## 3.5 身份运算符\n\n身份运算符用于比较两个对象的存储单元\n\n|运算符|描述|实例|\n|-|-|-|\n|is|is 是判断两个标识符是不是引用自一个对象|x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False|\n|is not|is not 是判断两个标识符是不是引用自不同对象|x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。|\n\n>注： id() 函数用于获取对象内存地址。\n>id() 函数返回对象的唯一标识符，标识符是一个整数。CPython 中 id() 函数用于获取对象的内存地址\n>id 语法：id([object])，参数说明：object -- 对象。\n\n### is 与 == 区别：\n\n**is **用于判断两个变量引用对象是否为**同一个(同一块内存空间)**，**==**用于判断引用变量的**值是否相等**。\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a \nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\n## 3.6 运算符优先级\n\n以下表格列出了从最高到最低优先级的所有运算符：\n\n|运算符|描述|\n|-|-|\n|\\*\\*|指数 (最高优先级)|\n|~ + -|按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)|\n|\\* / % //|乘，除，取模和取整除|\n|+ -|加法减法|\n|>> <<|右移，左移运算符|\n|&|位 'AND'|\n|^ |\t位运算符|\n|<= < > >=|比较运算符|\n|<> == !=|等于运算符|\n|= %= /= //= -= += \\*= \\*\\*=|赋值运算符|\n|is is not|身份运算符|\n|in not in|成员运算符|\n|not and or|逻辑运算符|\n\n# 4. 条件语句\n# 5. 循环语句\n# 6. While循环语句\n# 7. for循环语句\n# 8. 循环嵌套\n# 9. break语句\n# 10. continue语句\n# 11. pass语句\n# 12. Number（数字）\n# 13. 字符串\n# 14. 列表（List）\n# 15. 元祖\n# 16. 字典（Dictionary）\n# 17. 日期和时间\n# 18. 函数\n# 19. 模块\n# 20. 文件I/O\n# 21. File 方法\n# 22. 异常处理\n# 23. OS 文件/目录方法\n# 24. 内置函数\n\n\n\n\n\n\n\n\n\n","tags":["开发语言"],"categories":["Python"]},{"title":"Python 简介","url":"/article/Python-introduction.html","content":"\n\n# 1. Python 起源\n\n## 1.1 解释器\n\n**计算机不能直接理解任何除机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**。  \n编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器**以解释方式运行的时候**，也称之为**解释器**。  \n![](Python-introduction/编译型和解释型语言工作对比.png)  \n\n- **编译型语言**：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++。  \n- **解释型语言**：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行。  \n\n## 1.2 Python 特点\n\n* Python 是**完全面向对象的语言**\n  * **函数**、**模块**、**数字**、**字符串**都是对象，**在 Python 中一切皆对象**\n  * 完全支持继承、重载、多重继承\n  * 支持重载运算符，也支持泛型设计\n* Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字**、**字符串**、**列表**、**字典**、**文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理**、**网络通信**、**文本处理**、**数据库接口**、**图形系统**、**XML 处理** 等额外的功能。\n* Python 社区提供了**大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算**、**人工智能**、**机器学习**、**Web 开发**、**数据库接口**、**图形系统** 多个领域。\n\n## 1.3 Python 的优缺点\n\n- **优点**\n  - 简单、易学\n  - 免费、开源\n  - **面向对象**\n  - 丰富的库\n  - 可扩展性\n    - 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 `C` 或 `C++` 编写，然后在 `Python` 程序中使用它们\n  - ……\n- **缺点**\n  - 运行速度\n  - 国内市场较小\n  - 中文资料匮乏\n\n# 2. Python 程序\n\n1. Python 源程序就是**一个特殊格式的文本文件**，可以**使用任意文本编辑软件**做 `Python` 的开发\n2. Python 程序的 **文件扩展名** 通常都是 `.py`\n\n**Tips:（报错提示）**\n\n- error 错误\n- name 名字\n- defined 已经定义\n- syntax 语法\n- invalid 无效\n- Indentation 索引\n- unexpected 意外的，不期望的\n- character 字符\n- line 行\n- encoding 编码\n- declared 声明\n- details 细节，详细信息\n- ASCII 一种字符编码\n\n# 3. `Python 2.x` 与 `3​​.x` 版本简介\n\n目前市场上有两个 Python 的版本并存着，分别是 `Python 2.x` 和 `Python 3.x`\n\n> 新的 Python 程序建议使用 `Python 3.0` 版本的语法\n\n* Python 2.x 是 **过去的版本**\n  * 解释器名称是 **python**\n* Python 3.x 是 **现在和未来 主流的版本**\n  * 解释器名称是 **python3**\n  * 相对于 `Python` 的早期版本，这是一个 **较大的升级**\n  * 为了不带入过多的累赘，`Python 3.0` 在设计的时候 **没有考虑向下兼容**\n    * 许多早期 `Python` 版本设计的程序都无法在 `Python 3.0` 上正常执行\n  * Python 3.0 发布于 **2008 年**\n  * 到目前为止，Python 3.0 的稳定版本已经有很多年了\n    * Python 3.3 发布于 2012\n    * Python 3.4 发布于 2014\n    * Python 3.5 发布于 2015\n    * Python 3.6 发布于 2016\n* 为了照顾现有的程序，官方提供了一个过渡版本 —— **Python 2.6**\n  * 基本使用了 `Python 2.x` 的语法和库\n  * 同时考虑了向 `Python 3.0` 的迁移，**允许使用部分** `Python 3.0` 的语法与函数\n  * 2010 年中推出的 `Python 2.7` 被确定为 **最后一个Python 2.x 版本**\n\n> 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议\n>\n> * 先使用 `Python 3.0` 版本进行开发\n> * 然后使用 `Python 2.6`、`Python 2.7` 来执行，并且做一些兼容性的处理\n\n# 4. 执行 Python 程序的三种方式\n\n## 4.1  解释器 `python` / `python3`\n\n### 1) Python 的解释器\n\n```bash\n# 使用 python 2.x 解释器\n$ python xxx.py\n\n# 使用 python 3.x 解释器\n$ python3 xxx.py\n```\n\n### 2) 其他解释器\n\n**Python 的解释器** 如今有多个语言的实现，包括：\n\n- `CPython` —— 官方版本的 C 语言实现\n- `Jython` —— 可以运行在 Java 平台\n- `IronPython` —— 可以运行在 .NET 和 Mono 平台\n- `PyPy` —— Python 实现的，支持 JIT 即时编译\n\n## 4.2 交互式运行 Python 程序\n\n- 直接在终端中运行解释器，而不输入要执行的文件名\n- 在 Python 的 `Shell` 中直接输入 **Python 的代码**，会立即看到程序执行结果\n\n### 1) 交互式运行 Python 的优缺点\n\n- **优点**\n  - 适合于学习/验证 Python 语法或者局部代码\n- **缺点**\n  - 代码不能保存\n  - 不适合运行太大的程序\n\n### 2) 退出 官方的解释器\n\n- 1> 直接输入 `exit()`\n\n```python\n>>> exit()\n```\n\n- 2> 使用热键退出\n  在 python 解释器中，按热键 `ctrl + d` 可以退出解释器\n\n### 3) IPython\n\n- IPython 中 的 “I” 代表 **交互 interactive**\n\n**特点**\n\n- IPython 是一个 python 的 **交互式 shell**，比默认的 `python shell` 好用得多\n  - 支持自动补全\n  - 自动缩进\n  - 支持 `bash shell` 命令\n  - 内置了许多很有用的功能和函数\n- IPython 是基于 BSD 开源的\n\n**版本**\n\n- Python 2.x 使用的解释器是 **ipython**\n- Python 3.x 使用的解释器是 **ipython3**\n\n**要退出解释器可以有以下两种方式：**\n\n- 1> 直接输入 `exit`\n\n```python\nIn [1]: exit\n```\n\n- 2> 使用热键退出\n  在 IPython 解释器中，按热键 `ctrl + d`，`IPython` 会询问是否退出解释器\n\n## 4.3. Python 的 IDE —— `PyCharm`\n\n### 1） 集成开发环境（IDE）\n\n集成开发环境（`IDE`，Integrated Development Environment）—— **集成了开发软件需要的所有工具**，一般包括以下工具：\n\n- 图形用户界面\n- 代码编辑器（支持 **代码补全**／**自动缩进**）\n- 编译器／解释器\n- 调试器（**断点**／**单步执行**）\n- ……\n\n### 2）PyCharm 介绍\n\n- `PyCharm` 是 Python 的一款非常优秀的集成开发环境\n- `PyCharm` 除了具有一般 IDE 所必备功能外，还可以在 `Windows`、`Linux`、`macOS` 下使用\n- `PyCharm` 适合开发大型项目\n  - 一个项目通常会包含 **很多源文件**\n  - 每个 **源文件** 的代码行数是有限的，通常在几百行之内\n  - 每个 **源文件** 各司其职，共同完成复杂的业务功能","tags":["开发语言"],"categories":["Python"]},{"title":"Perceptron","url":"/article/Perceptron.html","content":"\n\n# 1 感知器模型\n## 1.1 起源\n感知器模型与算法由美国科学家 Frank Rosenblatt 于 1958 年提出，最早用于解决图像分类问题。我们把向量 $ \\begin{equation} x = (x_1, x_2, ... , x_n)^T \\end{equation} $ 称为模式（Pattern）或特征（Feature）向量，比如 $ \\begin{equation} x_i \\end{equation} $ 表示图像中第 i 个像素的亮度。标量 y 称为类别标号（Class label）。感知器可以把一个模式 x 区分为两个不同的类别 $ \\begin{equation} (y = -1, +1) \\end{equation} $ ，这个过程称为分类（Classification）。\n\n## 1.2 定义\n假设输入空间（特征空间）是 $ \\begin{equation} \\mathcal{X} \\in R^n \\end{equation} $ ，输出空间是 $ \\begin{equation} \\mathcal{Y} \\in \\lbrace -1, 1 \\rbrace \\end{equation} $ ，其中输入 $ \\begin{equation} x \\in \\mathcal{X} \\end{equation} $ 表示实例的特征向量，对应于输入空间（特征空间）的点，输出 $ \\begin{equation} y \\in \\mathcal{Y} \\end{equation} $ 表示实例的类别，有输入空间到输出空间的函数：\n$$ \\begin{equation} \ng(x; w, b) = sgn(w^Tx + b) \n\\end{equation} $$\n称为感知器。其中 **g** 称为决策函数，**sgn** 称为符号函数：\n$$ \\begin{equation} \nsgn(x) = \n\\begin{cases}\n\\ \\ \\ 1, &x \\geqslant 0\\\\\n-1, &x < 0\n\\end{cases}\n\\end{equation} $$\n由判别函数得到一个方程：\n$$ \\begin{equation} \n\\mathcal{f} (x; w, b) = w^Tx + b = 0\n\\end{equation} $$\n该方程是一个线性方程，表示 d 维空间的一个超平面（hyper-plane），称为决策面（Decision Boundary），把该空间划分两半，位于该决策面一侧的样本 **x** 为正样本（**y** = 1）、位于另一侧的样本为负样本（**y**  = -1），**w** 为该超平面的法向量，**b** 为位置偏置。图 1 展示了 d = 2 时的情况。\n![图1 线性决策面](Perceptron/图1_线性决策面.jpg)\n<center><p>图1 线性决策面</p></center>\n由于 d 维感知器的决策面是一个超平面，因此一个感知器只能对可以用超平面分隔的样本进行区分，如果样本的分布不能用线性超平面区分（线性不可分），那么单个感知器就无法起作用。比如图 2 中的红色与蓝色样本，是线性不可分的。\n![图2 线性不可分](Perceptron/图2_线性不可分.jpg)\n\n<center><p>图2 线性不可分</p></center>\n\n\n# 2 感知器学习算法\n\n## 2.1 定义\n感知器模型由参数 $ \\begin{equation} \\Theta  = (w, b ) \\end{equation} $ 决定。但是在很多问题中，这些参数无法由人工决定。比如，图像分类中，权值 $ \\begin{equation} w_i \\end{equation} $ 表示第i个像素的权值，这个权值很难由人工分析确定。因此需要有一种方法能自动确定这些参数。在机器学习中，如果给定一组已知类别标号的样本集 $ \\begin{equation} D = \\lbrace (x^{(i)}, y^{(i)}) \\rbrace (i = 1, 2, ..., n) \\end{equation} $ ，那么可以从这组样本中学习（Learning）/训练（Training）出模型的参数 $ \\begin{equation} \\Theta \\end{equation} $ 。\n**感知器学习算法**（Perceptron Learning Algorithm，PLA）是 Rosenblatt 给出的一个用于学习感知器模型的算法。该算法是一个迭代算法，首先初化模型参数为 **w** = 0，**b** = 0，假设第 t 步得到的模型参数为 $ \\begin{equation} \\Theta  = (w, b ) \\end{equation} $ ，在 t + 1 步，从 **D** 中选取一个样本 $ \\begin{equation} (x^{(j)}, y^{(j)}) \\end{equation} $ ，用当前模型参数代入感知器中对该样本进行分类，得到分类结果为 $ \\begin{equation} \\bar y \\end{equation} $ 。如果分类正确（ $ \\begin{equation} \\bar y = y^{(j)} \\end{equation} $ ），那么权值不变；如果分类错误（ $ \\begin{equation} \\bar y \\neq y^{(j)} \\end{equation} $ ），根据类别标号  $ \\begin{equation} y = y^{(j)} \\end{equation} $  对权值做如下更新：\n$$\\begin{equation}\\begin{split} \n&w \\leftarrow w + y^{(j)}x^{(j)} \\\\ \n&b \\leftarrow b + y^{(j)}\n\\end{split}\\end{equation}$$  \n\n## 2.2 PLA算法（伪代码）\n下面的伪代码展示了感知器的学习过程：  \n![PLA算法伪代码](Perceptron/PLA算法伪代码.jpg)\n当训练样本集D是线性可分时，上述算法在有限步内能输出一个能对D中所有样本正确分类的模型$ \\begin{equation} g(x; w, b) \\end{equation} $。  \n\n## 2.3 PLA算法实现\n1. 算法思想：对样本集进行**重复迭代**，以实现**逐点修正**。\n\t- ① 获取样本集中本次迭代的样本的预测值  $ \\begin{equation} \\bar y \\end{equation} $ 。\n\t- ② 将预测值 $ \\begin{equation} \\bar y \\end{equation} $ 和该样本的真实值 $ \\begin{equation} y^{(i)} \\end{equation} $ 进行比较。\n\t\t- 分类正确，对样本集中的下一个样本进行预测，即跳转到 ① 处执行，直至样本集中的样本全部迭代，然后跳转至③。\n\t\t- 分类错误，标记出现错误分类，然后对 $ \\begin{equation} \\vec w \\end{equation} $  和 **b** 进行更新，完成后跳转到 ① 处执行，直至样本集中的样本全部迭代，然后跳转至③。\n\t- ③ 若样本集中的所有样本全部迭代，且**未出现错误分类**，即说明当前的权重和偏差值正确，输出此时的 $ \\begin{equation} \\vec w \\end{equation} $  和 **b** 。\n2. Java实现：\n\n- PLA算法核心\n```Java\n// 重复迭代样本集实现逐点修正\nwhile (true){\n    boolean flag = true;    // 错误分类标记（用于判断当前w、b是否可以实现二分类）\n    Collections.shuffle(data);  // 对测试集进行随机排序\n    for (Data d : data) {   // 迭代样本集\n        int y_hat = forecast(weight, b, d); // 预测值\n        int y = d.getY();   // 真实值\n        if (y * y_hat <= 0){  // 判断当前分类是否正确，>0正确\n            flag = false;   // 出现错误分类\n            weight = update(weight, d); // 更新权重\n            b += d.getY();  // 更新偏差值\n        }\n    }\n    if (flag)\t// 本次迭代未出现错误分类\n        break;\n}\n```\n\n- forecast(Weight weight, int b, Data data)方法\n```Java\n/**\n * 计算y_hat(预测值)\n * @param weight    权重\n * @param b         偏差值\n * @param data      数据集\n * @return          返回预测值\n */\npublic static int forecast(Weight weight, int b, Data data){\n    return ((weight.getW1() * data.getX1()) + (weight.getW2() * data.getX2()) + b);\n}\n\n```\n\n- update(Weight weight, Data data)方法\n```Java\n/**\n * 更新权重\n * @param weight    原权重值\n * @param data      数据集\n * @return          返回更新后的权重\n */\npublic static Weight update(Weight weight, Data data){\n    // 获取样本数据\n    int x1 = data.getX1();\n    int x2 = data.getX2();\n\n    // 获取实际值\n    int y = data.getY();\n\n    // 更新权重\n    int newW1 = weight.getW1() + (y * x1);\n    int newW2 = weight.getW2() + (y * x2);\n    weight.setW1(newW1);\n    weight.setW2(newW2);\n    return weight;\n}\n```\n\n- 运行结果\n\n（1）运行结果1  \n![运行结果1](Perceptron/PLA（java实现）运行结果1.jpg)\n\n（2）运行结果2\n![运行结果2](Perceptron/PLA（java实现）运行结果2.jpg)\n\n（3）运行结果3\n![运行结果3](Perceptron/PLA（java实现）运行结果3.jpg)\n\n（4）运行结果4\n![运行结果4](Perceptron/PLA（java实现）运行结果4.jpg)\n\n# 3 总结\n\n- 感知器主要可以解决线性可分的问题，他可以用来解决**二分类问题**，其具有如下的优点和缺点：\n\t- 优点：相较于其他模型，感知器模型简单，易于实现。\n\t- 缺点：\n\t\t- PLA算法每一次运行的结果不一致（不稳定），所以无法完美的处理线性不可分的训练集（数据）。\n\t\t- 感知机中的损失函数（衡量预测值与真实值之间的误差）的目标只是减小所有误分类点与超平面，最终很有可能导致部分样本点距离超平面很近。所以通过PLA得到的只是一个近似最优解的解，并不能得到最优解。\n- 导致PLA算法第一个缺点的主要原因是因为该算法的基本原理是**逐点修正**。首先，在超平面上随意取一条分类面，统计分类错误的点，然后随机对某个错误点进行修正，也就是改变直线的位置，使该错误点得以修正；接着再随机选一个错误点进行纠正，分类面不断变化，直到所有的点都完全分类正确了，就得到了最佳的分类面。正是因为每次运行PLA算法进行的是一种随机修正，所以得到的结果不一样。\n- PLA算法的第二个确定可以通过**SVM**（支持向量机）解决，另外SVM也可以很好地解决线性不可分问题。\n\n\n\n\n\n\n\n\n","tags":["ML（机器学习）","algorithm（算法）","Perceptron（感知器）","linear classification（线性分类）"],"categories":["AI（人工智能）"]}]