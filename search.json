[{"title":"Python3 基础","url":"/article/Python3.html","content":"\n# 1. 基础语法\n\n## 1.1 编码\n\n默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码\n\n```python\n# -*- coding: cp-1252 -*-\n```\n上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码。\n\n## 1.2 标识符\n\n- 第一个字符必须是字母表中字母或下划线 _ 。\n- 标识符的其他的部分由字母、数字和下划线组成。\n- **标识符对大小写敏感。**\n\n在 `Python 3` 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。\n\n## 1.3 Python 保留字\n\n保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：\n\n```python\n>>> import keyword\n>>> keyword.kwlist\n['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n\n## 1.4 注释\n\n- Python中单行注释以 `#` 开头\n- 多行注释可以用多个 `#` 号，还有 `'''` 和 `\"\"\"`\n\n## 1.5 行与缩进\n\npython最具特色的就是使用缩进来表示代码块，不需要使用大括号 `{}` 。\n\n缩进的空格数是可变的，但是**同一个代码块的语句必须包含相同的缩进空格数**。\n\n以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：\n\n```python\nif True:\n    print (\"Answer\")\n    print (\"True\")\nelse:\n    print (\"Answer\")\n  print (\"False\")    # 缩进不一致，会导致运行错误\n```\n\n以上程序由于缩进不一致，执行后会出现类似以下错误：\n\n```python\n File \"test.py\", line 6\n    print (\"False\")    # 缩进不一致，会导致运行错误\n                                      ^\nIndentationError: unindent does not match any outer indentation level\n```\n\n## 1.6 多行语句\n\nPython 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \\ 来实现多行语句，例如：\n\n```python\ntotal = item_one + \\\n        item_two + \\\n        item_three\n```\n\n在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \\，例如：\n\n```python\ntotal = ['item_one', 'item_two', 'item_three',\n        'item_four', 'item_five']\n```\n\n## 1.7 数字(Number)类型\n\n- **int ** (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\n- **bool ** (布尔), 如 True。\n- **float ** (浮点数), 如 1.23、3E-2\n- **complex ** (复数), 如 1 + 2j、 1.1 + 2.2j\n\n## 1.8 字符串(String)\n\n- Python 中单引号 `'` 和双引号 `\"` 使用完全相同。\n- 使用三引号( `'''` 或 `\"\"\"` )可以指定一个多行字符串。\n- 转义符 `\\` 。\n- 反斜杠可以用来转义，使用 `r` 可以让反斜杠不发生转义。 如 ** r\"this is a line with \\n **\"则 \\n 会显示，并不是换行。\n- 按字面意义级联字符串，如** \"this \" \"is \" \"string\" **会被自动转换为** this is string **。\n- 字符串可以用 `+` 运算符连接在一起，用 `*` 运算符重复。\n- Python 中的字符串有两种索引方式，从左往右以 `0` 开始，从右往左以 `-1` 开始。\n- Python 中的**字符串不能改变**。\n- Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n- 字符串的截取的语法格式如下：变量[头下标:尾下标:步长]\n\n```python\nword = '字符串'\nsentence = \"这是一个句子。\"\nparagraph = \"\"\"这是一个段落，\n可以由多行组成\"\"\"\n```\n\n```python\nstr='123456789'\n \nprint(str)                 # 输出字符串\nprint(str[0:-1])           # 输出第一个到倒数第二个的所有字符\nprint(str[0])              # 输出字符串第一个字符\nprint(str[2:5])            # 输出从第三个开始到第五个的字符\nprint(str[2:])             # 输出从第三个开始后的所有字符\nprint(str[1:5:2])          # 输出从第二个开始到第五个且每隔一个的字符（步长为2）\nprint(str * 2)             # 输出字符串两次\nprint(str + '你好')         # 连接字符串\n \nprint('------------------------------')\n \nprint('hello\\nrunoob')      # 使用反斜杠(\\)+n转义特殊字符\nprint(r'hello\\nrunoob')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义\n```\n\n这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如：\n\n```python\n>>> print('\\n')       # 输出空行\n\n>>> print(r'\\n')      # 输出 \\n\n\\n\n>>>\n```\n\n以上实例输出结果：\n```python\n123456789\n12345678\n1\n345\n3456789\n24\n123456789123456789\n123456789你好\n------------------------------\nhello\nrunoob\nhello\\nrunoob\n```\n\n## 1.9 空行\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n\n空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n> **记住：**空行也是程序代码的一部分。\n\n## 1.10 等待用户输入\n\n执行下面的程序在按回车键后就会等待用户输入：\n\n```python\ninput(\"\\n\\n按下 enter 键后退出。\")\n```\n\n以上代码中 ，\\n\\n 在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。\n\n## 1.11 同一行显示多条语句\n\nPython 可以在同一行中使用多条语句，语句之间使用分号 `;` 分割，以下是一个简单的实例：\n\n```python\n>>> import sys; x = 'runoob'; sys.stdout.write(x + '\\n')\nrunoob\n7\n```\n\n此处的 7 表示字符数，runoob 有 6 个字符，**\\n 表示一个字符**，加起来 7 个字符。\n\n## 1.12 多个语句构成代码组\n\n缩进相同的一组语句构成一个代码块，称之代码组。\n\n像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。\n\n将首行及后面的代码组称为一个子句(clause)。\n\n如下实例：\n\n```python\nif expression : \n   suite\nelif expression : \n   suite \nelse : \n   suite\n```\n\n## 1.13 print 输出\n\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=\"\"`：\n\n## 1.14 import 与 from...import\n在 python 用 `import` 或者` from...import` 来导入相应的模块。\n\n将整个模块(somemodule)导入，格式为： `import somemodule`\n\n从某个模块中导入某个函数,格式为：` from somemodule import somefunction`\n\n从某个模块中导入多个函数,格式为：` from somemodule import firstfunc, secondfunc, thirdfunc`\n\n将某个模块中的全部函数导入，格式为：` from somemodule import *`\n\n```python\n# 导入 sys 模块\nimport sys\nprint('================Python import mode==========================')\nprint ('命令行参数为:')\nfor i in sys.argv:\n    print (i)\nprint ('\\n python 路径为',sys.path)\n```\n\n```python\n# 导入 sys 模块的 argv,path 成员\nfrom sys import argv,path  #  导入特定的成员\n \nprint('================python from import===================================')\nprint('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path\n```\n\n## 1.15 命令行参数\n\n很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息\n\n\n# 2. 基本数据类型\n\nPython 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n\n在 Python 中，变量就是变量，它没有类型，我们所说的\"类型\"是变量所指的内存中对象的类型。\n\n等号（=）用来给变量赋值。\n\n等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。\n\n## 2.1 多个变量赋值\n\nPython允许你同时为多个变量赋值。例如：\n\n```python\na = b = c = 1\n```\n\n以上实例，**创建一个整型对象**，值为 1，从后向前赋值，三个变量被赋予相同的数值。\n\n您也可以为多个对象指定多个变量。例如：\n\n```python\na, b, c = 1, 2, \"runoob\"\n```\n\n以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 \"runoob\" 分配给变量 c。\n\n## 2.2 标准数据类型\n\nPython3 中有六个标准的数据类型：\n\n- Number（数字）\n- String（字符串）\n- List（列表）\n- Tuple（元组）\n- Set（集合）\n- Dictionary（字典）\n\nPython3 的六个标准数据类型中：\n\n- **不可变数据**（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n- **可变数据**（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n\n## 2.3 Number（数字）\n\nPython3 支持 **int、float、bool、complex（复数）**。\n\n**在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。**\n\n像大多数语言一样，数值类型的赋值和计算都是很直观的。\n\n内置的** type() 函数**可以用来查询变量所指的**对象类型**。\n\n```python\n>>> a, b, c, d = 20, 5.5, True, 4+3j\n>>> print(type(a), type(b), type(c), type(d))\n<class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n```\n\n此外还可以用 isinstance 来判断：\n```python\n>>> a = 111\n>>> isinstance(a, int)\nTrue\n>>>\n```\n\n**isinstance 和 type 的区别在于：**\n\n- type()不会认为子类是一种父类类型。\n- isinstance()会认为子类是一种父类类型。\n\n```python\n>>> class A:\n...     pass\n... \n>>> class B(A):\n...     pass\n... \n>>> isinstance(A(), A)\nTrue\n>>> type(A()) == A \nTrue\n>>> isinstance(B(), A)\nTrue\n>>> type(B()) == A\nFalse\n```\n\n> Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加，` True==1、False==0` 会返回 True，但可以通过 `is` 来判断类型。\n\n```python\n>>> issubclass(bool, int) \nTrue\n>>> True==1\nTrue\n>>> False==0\nTrue\n>>> True+1\n2\n>>> False+1\n1\n>>> 1 is True\nFalse\n>>> 0 is False\nFalse\n```\n\n> 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。\n\n当指定一个值时，Number 对象就会被创建：\n\n```python\nvar1 = 1\nvar2 = 10\n```\n\n也可以使用del语句删除一些对象引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n可以通过使用del语句删除单个或多个对象。例如：\n\n```python\ndel var\ndel var_a, var_b\n```\n\n**注意：**\n\n- 1、Python可以同时为多个变量赋值，如a, b = 1, 2。\n- 2、一个变量可以通过赋值指向不同类型的对象。\n- 3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。\n- 4、在混合计算时，Python会把整型转换成为浮点数。\n\nPython还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型\n\n## 2.4 String（字符串）\n\nPython中的字符串用单引号 `'` 或双引号 `\"` 括起来，同时使用反斜杠 `\\ ` 转义特殊字符。\n\n字符串的截取的语法格式如下：\n\n> 变量[头下标:尾下标]\n\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n\n![](Python3/123456-20200923-1.svg)\n\n加号 `+` 是字符串的连接符， 星号 `*` 表示复制当前字符串，与之结合的数字为复制的次数。\n\nPython 使用反斜杠 `\\ `转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 `r`，表示原始字符串\n\n```python\n>>> print('Ru\\noob')\nRu\noob\n>>> print(r'Ru\\noob')\nRu\\noob\n>>>\n```\n\n另外，反斜杠(\\)可以作为续行符，表示下一行是上一行的延续。也可以使用 \"\"\"...\"\"\" 或者 '''...''' 跨越多行。\n\n注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。\n\n```python\n>>> word = 'Python'\n>>> print(word[0], word[5])\nP n\n>>> print(word[-1], word[-6])\nn P\n```\n\n与 C 字符串不同的是，**Python 字符串不能被改变**。向一个索引位置赋值，比如word[0] = 'm'会导致错误。\n\n**注意：**\n\n- 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。\n- 2、字符串可以用+运算符连接在一起，用*运算符重复。\n- 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。\n- 4、Python中的字符串不能改变。\n\n## 2.5 List（列表）\n\nList（列表） 是 Python 中使用最频繁的数据类型。\n\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。\n\n列表是写在方括号 `[]` 之间、用逗号分隔开的元素列表。\n\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。\n\n列表截取的语法格式如下：\n\n> 变量[头下标:尾下标]\n\n索引值以 `0` 为开始值，`-1` 为从末尾的开始位置。\n\n![](Python3/list_slicing1_new1.png)\n\n加号 + 是列表连接运算符，星号 * 是重复操作。\n\n**与Python字符串不一样的是，列表中的元素是可以改变的：**\n\n```python\n>>> a = [1, 2, 3, 4, 5, 6]\n>>> a[0] = 9\n>>> a[2:5] = [13, 14, 15]\n>>> a\n[9, 2, 13, 14, 15, 6]\n>>> a[2:5] = []   # 将对应的元素值设置为 []\n>>> a\n[9, 2, 6]\n```\n\nList 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。\n\n**注意：**\n\n- 1、List写在方括号之间，元素用逗号隔开。\n- 2、和字符串一样，list可以被索引和切片。\n- 3、List可以使用+操作符进行拼接。\n- 4、List中的元素是可以改变的。\n\nPython 列表截取可以接收**第三个参数**，参数作用是**截取的步长**，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n![](Python3/py-dict-1.png)\n\n**如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：**\n\n```python\ndef reverseWords(input):\n     \n    # 通过空格将字符串分隔符，把各个单词分隔为列表\n    inputWords = input.split(\" \")\n \n    # 翻转字符串\n    # 假设列表 list = [1,2,3,4],  \n    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)\n    # inputWords[-1::-1] 有三个参数\n    # 第一个参数 -1 表示最后一个元素\n    # 第二个参数为空，表示移动到列表末尾\n    # 第三个参数为步长，-1 表示逆向\n    inputWords=inputWords[-1::-1]\n \n    # 重新组合字符串\n    output = ' '.join(inputWords)\n     \n    return output\n \nif __name__ == \"__main__\":\n    input = 'I like runoob'\n    rw = reverseWords(input)\n    print(rw)\n```\n\n输出结果为：\n```python\nrunoob like I\n```\n\n## 2.6 Tuple（元组）\n\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。\n\n元组中的元素类型也可以不相同。\n\n元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。\n\n其实，**可以把字符串看作一种特殊的元组**。\n\n```python\n>>> tup = (1, 2, 3, 4, 5, 6)\n>>> print(tup[0])\n1\n>>> print(tup[1:5])\n(2, 3, 4, 5)\n>>> tup[0] = 11  # 修改元组元素的操作是非法的\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>>\n```\n\n**虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。**\n\n构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：\n\n```python\ntup1 = ()    # 空元组\ntup2 = (20,) # 一个元素，需要在元素后添加逗号\n```\n\n> string、list 和 tuple 都属于 sequence（序列）。\n\n注意：\n\n- 1、与字符串一样，元组的元素不能修改。\n- 2、元组也可以被索引和切片，方法一样。\n- 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。\n- 4、元组也可以使用+操作符进行拼接。\n\n## 2.7 Set（集合）\n\n集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。\n\n基本功能是进行成员关系测试和删除重复元素。\n\n可以使用大括号 `{ }` 或者 `set()` 函数创建集合，注意：创建一个空集合必须用 `set()` 而不是 `{ }`，因为 `{ }` 是用来创建一个空字典。\n\n创建格式：\n```python\nparame = {value01,value02,...}\n或者\nset(value)\n```\n\n```python\nsites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}\n\nprint(sites)   # 输出集合，重复的元素被自动去掉\n\n# 成员测试\nif 'Runoob' in sites :\n    print('Runoob 在集合中')\nelse :\n    print('Runoob 不在集合中')\n\n\n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n\nprint(a)\n\nprint(a - b)     # a 和 b 的差集\n\nprint(a | b)     # a 和 b 的并集\n\nprint(a & b)     # a 和 b 的交集\n\nprint(a ^ b)     # a 和 b 中不同时存在的元素\n```\n\n以上实例输出结果：\n\n```python\n{'Zhihu', 'Baidu', 'Taobao', 'Runoob', 'Google', 'Facebook'}\nRunoob 在集合中\n{'b', 'c', 'a', 'r', 'd'}\n{'r', 'b', 'd'}\n{'b', 'c', 'a', 'z', 'm', 'r', 'l', 'd'}\n{'c', 'a'}\n{'z', 'b', 'm', 'r', 'l', 'd'}\n```\n\n## 2.8 Dictionary（字典）\n\n字典（dictionary）是Python中另一个非常有用的**内置数据类型**。\n\n**列表是有序的对象集合，字典是无序的对象集合**。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。\n\n字典是一种映射类型，字典用 `{ }` 标识，它是一个无序的` 键(key) : 值(value)` 的集合。\n\n键(key)必须使用不可变类型。\n\n**在同一个字典中，键(key)必须是唯一的。**\n\n```python\ndict = {}\ndict['one'] = \"1 - 菜鸟教程\"\ndict[2]     = \"2 - 菜鸟工具\"\n\ntinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}\n\n\nprint (dict['one'])       # 输出键为 'one' 的值\nprint (dict[2])           # 输出键为 2 的值\nprint (tinydict)          # 输出完整的字典\nprint (tinydict.keys())   # 输出所有键\nprint (tinydict.values()) # 输出所有值\n```\n\n以上实例输出结果：\n```python\n1 - 菜鸟教程\n2 - 菜鸟工具\n{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}\ndict_keys(['name', 'code', 'site'])\ndict_values(['runoob', 1, 'www.runoob.com'])\n```\n\n构造函数 dict() 可以直接从键值对序列中构建字典如下：\n\n```python\n>>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])\n{'Runoob': 1, 'Google': 2, 'Taobao': 3}\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n>>> dict(Runoob=1, Google=2, Taobao=3)\n{'Runoob': 1, 'Google': 2, 'Taobao': 3}\n```\n\n`{x: x**2 for x in (2, 4, 6)}` 该代码使用的是字典推导式，更多推导式内容可以参考：Python 推导式。\n\n另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。\n\n**注意：**\n\n- 1、字典是一种映射类型，它的元素是键值对。\n- 2、字典的关键字必须为不可变类型，且不能重复。\n- 3、创建空字典使用 { }。\n\n## 2.9 Python数据类型转换\n\n有时候，需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，在下一章节 数据类型转换 会具体介绍。\n\n# 3. 数据类型转换\n\n有时候，需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。\n\nPython 数据类型转换可以分为两种：\n\n- **隐式**类型转换 - 自动完成\n- **显式**类型转换 - 需要使用类型函数来转换\n\n## 3.1 隐式类型转换\n\n在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。\n\n以下实例中，对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。\n\n```python\nnum_int = 123\nnum_flo = 1.23\n\nnum_new = num_int + num_flo\n\nprint(\"datatype of num_int:\",type(num_int))\nprint(\"datatype of num_flo:\",type(num_flo))\n\nprint(\"Value of num_new:\",num_new)\nprint(\"datatype of num_new:\",type(num_new))\n```\n\n以上实例输出结果为：\n\n```python\nnum_int 数据类型为: <class 'int'>\nnum_flo 数据类型为: <class 'float'>\nnum_new: 值为: 124.23\nnum_new 数据类型为: <class 'float'>\n```\n\n代码解析：\n\n- 实例中我们对两个不同数据类型的变量 num_int 和 num_flo 进行相加运算，并存储在变量 num_new 中。\n- 然后查看三个变量的数据类型。\n- 在输出结果中，我们看到 num_int 是 整型（integer） ， num_flo 是 浮点型（float）。\n- 同样，新的变量 num_new 是 浮点型（float），这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。\n\n再看一个实例，整型数据与字符串类型的数据进行相加：\n\n```python\nnum_int = 123\nnum_str = \"456\"\n\nprint(\"Data type of num_int:\",type(num_int))\nprint(\"Data type of num_str:\",type(num_str))\n\nprint(num_int+num_str)\n```\n\n以上实例输出结果为：\n\n```python\nnum_int 数据类型为: <class 'int'>\nnum_str 数据类型为: <class 'str'>\nTraceback (most recent call last):\n  File \"/runoob-test/test.py\", line 7, in <module>\n    print(num_int+num_str)\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n```\n\n从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。\n\n但是，Python 为这些类型的情况提供了一种解决方案，称为显式转换。\n\n## 3.2 显式类型转换\n\n在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。\n\n整型和字符串类型进行运算，就可以用强制类型转换来完成：\n\n```python\nnum_int = 123\nnum_str = \"456\"\n\nprint(\"num_int 数据类型为:\",type(num_int))\nprint(\"类型转换前，num_str 数据类型为:\",type(num_str))\n\nnum_str = int(num_str)    # 强制转换为整型\nprint(\"类型转换后，num_str 数据类型为:\",type(num_str))\n\nnum_sum = num_int + num_str\n\nprint(\"num_int 与 num_str 相加结果为:\",num_sum)\nprint(\"sum 数据类型为:\",type(num_sum))\n```\n\n以上实例输出结果为：\n\n```python\nnum_int 数据类型为: <class 'int'>\n类型转换前，num_str 数据类型为: <class 'str'>\n类型转换后，num_str 数据类型为: <class 'int'>\nnum_int 与 num_str 相加结果为: 579\nsum 数据类型为: <class 'int'>\n```\n\n以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。\n\n|函数|描述|备注|\n|-|-|-|\n|int(x [,base])|将x转换为一个整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|float(x)|将x转换到一个浮点数||\n|complex(real [,imag])|创建一个复数|real -- int, long, float或字符串；imag -- int, long, float；|\n|str(x)|将对象 x 转换为字符串||\n|repr(x)|将对象 x 转换为表达式字符串||\n|eval(str)|用来计算在字符串中的有效Python表达式,并返回一个对象||\n|tuple(s)|将序列 s 转换为一个元组||\n|list(s)|将序列 s 转换为一个列表||\n|set(s)|转换为可变集合||\n|dict(d)|创建一个字典。d 必须是一个序列 (key,value)元组。||\n|frozenset(s)|转换为不可变集合||\n|chr(x)|将一个整数转换为一个字符||\n|ord(x)|将一个字符转换为它的整数值||\n|hex(x)|将一个整数转换为一个十六进制字符串||\n|oct(x)|将一个整数转换为一个八进制字符串||\n\n# 4. 推导式\n\nPython 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。\n\nPython 支持各种数据结构的推导式：\n\n- 列表(list)推导式\n- 字典(dict)推导式\n- 集合(set)推导式\n- 元组(tuple)推导式\n\n## 4.1 列表推导式\n列表推导式格式为：\n\n`[表达式 for 变量 in 列表]`\n\n`[out_exp_res for out_exp in input_list]`\n\n或者 \n\n`[表达式 for 变量 in 列表 if 条件]`\n\n`[out_exp_res for out_exp in input_list if condition]`\n\n- out_exp_res：列表生成元素表达式，可以是有返回值的函数。\n- for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。\n- if condition：条件语句，可以过滤列表中不符合条件的值。\n\n过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：\n\n```python\n>>> names = ['Bob','Tom','alice','Jerry','Wendy','Smith']\n>>> new_names = [name.upper()for name in names if len(name)>3]\n>>> print(new_names)\n['ALICE', 'JERRY', 'WENDY', 'SMITH']\n```\n\n计算 30 以内可以被 3 整除的整数：\n\n```python\n>>> multiples = [i for i in range(30) if i % 3 == 0]\n>>> print(multiples)\n[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]\n```\n> python range() 函数可创建一个整数列表，一般用在 for 循环中。\n> 函数语法range(start, stop[, step])\n> 参数说明：\n> start: 计数从 start 开始。默认是从 0 开始。例如range(5)等价于range(0， 5);\n> stop: 计数到 stop 结束，但不包括 stop。例如：range(0， 5) 是[0, 1, 2, 3, 4]没有5\n> step：步长，默认为1。例如：range(0， 5) 等价于 range(0, 5, 1)\n\n\n## 4.2 字典推导式\n\n字典推导基本格式：\n\n`{ key_expr: value_expr for value in collection }`\n\n或\n\n`{ key_expr: value_expr for value in collection if condition }`\n\n使用字符串及其长度创建字典：\n\n```python\nlistdemo = ['Google','Runoob', 'Taobao']\n# 将列表中各字符串值为键，各字符串的长度为值，组成键值对\n>>> newdict = {key:len(key) for key in listdemo}\n>>> newdict\n{'Google': 6, 'Runoob': 6, 'Taobao': 6}\n```\n\n提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：\n\n```python\n>>> dic = {x: x**2 for x in (2, 4, 6)}\n>>> dic\n{2: 4, 4: 16, 6: 36}\n>>> type(dic)\n<class 'dict'>\n```\n\n## 4.3 集合推导式\n\n集合推导式基本格式：\n\n`{ expression for item in Sequence }`\n\n或\n\n`{ expression for item in Sequence if conditional }`\n\n计算数字 1,2,3 的平方数：\n\n```python\n>>> setnew = {i**2 for i in (1,2,3)}\n>>> setnew\n{1, 4, 9}\n```\n\n判断不是 abc 的字母并输出：\n\n```python\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'d', 'r'}\n>>> type(a)\n<class 'set'>\n```\n\n## 4.4 元组推导式\n\n元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。\n\n元组推导式基本格式：\n\n`(expression for item in Sequence )`\n\n或\n\n`(expression for item in Sequence if conditional )`\n\n元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外**元组推导式返回的结果是一个生成器对象**。\n\n例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：\n\n```python\n>>> a = (x for x in range(1,10))\n>>> a\n<generator object <genexpr> at 0x7faf6ee20a50>  # 返回的是生成器对象\n\n>>> tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组\n(1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n\n\n# 5. 解释器\n\nPython 解释器有 CPython、IPython、Jython、PyPy 等。\n\n顾名思义，CPython 就是用 C 语言开发的了，是官方标准实现，拥有良好的生态，所以应用也就最为广泛了。\n\n而 [IPython](http://ipython.org/) 是在 CPython 的基础之上在交互式方面得到增强的解释器。\n\n[Jython](http://www.jython.org/) 是专为 Java 平台设计的 Python 解释器，它把 Python 代码编译成 Java 字节码执行。\n\n[PyPy](http://pypy.org/) 是 Python 语言（2.7.13和3.5.3）的一种快速、兼容的替代实现，以速度快著称。\n\n# 6. 注释\n\n确保对模块, 函数, 方法和行内注释使用正确的风格。\n\nPython 中的注释有单行注释和多行注释。\n\n- Python 中单行注释以 `#` 开头，例如\n- 多行注释用三个单引号 `'''` 或者三个双引号 `\"\"\"` 将注释括起来\n\n# 7. 运算符\n\nPython语言支持以下类型的运算符:\n\n- 算术运算符\n- 比较（关系）运算符\n- 赋值运算符\n- 逻辑运算符\n- 位运算符\n- 成员运算符\n- 身份运算符\n- 运算符优先级\n\n## 7.1 算术运算符\n\n以下假设变量： a=10，b=20：\n\n|运算符|描述|实例|\n|-|-|-|\n|%|取模 - 返回除法的余数|b % a 输出结果 0|\n|\\*\\*|幂 - 返回x的y次幂|a\\*\\*b 为10的20次方， 输出结果 100000000000000000000|\n|//|取整除 - 返回商的整数部分（**向下取整**）|9//2 输出 4 ; -9//2 输出 -5|\n\n> **注意：**  `Python2.x` 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。\n> 在 `Python 3.x` 中 / 除法不再这么做了，对于整数之间的相除，结果也会是浮点数。\n\n## 7.2 赋值运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|:=|海象运算符，可在表达式内部为变量赋值。**Python3.8 版本新增运算符。**|在下方示例中，赋值表达式可以避免调用 len() 两次: |\n\n```python\nif (n := len(a)) > 10:\n    print(f\"List is too long ({n} elements, expected <= 10)\")\n```\n\n## 7.3 位运算符\n\n按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n\n下表中变量 a 为 60，b 为 13，二进制格式如下：\n\n```python\na = 0011 1100\n\nb = 0000 1101\n\n-----------------\n\na&b = 0000 1100\n\na|b = 0011 1101\n\na^b = 0011 0001\n\n~a  = 1100 0011\n```\n|运算符|描述|实例|\n|-|-|-|\n|&|按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0|(a & b) 输出结果 12 ，二进制解释： 0000 1100|\n|\\||按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。|(a | b) 输出结果 61 ，二进制解释： 0011 1101|\n|^|按位异或运算符：当两对应的二进位相异时，结果为1|(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|\n|~|按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|\n|<<|左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。|a << 2 输出结果 240 ，二进制解释： 1111 0000|\n|>>|右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|\n\n## 7.4 逻辑运算符\n\nPython语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n> **注意：** 关注and、or的返回值问题\n\n|运算符|逻辑表达式|描述|实例|\n|-|-|-|-|\n|and|x and y|布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它**返回 y 的计算值**。|(a and b) 返回 20。|\n|or|x or y|布尔\"或\" - **如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。**|(a or b) 返回 10。|\n|not|not x|布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|not(a and b) 返回 False|\n\n## 7.5 成员运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|in|如果在指定的序列中找到值返回 True，否则返回 False。|x 在 y 序列中 , 如果 x 在 y 序列中返回 True。|\n|not in|如果在指定的序列中没有找到值返回 True，否则返回 False。|x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。|\n\n## 7.6 身份运算符\n\n身份运算符用于比较两个对象的存储单元\n\n|运算符|描述|实例|\n|-|-|-|\n|is|is 是判断两个标识符是不是引用自一个对象|x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False|\n|is not|is not 是判断两个标识符是不是引用自不同对象|x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。|\n\n>注： id() 函数用于获取对象内存地址。\n>id() 函数返回对象的唯一标识符，标识符是一个整数。CPython 中 id() 函数用于获取对象的内存地址\n>id 语法：id([object])，参数说明：object -- 对象。\n\n### is 与 == 区别：\n\n**is **用于判断两个变量引用对象是否为**同一个(同一块内存空间)**，**==**用于判断引用变量的**值是否相等**。\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a \nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\n## 7.7 运算符优先级\n\n以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）：\n\n|运算符|描述|\n|-|-|\n|(expressions...),[expressions...], {key: value...}, {expressions...}|圆括号的表达式|\n|x[index], x[index:index], x(arguments...), x.attribute|读取，切片，调用，属性引用|\n|await x|await 表达式|\n|\\*\\*|乘方(指数)|\n|+x, -x, ~x|正，负，按位非 NOT|\n|\\*, @, /, //, %|乘，矩阵乘，除，整除，取余|\n|+, -|加和减|\n|<<, >>|移位|\n|&|按位与 AND|\n|^|按位异或 XOR|\n|\\||按位或 OR|\n|in,not in, is,is not, <, <=, >, >=, !=, ==|比较运算，包括成员检测和标识号检测|\n|not x|逻辑非 NOT|\n|and|逻辑与 AND|\n|or|逻辑或 OR|\n|if -- else|条件表达式|\n|lambda|lambda 表达式|\n|:=|赋值表达式|\n\n> 注意：Pyhton3 已不支持 <> 运算符，可以使用 != 代替，如果你一定要使用这种比较运算符，可以使用以下的方式：\n> ```python\n> >>> from __future__ import barry_as_FLUFL\n> >>> 1 <> 2\n> True\n> ```\n\n# 8. 数字（Number）\n\nPython 数字数据类型用于存储数值。\n\n**数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。**\n\n以下实例在变量赋值时 Number 对象将被创建：\n\n```python\nvar1 = 1\nvar2 = 10\n```\n\n也可以使用del语句删除一些数字对象的引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n可以通过使用del语句删除单个或多个对象的引用，例如：\n```python\ndel var\ndel var_a, var_b\n```\n\nPython 支持三种不同的数值类型：\n\n- **整型**(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。\n\n- **浮点型**(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）\n\n- **复数**( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n\n> Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是**浮点型**。\n\n## 8.1 数字类型转换\n\n有时候，我们需要对数据内置的类型进行转换，数据类型的转换，只需要将数据类型作为函数名即可。\n\n- int(x) 将x转换为一个整数。\n- float(x) 将x转换到一个浮点数。\n- complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。\n- complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n\n## 8.2 数字运算\n\nPython 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。\n\n表达式的语法很直白： `+`, `-`, `*` 和 `/`, 和其它语言（如Pascal或C）里一样。\n\n注意：在不同的机器上浮点运算的结果可能会不一样。\n\n在整数除法中，**除法 `/` 总是返回一个浮点数**，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 `//`。\n\n注意：// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。\n\n```python\n>>> 7//2\n3\n>>> 7.0//2\n3.0\n>>> 7//2.0\n3.0\n>>> \n```\n\n变量在使用前必须先\"定义\"（即赋予变量一个值），否则会出现错误：\n\n```python\n>>> n   # 尝试访问一个未定义的变量\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'n' is not defined\n```\n\n不同类型的数混合运算时会将整数转换为浮点数。\n\n[数学函数、随机数函数、三角函数、数学常量](https://www.runoob.com/python3/python3-number.html)\n\n\n# 9. 字符串（String）\n\n字符串是 Python 中最常用的数据类型。我们可以使用引号( `'` 或 `\"` )来创建字符串。\n\n创建字符串很简单，只要为变量分配一个值即可。\n\n## 9.1 访问字符串中的值\n\nPython 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。\n\nPython 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下：\n\n`变量[头下标:尾下标]`\n\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n\n![](Python3/123456-20200923-1.svg)\n\n![](Python3/python-str-runoob.png)\n\n## 9.2 转义字符\n\n在需要在字符中使用特殊字符时，python 用反斜杠 `\\ ` 转义字符\n\n> [\\, \\\\, \\', \\\", \\a, \\b, \\000, \\n, \\v, \\t, \\r, \\f, \\yyy, \\xyy ,\\other ](https://www.runoob.com/python3/python3-string.html)\n\n## 9.3 字符串运算符\n\n> [+, \\*, [], [ : ], in, not in, r/R, %](https://www.runoob.com/python3/python3-string.html)\n\n## 9.4 字符串格式化\n\nPython 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。\n\n在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。\n\n```python\nprint (\"我叫 %s 今年 %d 岁!\" % ('小明', 10))\n```\n\n以上实例输出结果：\n```python\n我叫 小明 今年 10 岁!\n```\n\n> [python字符串格式化符号](https://www.runoob.com/python3/python3-string.html)\n> [格式化操作符辅助指令]((https://www.runoob.com/python3/python3-string.html)\n\nPython2.6 开始，新增了一种格式化字符串的函数 [str.format()](https://www.runoob.com/python/att-string-format.html)，它增强了字符串格式化的功能。\n\n## 9.5 三引号\n\npython三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下：\n\n```python\npara_str = \"\"\"这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB ( \\t )。\n也可以使用换行符 [ \\n ]。\n\"\"\"\nprint (para_str)\n```\n\n以上实例执行结果为：\n\n```python\n这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB (    )。\n也可以使用换行符 [ \n ]。\n```\n\n三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的**WYSIWYG（所见即所得）**格式的。\n\n## 9.6 f-string\n\nf-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。\n\n之前我们习惯用百分号 (%):\n\n```python\n>>> name = 'Runoob'\n>>> 'Hello %s' % name\n'Hello Runoob'\n```\n\nf-string 格式化字符串以 `f` 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：\n\n```python\n>>> name = 'Runoob'\n>>> f'Hello {name}'  # 替换变量\n'Hello Runoob'\n>>> f'{1+2}'         # 使用表达式\n'3'\n\n>>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}\n>>> f'{w[\"name\"]}: {w[\"url\"]}'\n'Runoob: www.runoob.com'\n```\n\n用了这种方式明显更简单了，**不用再去判断使用 %s，还是 %d**。\n\n**在 Python 3.8 的版本中可以使用 `=` 符号来拼接运算表达式与结果：**\n\n```python\n>>> x = 1\n>>> print(f'{x+1}')   # Python 3.6\n2\n\n>>> x = 1\n>>> print(f'{x+1=}')   # Python 3.8\nx+1=2\n```\n\n## 9.7 Unicode 字符串\n\n在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。\n\n在Python3中，所有的字符串都是Unicode字符串。\n\n## 9.8 字符串内建函数\n\n[Python 的字符串常用内建函数](https://www.runoob.com/python3/python3-string.html)\n\n# 10. 列表（List）\n\n序列是 Python 中最基本的数据结构。\n\n序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。\n\nPython 有 6 个序列的内置类型，但最常见的是列表和元组。\n\n列表都可以进行的操作包括索引，切片，加，乘，检查成员。\n\n此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。\n\n列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。\n\n列表的数据项不需要具有相同的类型\n\n创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：\n\n```python\nlist1 = ['Google', 'Runoob', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5 ]\nlist3 = [\"a\", \"b\", \"c\", \"d\"]\nlist4 = ['red', 'green', 'blue', 'yellow', 'white', 'black']\n```\n\n## 10.1 访问列表中的值\n与字符串的索引一样，列表索引从 `0` 开始，第二个索引是 `1`，依此类推。\n\n通过索引列表可以进行截取、组合等操作。\n\n![](Python3/positive-indexes-1.png)\n\n索引也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2，以此类推。\n\n![](Python3/negative-indexes.png)\n\n使用下标索引来访问列表中的值，同样也可以使用方括号 [] 的形式截取字符，如下所示：\n\n![](Python3/first-slice.png)\n\n使用负数索引值截取：\n\n```python\nlist = ['Google', 'Runoob', \"Zhihu\", \"Taobao\", \"Wiki\"]\n \n# 读取第二位\nprint (\"list[1]: \", list[1])\n# 从第二位开始（包含）截取到倒数第二位（不包含）\nprint (\"list[1:-2]: \", list[1:-2])\n```\n\n以上实例输出结果：\n\n```python\nlist[1]:  Runoob\nlist[1:-2]:  ['Runoob', 'Zhihu']\n```\n\n## 10.2 列表脚本操作符\n\n列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，\\* 号用于重复列表。\n\n## 10.3 嵌套列表\n\n使用嵌套列表即在列表里创建其它列表，例如：\n\n```python\n>>> a = ['a', 'b', 'c']\n>>> n = [1, 2, 3]\n>>> x = [a, n]\n>>> x\n[['a', 'b', 'c'], [1, 2, 3]]\n>>> x[0]\n['a', 'b', 'c']\n>>> x[0][1]\n'b'\n```\n\n## 10.4 列表比较\n\n列表比较需要引入 operator 模块的 eq 方法（详见：[Python operator 模块](https://www.runoob.com/python3/python-operator.html)）：\n\n```python\n# 导入 operator 模块\nimport operator\n\na = [1, 2]\nb = [2, 3]\nc = [2, 3]\nprint(\"operator.eq(a,b): \", operator.eq(a,b))\nprint(\"operator.eq(c,b): \", operator.eq(c,b))\n```\n\n以上代码输出结果为：\n\n```python\noperator.eq(a,b):  False\noperator.eq(c,b):  True\n```\n\n## 10.5 Python列表函数&方法\n\n[Python包含以下函数和方法](https://www.runoob.com/python3/python3-list.html)。\n\n# 11. 元组（Tuple）\n\nPython 的元组与列表类似，不同之处在于元组的元素不能修改。\n\n## 11.1 访问元组中的值\n\n元组使用小括号 `( )`，列表使用方括号 `[ ]`。\n\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n\n![](Python3/tup-2020-10-27-10-26-2.png)\n\n```python\n>>> tup1 = ('Google', 'Runoob', 1997, 2000)\n>>> tup2 = (1, 2, 3, 4, 5 )\n>>> tup3 = \"a\", \"b\", \"c\", \"d\"   #  不需要括号也可以\n>>> type(tup3)\n<class 'tuple'>\n```\n\n创建空元组\n\ntup1 = ()\n**元组中只包含一个元素时，需要在元素后面添加逗号 `,` ，否则括号会被当作运算符使用：**\n\n```python\n>>> tup1 = (50)\n>>> type(tup1)     # 不加逗号，类型为整型\n<class 'int'>\n\n>>> tup1 = (50,)\n>>> type(tup1)     # 加上逗号，类型为元组\n<class 'tuple'>\n```\n\n元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等。\n\n![](Python3/py-tup-10-26.png)\n\n\n**元组中的元素值是不允许修改的，但我们可以对元组进行连接组合。**\n\n## 11.2 元组内置函数\n\n[Python元组包含了以下内置函数](https://www.runoob.com/python3/python3-tuple.html)\n\n## 11.3 关于元组是不可变的\n\n所谓元组的不可变指的是**元组所指向的内存中的内容**不可变。\n\n```python\n>>> tup = ('r', 'u', 'n', 'o', 'o', 'b')\n>>> tup[0] = 'g'     # 不支持修改元素\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> id(tup)     # 查看内存地址\n4440687904\n>>> tup = (1,2,3)\n>>> id(tup)\n4441088800    # 内存地址不一样了\n```\n\n**从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。**\n\n# 12. 字典（Dictionary）\n\n字典是另一种可变容器模型，且可存储任意类型对象。\n\n字典的每个键值 `key=>value` 对用冒号 `:` 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 `{}` 中 ,格式如下所示：\n\nd = {key1 : value1, key2 : value2, key3 : value3 }\n\n注意：`dict` 作为 Python 的关键字和内置函数，变量名不建议命名为 **dict**。\n\n![](Python3/py-dict-3.png)\n\n**键必须是唯一的，但值则不必。**\n\n值可以取任何数据类型，但**键必须是不可变的**，如字符串，数字。\n\n## 12.1 创建空字典\n\n**使用大括号 { } 创建空字典：**\n\n```python\n# 使用大括号 {} 来创建空字典\nemptyDict = {}\n \n# 打印字典\nprint(emptyDict)\n \n# 查看字典的数量\nprint(\"Length:\", len(emptyDict))\n \n# 查看类型\nprint(type(emptyDict))\n```\n\n以上实例输出结果：\n\n```python\n{}\nLength: 0\n<class 'dict'>\n```\n\n**使用内建函数 dict() 创建字典：**\n\n```python\nemptyDict = dict()\n \n# 打印字典\nprint(emptyDict)\n \n# 查看字典的数量\nprint(\"Length:\",len(emptyDict))\n \n# 查看类型\nprint(type(emptyDict))\n```\n\n以上实例输出结果：\n\n```python\n{}\nLength: 0\n<class 'dict'>\n```\n\n## 12.2 删除字典元素\n\n能**删单一的元素**也能**清空字典**，清空只需一项操作。\n\n**显式删除**一个字典用del命令，如下实例：\n\n```python\ntinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}\n \ndel tinydict['Name'] # 删除键 'Name'\ntinydict.clear()     # 清空字典\ndel tinydict         # 删除字典\n \nprint (\"tinydict['Age']: \", tinydict['Age'])\nprint (\"tinydict['School']: \", tinydict['School'])\n```\n\n但这会引发一个异常，因为用执行 del 操作后字典不再存在：\n\n```python\nTraceback (most recent call last):\n  File \"/runoob-test/test.py\", line 9, in <module>\n    print (\"tinydict['Age']: \", tinydict['Age'])\nNameError: name 'tinydict' is not defined\n```\n\n## 12.3 字典键的特性\n\n字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。\n\n两个重要的点需要记住：\n\n**1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住**，如下实例：\n\n```python\ntinydict = {'Name': 'Runoob', 'Age': 7, 'Name': '小菜鸟'}\n \nprint (\"tinydict['Name']: \", tinydict['Name'])\n```\n\n以上实例输出结果：\n\n```python\ntinydict['Name']:  小菜鸟\n```\n\n**2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行**，如下实例：\n\n```python\ntinydict = {['Name']: 'Runoob', 'Age': 7}\n \nprint (\"tinydict['Name']: \", tinydict['Name'])\n```\n\n以上实例输出结果：\n\n```python\nTraceback (most recent call last):\n  File \"test.py\", line 3, in <module>\n    tinydict = {['Name']: 'Runoob', 'Age': 7}\nTypeError: unhashable type: 'list'\n```\n\n## 12.4 字典内置函数&方法\n\n[Python字典包含了以下内置函数、方法](https://www.runoob.com/python3/python3-dictionary.html)\n\n# 13. 集合（Set）\n\n集合（set）是一个无序的不重复元素序列。\n\n## 13.1 访问集合中的值\n可以使用大括号 `{ }` 或者 `set()` 函数创建集合，注意：**创建一个空集合必须用 set() 而不是 { }**，因为 { } 是用来创建一个空字典。\n\n创建格式：\n\n`parame = {value01,value02,...}`\n\n或者\n\n`set(value)`\n\n```python\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # 这里演示的是去重功能\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # 快速判断元素是否在集合内\nTrue\n>>> 'crabgrass' in basket\nFalse\n\n>>> # 下面展示两个集合间的运算.\n...\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  \n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # 集合a中包含而集合b中不包含的元素\n{'r', 'd', 'b'}\n>>> a | b                              # 集合a或b中包含的所有元素\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # 集合a和b中都包含了的元素\n{'a', 'c'}\n>>> a ^ b                              # 不同时包含于a和b的元素\n{'r', 'd', 'b', 'm', 'z', 'l'}\n```\n\n类似列表推导式，同样集合支持集合推导式(Set comprehension):\n\n```python\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n```\n\n## 13.2 集合内置方法完整列表\n\nTips：\n\n- s.add( x ) 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。\n- s.update( x ) 可以添加元素，且参数可以是列表，元组，字典等；x 可以有多个，用逗号分开。\n- s.remove( x ) 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。\n- s.discard( x ) 方法也是移除集合中的元素，且如果元素不存在，不会发生错误。\n- s.pop()  随机删除集合中的一个元素。set 集合的 pop 方法会**对集合进行无序的排列**，然后将这个无序排列集合的**左面第一个元素进行删除**。\n\n[集合内置方法](https://www.runoob.com/python3/python3-set.html)\n\n\n# 14. 编程第一步\n\n通过前面所学的 Python3 基本语法知识，尝试来写一个斐波纳契数列。\n\n```python\n# Fibonacci series: 斐波纳契数列\n# 两个元素的总和确定了下一个数\na, b = 0, 1\nwhile b < 10:\n    print(b)\n    a, b = b, a+b\n```\n\n执行以上程序，输出结果为：\n\n```python\n1\n1\n2\n3\n5\n8\n```\n\n这个例子介绍了几个新特征。\n\n第一行包含了一个**复合赋值**：变量 a 和 b 同时得到新值 0 和 1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。\n\n## 14.1 end 关键字\n\n关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：\n\n```python\n# Fibonacci series: 斐波纳契数列\n# 两个元素的总和确定了下一个数\na, b = 0, 1\nwhile b < 1000:\n    print(b, end=',')\n    a, b = b, a+b\n```\n\n执行以上程序，输出结果为：\n\n```python\n1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n```\n\n# 15. 条件控制\n\nPython 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。\n\n可以通过下图来简单了解条件语句的执行过程:\n\n![](Python3/if-condition.jpg)\n\n代码执行过程：\n\n![](Python3/python-if.webp)\n\n## 15.1 if 语句\nPython中if语句的一般形式如下所示：\n\n```python\nif condition_1:\n    statement_block_1\nelif condition_2:\n    statement_block_2\nelse:\n    statement_block_3\n```\nPython 中用 `elif` 代替了 `else if`，所以if语句的关键字为：`if – elif – else`。\n\n注意：\n\n- 1、每个条件后面要使用冒号 `:`，表示接下来是满足条件后要执行的语句块。\n- 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\n- 3、**在Python中没有switch – case语句。**\n\n![](Python3/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif)\n\n## 15.2 if 嵌套\n在嵌套 if 语句中，可以把 `if...elif...else` 结构放在另外一个 `if...elif...else` 结构中。\n\n```python\nif 表达式1:\n    语句\n    if 表达式2:\n        语句\n    elif 表达式3:\n        语句\n    else:\n        语句\nelif 表达式4:\n    语句\nelse:\n    语句\n```\n\n# 16. 循环控制\n\nPython 中的循环语句有 for 和 while。\n\nPython 循环语句的控制结构图如下所示：\n\n![](Python3/loop.png)\n\n## 16.1 while 循环\n\nPython 中 while 语句的一般形式：\n\n```python\nwhile 判断条件(condition)：\n    执行语句(statements)……\n```\n\n执行流程图如下：\n\n![](Python3/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg)\n\n执行 Gif 演示：\n\n![](Python3/006faQNTgw1f5wnm06h3ug30ci08cake.gif)\n\n同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。\n\n## 16.2 无限循环\n\n我们可以通过**设置条件表达式永远不为 false** 来实现无限循环，实例如下：\n\n```python\nvar = 1\nwhile var == 1 :  # 表达式永远为 true\n   num = int(input(\"输入一个数字  :\"))\n   print (\"你输入的数字是: \", num)\n \nprint (\"Good bye!\")\n```\n\n执行以上脚本，输出结果如下：\n\n```python\n输入一个数字  :5\n你输入的数字是:  5\n输入一个数字  :\n```\n\n可以使用 `CTRL+C` 来退出当前的无限循环。\n\n无限循环在**服务器上客户端的实时请求**非常有用。\n\n## 16.3 while 循环使用 else 语句\n\n如果 while 后面的条件语句为 false 时，则执行 else 的语句块。\n\n语法格式如下：\n\n```python\nwhile <expr>:\n    <statement(s)>\nelse:\n    <additional_statement(s)>\n```\n\nexpr 条件语句为 true 则执行 statement(s) 语句块，如果为 false，则执行 additional_statement(s)。\n\n循环输出数字，并判断大小：\n\n```python\ncount = 0\nwhile count < 5:\n   print (count, \" 小于 5\")\n   count = count + 1\nelse:\n   print (count, \" 大于或等于 5\")\n```\n\n执行以上脚本，输出结果如下：\n\n```python\n0  小于 5\n1  小于 5\n2  小于 5\n3  小于 5\n4  小于 5\n5  大于或等于 5\n```\n\n## 16.4 简单语句组\n类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：\n\n```python\nflag = 1\n \nwhile (flag): print ('欢迎访问菜鸟教程!')\n \nprint (\"Good bye!\")\n```\n\n## 16.5 for 语句\nPython for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。\n\nfor循环的一般格式如下：\n\n```python\nfor <variable> in <sequence>:\n    <statements>\nelse:\n    <statements>\n```\n\n流程图：\n\n![](Python3/A71EC47E-BC53-4923-8F88-B027937EE2FF.jpg)\n\n以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：\n\n```python\nsites = [\"Baidu\", \"Google\",\"Runoob\",\"Taobao\"]\nfor site in sites:\n    if site == \"Runoob\":\n        print(\"菜鸟教程!\")\n        break\n    print(\"循环数据 \" + site)\nelse:\n    print(\"没有循环数据!\")\nprint(\"完成循环!\")\n```\n\n执行脚本后，在循环到 \"Runoob\"时会跳出循环体：\n\n```python\n循环数据 Baidu\n循环数据 Google\n菜鸟教程!\n完成循环!\n```\n\n## 16.6 range()函数\n\n1. 如果需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:\n\n```python\n>>>for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\n```\n\n2. 也可以使用range指定区间的值：\n\n```python\n>>>for i in range(5,9) :\n    print(i)\n \n    \n5\n6\n7\n8\n>>>\n```\n\n3. 也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'**步长**'):\n\n```python\n>>>for i in range(0, 10, 3) :\n    print(i)\n \n    \n0\n3\n6\n9\n>>>\n```\n\n4. 负数：\n\n```python\n>>>for i in range(-10, -100, -30) :\n    print(i)\n \n    \n-10\n-40\n-70\n>>>\n```\n\n5. 也可以结合range()和len()函数以遍历一个序列的索引,如下所示:\n\n```python\n>>>a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n... \n0 Google\n1 Baidu\n2 Runoob\n3 Taobao\n4 QQ\n>>>\n```\n\n6. 还可以使用range()函数来创建一个列表：\n\n```python\n>>>list(range(5))\n[0, 1, 2, 3, 4]\n>>>\n```\n\n## 16.7 break 和 continue 语句及循环中的 else 子句\nbreak 执行流程图：\n\n![](Python3/E5A591EF-6515-4BCB-AEAA-A97ABEFC5D7D.jpg)\n\ncontinue 执行流程图：\n\n![](Python3/8962A4F1-B78C-4877-B328-903366EA1470.jpg)\n\nwhile 语句代码执行过程：\n\n![](Python3/python-while.webp)\n\nfor 语句代码执行过程：\n\n![](Python3/break-continue-536.png)\n\n`break` 语句可以跳出 for 和 while 的循环体。如果从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。\n\n`continue` 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\n\n循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。\n\n如下实例用于查询质数的循环例子:\n\n```python\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            print(n, '等于', x, '*', n//x)\n            break\n    else:\n        # 循环中没有找到元素\n        print(n, ' 是质数')\n```\n执行以上脚本输出结果为：\n\n```python\n2  是质数\n3  是质数\n4 等于 2 * 2\n5  是质数\n6 等于 2 * 3\n7  是质数\n8 等于 2 * 4\n9 等于 3 * 3\n```\n\n## 16.8 pass 语句\n\nPython pass是空语句，是为了保持程序结构的完整性。\n\n`pass` 不做任何事情，一般用做占位语句，如下实例\n\n```python\n>>>while True:\n...     pass  # 等待键盘中断 (Ctrl+C)\n```\n\n最小的类:\n\n```python\n>>>class MyEmptyClass:\n...     pass\n```\n\n# 17. 迭代器与生成器\n\n## 17.1 迭代器\n\n迭代是Python最强大的功能之一，是访问集合元素的一种方式。\n\n迭代器是一个可以记住遍历的位置的对象。\n\n迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n\n迭代器有两个基本的方法：`iter()` 和 `next()`。\n\n字符串，列表或元组对象都可用于创建迭代器：\n\n```python\n>>> list=[1,2,3,4]\n>>> it = iter(list)    # 创建迭代器对象\n>>> print (next(it))   # 输出迭代器的下一个元素\n1\n>>> print (next(it))\n2\n>>>\n```\n\n迭代器对象可以使用常规for语句进行遍历：\n\n```python\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nfor x in it:\n    print (x, end=\" \")\n```\n\n执行以上程序，输出结果如下：\n\n```python\n1 2 3 4\n```\n\n也可以使用 next() 函数：\n\n```python\nimport sys         # 引入 sys 模块\n \nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\n \nwhile True:\n    try:\n        print (next(it))\n    except StopIteration:\n        sys.exit()\n```\n\n执行以上程序，输出结果如下：\n\n```python\n1\n2\n3\n4\n```\n\n## 17.2 创建一个迭代器\n\n把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。\n\n如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 __init__(), 它会在对象初始化的时候执行。\n\n更多内容查阅：Python3 面向对象\n\n__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。\n\n__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。\n\n创建一个返回数字的迭代器，初始值为 1，逐步递增 1：\n\n```python\nclass MyNumbers:\n  def __iter__(self):\n    self.a = 1\n    return self\n \n  def __next__(self):\n    x = self.a\n    self.a += 1\n    return x\n \nmyclass = MyNumbers()\nmyiter = iter(myclass)\n \nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\n```\n\n执行输出结果为：\n\n```python\n1\n2\n3\n4\n5\n```\n\n### StopIteration\nStopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。\n\n在 20 次迭代后停止执行：\n\n```python\nclass MyNumbers:\n  def __iter__(self):\n    self.a = 1\n    return self\n \n  def __next__(self):\n    if self.a <= 20:\n      x = self.a\n      self.a += 1\n      return x\n    else:\n      raise StopIteration\n \nmyclass = MyNumbers()\nmyiter = iter(myclass)\n \nfor x in myiter:\n  print(x)\n  \n```\n\n执行输出结果为：\n\n```python\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n```\n\n## 17.3 生成器\n在 Python 中，使用了 yield 的函数被称为生成器（generator）。\n\n跟普通函数不同的是，**生成器是一个返回迭代器的函数，只能用于迭代操作**，更简单点理解生成器就是一个迭代器。\n\n在调用生成器运行的过程中，**每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行**。\n\n调用一个生成器函数，返回的是一个迭代器对象。\n\n以下实例使用 yield 实现斐波那契数列：\n\n```python\nimport sys\n \ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n \nwhile True:\n    try:\n        print (next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n```\n\n执行以上程序，输出结果如下：\n\n```python\n0 1 1 2 3 5 8 13 21 34 55\n```\n\n# 18. 函数\n\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。\n\n函数能提高**应用的模块性**，和**代码的重复利用率**。你已经知道Python提供了许多**内建函数**，比如print()。但你也可以自己创建函数，这被叫做**用户自定义函数**。\n\n## 18.1 定义一个函数\n\n你可以定义一个由自己想要功能的函数，以下是简单的规则：\n\n- 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。\n- 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n- 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。\n- 函数内容以冒号 `:` 起始，并且缩进。\n- **return [表达式]** 结束函数，选择性地返回一个值给调用方，**不带表达式的 return 相当于返回 None**。\n\n![](Python3/py-tup-10-26-1.png)\n\n### 语法\n\nPython 定义函数使用 def 关键字，一般格式如下：\n\n```python\ndef 函数名（参数列表）:\n    函数体\n```\n\n默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。\n\n## 18.2 函数调用\n\n定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。\n\n这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。\n\n## 18.3 参数传递\n\n在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：\n\n```python\na=[1,2,3]\n\na=\"Runoob\"\n```\n\n以上代码中，[1,2,3] 是 List 类型，\"Runoob\" 是 String 类型，而**变量 a 是没有类型，她仅仅是一个对象的引用（一个指针）**，可以是指向 List 类型对象，也可以是指向 String 类型对象。\n\n### 可更改(mutable)与不可更改(immutable)对象\n\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\n\n- **不可变类型**：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。\n\n- **可变类型**：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n\npython 函数的参数传递：\n\n- **不可变类型**：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。\n\n- **可变类型**：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响\n\n**python 中一切都是对象**，严格意义我们不能说值传递还是引用传递，我们应该说**传不可变对象**和**传可变对象**。\n\n### 传不可变对象实例\n\n通过 id() 函数来查看内存地址变化：\n\n```python\ndef change(a):\n    print(id(a))   # 指向的是同一个对象\n    a=10\n    print(id(a))   # 一个新对象\n \na=1\nprint(id(a))\nchange(a)\n```\n\n以上实例输出结果为：\n\n```python\n4379369136\n4379369136\n4379369424\n```\n\n可以看见在调用函数前后，**形参和实参指向的是同一个对象（对象 id 相同）**，在函数内部修改形参后，形参指向的是不同的 id。\n\n### 传可变对象实例\n可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：\n\n```python\n# 可写函数说明\ndef changeme( mylist ):\n   \"修改传入的列表\"\n   mylist.append([1,2,3,4])\n   print (\"函数内取值: \", mylist)\n   return\n \n# 调用changeme函数\nmylist = [10,20,30]\nchangeme( mylist )\nprint (\"函数外取值: \", mylist)\n```\n\n传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：\n\n```python\n函数内取值:  [10, 20, 30, [1, 2, 3, 4]]\n函数外取值:  [10, 20, 30, [1, 2, 3, 4]]\n```\n\n## 18.4 参数\n\n以下是调用函数时可使用的正式参数类型：\n\n- 必需参数\n- 关键字参数\n- 默认参数\n- 不定长参数\n\n### 必需参数\n\n必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的**一样**。\n\n### 关键字参数\n\n关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。\n\n使用关键字参数允许函数调用时参数的顺序与声明时**不一致**，因为 *Python 解释器能够用参数名匹配参数值*。\n\n以下实例中演示了函数参数的使用不需要使用指定顺序：\n\n```python\n#可写函数说明\ndef printinfo( name, age ):\n   \"打印任何传入的字符串\"\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n \n#调用printinfo函数\nprintinfo( age=50, name=\"runoob\" )\n```\n\n以上实例输出结果：\n\n```python\n名字:  runoob\n年龄:  50\n```\n\n### 默认参数\n\n调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：\n\n```python\n#可写函数说明\ndef printinfo( name, age = 35 ):\n   \"打印任何传入的字符串\"\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n \n#调用printinfo函数\nprintinfo( age=50, name=\"runoob\" )\nprint (\"------------------------\")\nprintinfo( name=\"runoob\" )\n```\n\n以上实例输出结果：\n\n```python\n名字:  runoob\n年龄:  50\n------------------------\n名字:  runoob\n年龄:  35\n```\n\n### 不定长参数\n\n你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：\n\n```python\ndef functionname([formal_args,] *var_args_tuple ):\n   \"函数_文档字符串\"\n   function_suite\n   return [expression]\n```\n\n1. 加了星号 * 的参数会以**元组(tuple)**的形式导入，存放所有未命名的变量参数。\n\n```python\n# 可写函数说明\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   print (vartuple)\n \n# 调用printinfo 函数\nprintinfo( 70, 60, 50 )\n```\n\n以上实例输出结果：\n\n```python\n输出: \n70\n(60, 50)\n```\n\n2. 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：\n\n```python\n# 可写函数说明\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   for var in vartuple:\n      print (var)\n   return\n \n# 调用printinfo 函数\nprintinfo( 10 )\nprintinfo( 70, 60, 50 )\n```\n\n以上实例输出结果：\n\n```python\n输出:\n10\n输出:\n70\n60\n50\n```\n\n3. 还有一种就是参数带两个星号 `**`基本语法如下：\n\n```python\ndef functionname([formal_args,] **var_args_dict ):\n   \"函数_文档字符串\"\n   function_suite\n   return [expression]\n```\n\n加了两个星号 `**` 的参数会以 **字典** 的形式导入。\n\n```python\n# 可写函数说明\ndef printinfo( arg1, **vardict ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   print (vardict)\n \n# 调用printinfo 函数\nprintinfo(1, a=2,b=3)\n```\n\n以上实例输出结果：\n\n```python\n输出: \n1\n{'a': 2, 'b': 3}\n```\n\n4. 声明函数时，参数中星号 * 可以单独出现，例如:\n\n```python\ndef f(a,b,*,c):\n    return a+b+c\n```\n\n如果单独出现星号 *，则星号 * 后的参数必须用关键字传入：\n\n```python\n>>> def f(a,b,*,c):\n...     return a+b+c\n... \n>>> f(1,2,3)   # 报错\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: f() takes 2 positional arguments but 3 were given\n>>> f(1,2,c=3) # 正常\n6\n>>>\n```\n\n## 18.5 匿名函数\n\nPython 使用 `lambda` 来创建匿名函数。\n\n所谓匿名，意即**不再使用 def 语句这样标准的形式定义一个函数**。\n\n- `lambda` 只是一个表达式，函数体比 **def** 简单很多。\n- `lambda` 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。\n- `lambda` 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n- 虽然 `lambda` 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n\n### 语法\nlambda 函数的语法只包含一个语句，如下：\n\n`lambda [arg1 [,arg2,.....argn]]:expression`\n\n1. 设置参数 a 加上 10:\n\n```python\nx = lambda a : a + 10\nprint(x(5))\n```\n\n以上实例输出结果：\n\n```python\n15\n```\n\n2. 以下实例匿名函数设置两个参数：\n\n```python \n# 可写函数说明\nsum = lambda arg1, arg2: arg1 + arg2\n \n# 调用sum函数\nprint (\"相加后的值为 : \", sum( 10, 20 ))\nprint (\"相加后的值为 : \", sum( 20, 20 ))\n```\n\n以上实例输出结果：\n\n```python\n相加后的值为 :  30\n相加后的值为 :  40\n```\n\n3. 可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。\n\n以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：\n\n```python\ndef myfunc(n):\n  return lambda a : a * n\n \nmydoubler = myfunc(2)\nmytripler = myfunc(3)\n \nprint(mydoubler(11))\nprint(mytripler(11))\n```\n\n以上实例输出结果：\n\n```python\n22\n33\n```\n\n## 18.6 return 语句\n\nreturn [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。\n\n## 18.7 强制位置参数\n\nPython3.8 新增了一个函数形参语法 `/` 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。\n\n在以下的例子中，**形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参**:\n\n```python\ndef f(a, b, /, c, d, *, e, f):\n    print(a, b, c, d, e, f)\n```\n\n- 以下使用方法是正确的:\n\n```python\nf(10, 20, 30, d=40, e=50, f=60)\n```\n\n- 以下使用方法会发生错误:\n\n```python\nf(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式\nf(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式\n```\n\n# 19. 数据结构\n\n## 19.1 列表\n\nPython中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。\n\n|方法|描述|\n|-|-|\n|list.append(x)|把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。|\n|list.extend(L)|通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。|\n|list.insert(i, x)|在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。|\n|list.remove(x)|删除列表中值为 x 的**第一个元素**。如果没有这样的元素，就会返回一个错误。|\n|list.pop([i])|从列表的指定位置移除元素，**并将其返回**。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的**方括号**表示这个**参数是可选**的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）|\n|list.clear()|移除列表中的所有项，等于del a[:]。|\n|list.index(x)|返回列表中**第一个值为 x 的元素的索引**。如果没有匹配的元素就会返回一个错误。|\n|list.count(x)|返回 x 在列表中出现的次数。|\n|list.sort()|对列表中的元素进行排序。|\n|list.reverse()|倒排列表中的元素。|\n|list.copy()|返回列表的浅复制，等于a[:]。|\n\n> 注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。\n\n## 19.2 将列表当做堆栈使用\n\n列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 `append()` 方法可以把一个元素添加到堆栈顶。用不指定索引的 `pop()` 方法可以把一个元素从堆栈顶释放出来。\n\n## 19.3 将列表当作队列使用\n\n也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。\n\n## 19.4 列表推导式\n\n列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。\n\n每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。\n\n一些关于循环和其它技巧的演示：\n\n```python\n>>> vec1 = [2, 4, 6]\n>>> vec2 = [4, 3, -9]\n>>> [x*y for x in vec1 for y in vec2]\n[8, 6, -18, 16, 12, -36, 24, 18, -54]\n>>> [x+y for x in vec1 for y in vec2]\n[6, 5, -7, 8, 7, -5, 10, 9, -3]\n>>> [vec1[i]*vec2[i] for i in range(len(vec1))]\n[8, 12, -54]\n```\n\n列表推导式可以使用复杂表达式或嵌套函数：\n\n```python\n>>> [str(round(355/113, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n```\n\n> round() 方法返回浮点数x的四舍五入值。\n> 语法： `round( x [, n]  )`\n> 参数：x -- 数值表达式。n -- 数值表达式，表示从小数点位数。\n> 返回值：返回浮点数x的四舍五入值。\n\n## 19.5 嵌套列表解析\n\nPython的列表还可以嵌套。\n\n以下实例展示了3X4的矩阵列表：\n\n```python\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\n```\n\n以下实例将3X4的矩阵列表转换为4X3列表：\n\n```python\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n\n也可以使用以下方法来实现：\n\n```python\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n\n另外一种实现方法：\n\n```python\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n\n## 19.6 del 语句\n使用 del 语句可以从一个列表中根据**索引**来删除一个元素，而不是值来删除元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：\n\n```python\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\n```\n\n也可以用 del 删除实体变量：\n\n```python\n>>> del a\n```\n\n## 19.7 元组和序列\n\n元组由若干逗号分隔的值组成，例如：\n\n```python\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n... u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n```\n\n如上所示，元组在输出时总是有括号的，以便于正确表达嵌套结构。**在输入时可能有或没有括号**， *不过括号通常是必须的（如果元组是更大的表达式的一部分）*。\n\n## 19.8 集合\n\n集合是一个**无序不重复元素的集**。基本功能包括**关系测试**和**消除重复元素**。\n\n可以用大括号(`{}`)创建集合。注意：如果要创建一个空集合，你必须用 `set()` 而不是 `{}` ；后者创建一个空的字典。\n\n集合也支持推导式。\n\n## 19.9 字典\n\n另一个非常有用的 Python 内建数据类型是字典。\n\n序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。\n\n理解字典的最佳方式是把它看做无序的键=>值对集合。在同一个字典之内，关键字必须是互不相同。\n\n一对大括号创建一个空的字典：`{}`。\n\n1. 构造函数 `dict()` 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：\n\n```python\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n```\n\n2. 此外，字典推导可以用来创建任意键和值的表达式词典：\n\n```python\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n```\n\n3. 如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：\n\n```python\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n```\n\n## 19.10 遍历技巧\n\n1. 在字典中遍历时，关键字和对应的值可以使用 `items()` 方法同时解读出来：\n\n```python\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\n```\n\n2. 在序列中遍历时，索引位置和对应值可以使用 `enumerate()` 函数同时得到：\n\n```python\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\n```\n\n3. 同时遍历两个或更多的序列，可以使用 `zip()` 组合：\n\n```python\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\n```\n\n> zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后**返回由这些元组组成的对象**，这样做的好处是*节约了不少的内存*。\n> 我们可以使用 list() 转换来输出列表。\n> 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。\n\n> Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。\n> 基本语法是通过 {} 和 : 来代替以前的 % 。\n> format 函数可以接受不限个参数，位置可以不按顺序。\n\n4. 要反向遍历一个序列，首先指定这个序列，然后调用 `reversed()` 函数：\n\n```python\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\n```\n\n5. 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：\n\n```python\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\n```\n\n> set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。\n> 语法：`class set([iterable])`\n> 参数说明：iterable -- 可迭代对象对象；\n> 返回值：返回新的集合对象\n\n\n# 20. 模块\n# 21. 输入和输出\n# 22. File\n# 23. OS\n# 24. 错误和异常\n# 25. 面向对象\n# 26. 命名空间/作用域\n# 27. 标准库概览\n","tags":["开发语言"],"categories":["Python"]},{"title":"Python2 基础","url":"/article/Python2.html","content":"\n# 1. 基础语法\n\n## 1.1 行和缩进\n\n学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。\n\n缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。\n\n## 1.2 多行语句\n\nPython语句中一般以新行作为语句的结束符。\n\n但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示：\n```python\ntotal = item_one + \\\n        item_two + \\\n        item_three\n```\n\n语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：\n```python\ndays = ['Monday', 'Tuesday', 'Wednesday',\n        'Thursday', 'Friday']\n```\n\n## 1.3 Python空行\n\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n\n空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n记住：**空行也是程序代码的一部分**。\n\n## 1.4 同一行显示多条语句\n\nPython可以在同一行中使用多条语句，语句之间使用**分号(`;`)**分割，以下是一个简单的实例：\n\n```pyhton\nimport sys; x = 'runoob'; sys.stdout.write(x + '\\n')\n```\n\n## 1.5 print输出\n\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号` ,`。\n```python\nx=\"a\"\ny=\"b\"\n# 换行输出\nprint x\nprint y\n\nprint '---------'\n# 不换行输出\nprint x,\nprint y,\n\n# 不换行输出\nprint x,y\n```\n\n# 2. 变量类型\n\n## 2.1 变量赋值\n\nPython 中的变量赋值不需要类型声明。\n\n每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。\n\n**每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。**\n\n等号 `=` 用来给变量赋值。\n\n等号`=` 运算符左边是一个变量名，等号 `=` 运算符右边是存储在变量中的值。\n\n## 2.2 多个变量赋值\n\nPython允许你同时为多个变量赋值。例如：\n\n```python\na = b = c = 1\n```\n\n以上实例，创建一个整型对象，值为1，**三个变量被分配到相同的内存空间上**。\n\n也可以为多个对象指定多个变量。例如：\n\n```python\na, b, c = 1, 2, \"john\"\n```\n\n以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 \"john\" 分配给变量 c。\n\n## 2.3 标准数据类型\n\n在内存中存储的数据可以有多种类型。\n\n例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。\n\nPython 定义了一些标准类型，用于存储各种类型的数据。\n\nPython有五个标准的数据类型：\n\n- Numbers（数字）\n- String（字符串）\n- List（列表）\n- Tuple（元祖）\n- Dictionary（字典）\n\n## 2.4 Python 数字\n\n数字数据类型用于存储数值。\n\n**他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。**\n\n当你指定一个值时，Number 对象就会被创建。\n\n也可以使用del语句删除一些对象的引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n还可以通过使用del语句删除单个或多个对象的引用。例如：\n```python\ndel var\ndel var_a, var_b\n```\n\nPython支持四种不同的数字类型：\n\n- int（有符号整型）\n- long（长整型，也可以代表八进制和十六进制）\n- float（浮点型）\n- complex（复数）\n\nTips：\n\n- 长整型也可以使用小写 l，但是还是建议使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。\n- Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。\n\n> **注意：** long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。\n> \n\n## 2.5 Python 字符串\n\n字符串或串(String)是由数字、字母、下划线组成的一串字符。它是编程语言中表示文本的数据类型。\n\npython的字串列表有2种取值顺序:\n\n- 从左到右索引默认0开始的，最大范围是字符串长度少1\n- 从右到左索引默认-1开始的，最大范围是字符串开头\n\n![](Python2/python-string-slice.png)\n\n如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。\n\n[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。 ==>  **左闭右开**\n\n比如:\n\n```python\n>>> s = 'abcdef'\n>>> s[1:5]\n'bcde'\n>>> s[-3:]\n'def'\n```\n\n**加号（+）是字符串连接运算符，星号（*）是重复操作。**如下实例：\n\n```python\nstr = 'Hello World!'\n \nprint str           # 输出完整字符串\nprint str[0]        # 输出字符串中的第一个字符\nprint str[2:5]      # 输出字符串中第三个至第六个之间的字符串\nprint str[2:]       # 输出从第三个字符开始的字符串\nprint str * 2       # 输出字符串两次\nprint str + \"TEST\"  # 输出连接的字符串\n```\n\n以上实例输出结果：\n```python\nHello World!\nH\nllo\nllo World!\nHello World!Hello World!\nHello World!TEST\n```\n\nPython 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n![](Python2/python_list_slice_2.png)\n\n## 2.6 Python 列表\n\nList（列表） 是 Python 中使用最频繁的数据类型。\n\n列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。\n\n列表用 `[ ]`  标识，是 python 最通用的复合数据类型。\n\n列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。\n\n![](Python2/list_slicing1_new1.png)\n\n**加号 + 是列表连接运算符，星号 * 是重复操作。**如下实例：\n\n```python\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntinylist = [123, 'john']\n \nprint list               # 输出完整列表\nprint list[0]            # 输出列表的第一个元素\nprint list[1:3]          # 输出第二个至第三个元素 \nprint list[2:]           # 输出从第三个开始至列表末尾的所有元素\nprint tinylist * 2       # 输出列表两次\nprint list + tinylist    # 打印组合的列表\n```\n\n以上实例输出结果：\n```python\n['runoob', 786, 2.23, 'john', 70.2]\nrunoob\n[786, 2.23]\n[2.23, 'john', 70.2]\n[123, 'john', 123, 'john']\n['runoob', 786, 2.23, 'john', 70.2, 123, 'john']\n```\n\n## 2.7 Python 元组\n元组是另一个数据类型，类似于 List（列表）。\n\n元组用 `( ) ` 标识。内部元素用逗号隔开。**但是元组不能二次赋值，相当于只读列表。**\n\n```python\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\ntinytuple = (123, 'john')\n \nprint tuple               # 输出完整元组\nprint tuple[0]            # 输出元组的第一个元素\nprint tuple[1:3]          # 输出第二个至第四个（不包含）的元素 \nprint tuple[2:]           # 输出从第三个开始至列表末尾的所有元素\nprint tinytuple * 2       # 输出元组两次\nprint tuple + tinytuple   # 打印组合的元组\n```\n\n以上实例输出结果：\n\n```python\n('runoob', 786, 2.23, 'john', 70.2)\nrunoob\n(786, 2.23)\n(2.23, 'john', 70.2)\n(123, 'john', 123, 'john')\n('runoob', 786, 2.23, 'john', 70.2, 123, 'john')\n```\n\n**以下对元组的操作是无效的，因为元组不允许更新，而列表是允许更新的：**\n\n```python\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntuple[2] = 1000    # 元组中是非法应用\nlist[2] = 1000     # 列表中是合法应用\n```\n\n元组是不允许更新的，所以以上代码执行错误，结果如下：\n\n```python\nTraceback (most recent call last):\n  File \"test.py\", line 6, in <module>\n    tuple[2] = 1000    # 元组中是非法应用\nTypeError: 'tuple' object does not support item assignment\n```\n\n## 2.8 Python 字典\n字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。**列表是有序的对象集合，字典是无序的对象集合。**\n\n两者之间的区别在于：字典当中的**元素是通过键来存取的，而不是通过偏移存取。**\n\n字典用 `{ }` 标识。字典由 **索引(key)** 和它对应的 **值value** 组成。\n\n```python\ndict = {}\ndict['one'] = \"This is one\"\ndict[2] = \"This is two\"\n \ntinydict = {'name': 'runoob','code':6734, 'dept': 'sales'}\n \n \nprint dict['one']          # 输出键为'one' 的值\nprint dict[2]              # 输出键为 2 的值\nprint tinydict             # 输出完整的字典\nprint tinydict.keys()      # 输出所有键\nprint tinydict.values()    # 输出所有值\n```\n\n输出结果为：\n\n```python\nThis is one\nThis is two\n{'dept': 'sales', 'code': 6734, 'name': 'runoob'}\n['dept', 'code', 'name']\n['sales', 6734, 'runoob']\n```\n\n## 2.9 Python 数据类型转换\n有时候，我们需要对数据内置的类型进行转换，**数据类型的转换，你只需要将数据类型作为函数名即可**。\n\n以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。\n\n|函数|描述|备注|\n|-|-|-|\n|int(x [,base])|将x转换为一个整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|long(x [,base])|将x转换为一个长整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|float(x)|将x转换到一个浮点数||\n|complex(real [,imag])|创建一个复数|real -- int, long, float或字符串；imag -- int, long, float；|\n|str(x)|将对象 x 转换为字符串||\n|repr(x)|将对象 x 转换为表达式字符串||\n|eval(str)|用来计算在字符串中的有效Python表达式,并返回一个对象||\n|tuple(s)|将序列 s 转换为一个元组||\n|list(s)|将序列 s 转换为一个列表||\n|set(s)|转换为可变集合||\n|dict(d)|创建一个字典。d 必须是一个序列 (key,value)元组。||\n|frozenset(s)|转换为不可变集合||\n|chr(x)|将一个整数转换为一个字符||\n|unichr(x)|将一个整数转换为Unicode字符||\n|ord(x)|将一个字符转换为它的整数值||\n|hex(x)|将一个整数转换为一个十六进制字符串||\n|oct(x)|将一个整数转换为一个八进制字符串||\n\n# 3. 运算符\n\nPython语言支持以下类型的运算符:\n\n- 算术运算符\n- 比较（关系）运算符\n- 赋值运算符\n- 逻辑运算符\n- 位运算符\n- 成员运算符\n- 身份运算符\n- 运算符优先级\n\n## 3.1 算术运算符\n\n以下假设变量： a=10，b=20：\n\n|运算符|描述|实例|\n|-|-|-|\n|%|取模 - 返回除法的余数|b % a 输出结果 0|\n|\\*\\*|幂 - 返回x的y次幂|a\\*\\*b 为10的20次方， 输出结果 100000000000000000000|\n|//|取整除 - 返回商的整数部分（**向下取整**）|9//2 输出 4 ; -9//2 输出 -5|\n\n> **注意：**  `Python2.x` 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。\n> 在 `Python 3.x` 中 / 除法不再这么做了，对于整数之间的相除，结果也会是浮点数。\n\n## 3.2 位运算符\n\n按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n\n下表中变量 a 为 60，b 为 13，二进制格式如下：\n\n```python\na = 0011 1100\n\nb = 0000 1101\n\n-----------------\n\na&b = 0000 1100\n\na|b = 0011 1101\n\na^b = 0011 0001\n\n~a  = 1100 0011\n```\n|运算符|描述|实例|\n|-|-|-|\n|&|按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0|(a & b) 输出结果 12 ，二进制解释： 0000 1100|\n|\\||按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。|(a | b) 输出结果 61 ，二进制解释： 0011 1101|\n|^|按位异或运算符：当两对应的二进位相异时，结果为1|(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|\n|~|按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|\n|<<|左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。|a << 2 输出结果 240 ，二进制解释： 1111 0000|\n|>>|右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|\n\n## 3.3 逻辑运算符\n\nPython语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n> **注意：** 关注and、or的返回值问题\n\n|运算符|逻辑表达式|描述|实例|\n|-|-|-|-|\n|and|x and y|布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它**返回 y 的计算值**。|(a and b) 返回 20。|\n|or|x or y|布尔\"或\" - **如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。**|(a or b) 返回 10。|\n|not|not x|布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|not(a and b) 返回 False|\n\n## 3.4 成员运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|in|如果在指定的序列中找到值返回 True，否则返回 False。|x 在 y 序列中 , 如果 x 在 y 序列中返回 True。|\n|not in|如果在指定的序列中没有找到值返回 True，否则返回 False。|x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。|\n\n## 3.5 身份运算符\n\n身份运算符用于比较两个对象的存储单元\n\n|运算符|描述|实例|\n|-|-|-|\n|is|is 是判断两个标识符是不是引用自一个对象|x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False|\n|is not|is not 是判断两个标识符是不是引用自不同对象|x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。|\n\n>注： id() 函数用于获取对象内存地址。\n>id() 函数返回对象的唯一标识符，标识符是一个整数。CPython 中 id() 函数用于获取对象的内存地址\n>id 语法：id([object])，参数说明：object -- 对象。\n\n### is 与 == 区别：\n\n**is **用于判断两个变量引用对象是否为**同一个(同一块内存空间)**，**==**用于判断引用变量的**值是否相等**。\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a \nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\n## 3.6 运算符优先级\n\n以下表格列出了从最高到最低优先级的所有运算符：\n\n|运算符|描述|\n|-|-|\n|\\*\\*|指数 (最高优先级)|\n|~ + -|按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)|\n|\\* / % //|乘，除，取模和取整除|\n|+ -|加法减法|\n|>> <<|右移，左移运算符|\n|&|位 'AND'|\n|^ |\t位运算符|\n|<= < > >=|比较运算符|\n|<> == !=|等于运算符|\n|= %= /= //= -= += \\*= \\*\\*=|赋值运算符|\n|is is not|身份运算符|\n|in not in|成员运算符|\n|not and or|逻辑运算符|\n\n# 4. 条件语句\n\nPython条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。\n\n可以通过下图来简单了解条件语句的执行过程:\n\n![](Python2/if-condition.jpg)\n\nPython程序语言指定任何非0和非空（null）值为true，0 或者 null为false。\n\n> tips: null是false\n\nPython 编程中 if 语句用于控制程序的执行，基本形式为：\n\n```python\nif 判断条件：\n    执行语句……\nelse：\n    执行语句……\n```\n\n其中\"判断条件\"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。\n\nelse 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。\n\nGif 演示：\n\n![](Python2/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif)\n\nif 语句的判断条件可以用>（大于）、<(小于)、==（等于）、>=（大于等于）、<=（小于等于）来表示其关系。\n\n当判断条件为多个值时，可以使用以下形式：\n\n```python\nif 判断条件1:\n    执行语句1……\nelif 判断条件2:\n    执行语句2……\nelif 判断条件3:\n    执行语句3……\nelse:\n    执行语句4……\n```\n\n**由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现**，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。\n\n当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于>（大于）、<（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。\n\n### 简单的语句组\n\n也可以在同一行的位置上使用if条件判断语句，如下实例：\n\n```python\nvar = 100 \n \nif ( var  == 100 ) : print \"变量 var 的值为100\" \n \nprint \"Good bye!\"\n```\n\n以上代码执行输出结果如下：\n\n```python\n变量 var 的值为100\nGood bye!\n```\n\n\n# 5. 循环语句\n\n程序在一般情况下是按顺序执行的。编程语言提供了各种控制结构，允许更复杂的执行路径。\n循环语句允许我们执行一个语句或语句组多次，下面是在大多数编程语言中的循环语句的一般形式：\n\n![](Python2/loop.png)\n\n## 5.1 循环类型\n\nPython 提供了 for 循环和 while 循环**（在 Python 中没有 do..while 循环）**:\n\n|循环类型|描述|\n|-|-|\n|while 循环|在给定的判断条件为 true 时执行循环体，否则退出循环体。|\n|for 循环|重复执行语句|\n|嵌套循环|你可以在while循环体中嵌套for循环|\n\n## 5.2 循环控制语句\n\n循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：\n\n|控制语句|描述|\n|-|-|\n|break 语句|在语句块执行过程中终止循环，并且跳出整个循环|\n|continue 语句|在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。|\n|pass 语句|pass是空语句，是为了保持程序结构的完整性。|\n\n# 6. While循环语句\n\n## 6.1 基本形式\nPython 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：\n\n```python\nwhile 判断条件(condition)：\n    执行语句(statements)……\n```\n\n执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。\n\n当判断条件假 false 时，循环结束。\n\n执行流程图如下：\n\n![](Python2/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg)\n\n## 6.2 Gif 演示 Python while 语句执行过程\n\n![](Python2/006faQNTgw1f5wnm06h3ug30ci08cake.gif)\n\n复杂一点\n\n![](Python2/loop-over-python-list-animation.gif)\n\nwhile 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外\"判断条件\"还可以是个常值，表示循环必定成立。\n\n## 6.3 无限循环\n\n如果条件判断语句永远为 true，循环将会无限的执行下去。\n\n> 注意：无限循环可以使用 CTRL+C 来中断循环。\n\n## 6.4 循环使用 else 语句\n\n在 python 中，while … else 在**循环条件为 false 时执行 else 语句块**：\n\n```python\ncount = 0\nwhile count < 5:\n   print count, \" is  less than 5\"\n   count = count + 1\nelse:\n   print count, \" is not less than 5\"\n```\n\n以上实例输出结果为：\n```python\n0 is less than 5\n1 is less than 5\n2 is less than 5\n3 is less than 5\n4 is less than 5\n5 is not less than 5\n```\n\n## 6.5 简单语句组\n\n类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：\n\n```python\nflag = 1\n \nwhile (flag): print 'Given flag is really true!'\n \nprint \"Good bye!\"\n```\n\n> 注意：以上的无限循环可以使用 CTRL+C 来中断循环。\n\n\n\n# 7. for循环语句\n\n# 8. 循环嵌套\n# 9. break语句\n# 10. continue语句\n# 11. pass语句\n# 12. Number（数字）\n# 13. 字符串\n# 14. 列表（List）\n# 15. 元祖\n# 16. 字典（Dictionary）\n# 17. 日期和时间\n# 18. 函数\n# 19. 模块\n# 20. 文件I/O\n# 21. File 方法\n# 22. 异常处理\n# 23. OS 文件/目录方法\n# 24. 内置函数\n\n\n\n\n\n\n\n\n\n","tags":["开发语言"],"categories":["Python"]},{"title":"Python 简介","url":"/article/Python-introduction.html","content":"\n\n# 1. Python 起源\n\n## 1.1 解释器\n\n**计算机不能直接理解任何除机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**。  \n编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器**以解释方式运行的时候**，也称之为**解释器**。  \n![](Python-introduction/编译型和解释型语言工作对比.png)  \n\n- **编译型语言**：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++。  \n- **解释型语言**：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行。  \n\n## 1.2 Python 特点\n\n* Python 是**完全面向对象的语言**\n  * **函数**、**模块**、**数字**、**字符串**都是对象，**在 Python 中一切皆对象**\n  * 完全支持继承、重载、多重继承\n  * 支持重载运算符，也支持泛型设计\n* Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字**、**字符串**、**列表**、**字典**、**文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理**、**网络通信**、**文本处理**、**数据库接口**、**图形系统**、**XML 处理** 等额外的功能。\n* Python 社区提供了**大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算**、**人工智能**、**机器学习**、**Web 开发**、**数据库接口**、**图形系统** 多个领域。\n\n## 1.3 Python 的优缺点\n\n- **优点**\n  - 简单、易学\n  - 免费、开源\n  - **面向对象**\n  - 丰富的库\n  - 可扩展性\n    - 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 `C` 或 `C++` 编写，然后在 `Python` 程序中使用它们\n  - ……\n- **缺点**\n  - 运行速度\n  - 国内市场较小\n  - 中文资料匮乏\n\n# 2. Python 程序\n\n1. Python 源程序就是**一个特殊格式的文本文件**，可以**使用任意文本编辑软件**做 `Python` 的开发\n2. Python 程序的 **文件扩展名** 通常都是 `.py`\n\n**Tips:（报错提示）**\n\n- error 错误\n- name 名字\n- defined 已经定义\n- syntax 语法\n- invalid 无效\n- Indentation 索引\n- unexpected 意外的，不期望的\n- character 字符\n- line 行\n- encoding 编码\n- declared 声明\n- details 细节，详细信息\n- ASCII 一种字符编码\n\n# 3. `Python 2.x` 与 `3​​.x` 版本简介\n\n目前市场上有两个 Python 的版本并存着，分别是 `Python 2.x` 和 `Python 3.x`\n\n> 新的 Python 程序建议使用 `Python 3.0` 版本的语法\n\n* Python 2.x 是 **过去的版本**\n  * 解释器名称是 **python**\n* Python 3.x 是 **现在和未来 主流的版本**\n  * 解释器名称是 **python3**\n  * 相对于 `Python` 的早期版本，这是一个 **较大的升级**\n  * 为了不带入过多的累赘，`Python 3.0` 在设计的时候 **没有考虑向下兼容**\n    * 许多早期 `Python` 版本设计的程序都无法在 `Python 3.0` 上正常执行\n  * Python 3.0 发布于 **2008 年**\n  * 到目前为止，Python 3.0 的稳定版本已经有很多年了\n    * Python 3.3 发布于 2012\n    * Python 3.4 发布于 2014\n    * Python 3.5 发布于 2015\n    * Python 3.6 发布于 2016\n* 为了照顾现有的程序，官方提供了一个过渡版本 —— **Python 2.6**\n  * 基本使用了 `Python 2.x` 的语法和库\n  * 同时考虑了向 `Python 3.0` 的迁移，**允许使用部分** `Python 3.0` 的语法与函数\n  * 2010 年中推出的 `Python 2.7` 被确定为 **最后一个Python 2.x 版本**\n\n> 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议\n>\n> * 先使用 `Python 3.0` 版本进行开发\n> * 然后使用 `Python 2.6`、`Python 2.7` 来执行，并且做一些兼容性的处理\n\n# 4. 执行 Python 程序的三种方式\n\n## 4.1  解释器 `python` / `python3`\n\n### 1) Python 的解释器\n\n```bash\n# 使用 python 2.x 解释器\n$ python xxx.py\n\n# 使用 python 3.x 解释器\n$ python3 xxx.py\n```\n\n### 2) 其他解释器\n\n**Python 的解释器** 如今有多个语言的实现，包括：\n\n- `CPython` —— 官方版本的 C 语言实现\n- `Jython` —— 可以运行在 Java 平台\n- `IronPython` —— 可以运行在 .NET 和 Mono 平台\n- `PyPy` —— Python 实现的，支持 JIT 即时编译\n\n## 4.2 交互式运行 Python 程序\n\n- 直接在终端中运行解释器，而不输入要执行的文件名\n- 在 Python 的 `Shell` 中直接输入 **Python 的代码**，会立即看到程序执行结果\n\n### 1) 交互式运行 Python 的优缺点\n\n- **优点**\n  - 适合于学习/验证 Python 语法或者局部代码\n- **缺点**\n  - 代码不能保存\n  - 不适合运行太大的程序\n\n### 2) 退出 官方的解释器\n\n- 1> 直接输入 `exit()`\n\n```python\n>>> exit()\n```\n\n- 2> 使用热键退出\n  在 python 解释器中，按热键 `ctrl + d` 可以退出解释器\n\n### 3) IPython\n\n- IPython 中 的 “I” 代表 **交互 interactive**\n\n**特点**\n\n- IPython 是一个 python 的 **交互式 shell**，比默认的 `python shell` 好用得多\n  - 支持自动补全\n  - 自动缩进\n  - 支持 `bash shell` 命令\n  - 内置了许多很有用的功能和函数\n- IPython 是基于 BSD 开源的\n\n**版本**\n\n- Python 2.x 使用的解释器是 **ipython**\n- Python 3.x 使用的解释器是 **ipython3**\n\n**要退出解释器可以有以下两种方式：**\n\n- 1> 直接输入 `exit`\n\n```python\nIn [1]: exit\n```\n\n- 2> 使用热键退出\n  在 IPython 解释器中，按热键 `ctrl + d`，`IPython` 会询问是否退出解释器\n\n## 4.3. Python 的 IDE —— `PyCharm`\n\n### 1） 集成开发环境（IDE）\n\n集成开发环境（`IDE`，Integrated Development Environment）—— **集成了开发软件需要的所有工具**，一般包括以下工具：\n\n- 图形用户界面\n- 代码编辑器（支持 **代码补全**／**自动缩进**）\n- 编译器／解释器\n- 调试器（**断点**／**单步执行**）\n- ……\n\n### 2）PyCharm 介绍\n\n- `PyCharm` 是 Python 的一款非常优秀的集成开发环境\n- `PyCharm` 除了具有一般 IDE 所必备功能外，还可以在 `Windows`、`Linux`、`macOS` 下使用\n- `PyCharm` 适合开发大型项目\n  - 一个项目通常会包含 **很多源文件**\n  - 每个 **源文件** 的代码行数是有限的，通常在几百行之内\n  - 每个 **源文件** 各司其职，共同完成复杂的业务功能","tags":["开发语言"],"categories":["Python"]},{"title":"Perceptron","url":"/article/Perceptron.html","content":"\n\n# 1 感知器模型\n## 1.1 起源\n感知器模型与算法由美国科学家 Frank Rosenblatt 于 1958 年提出，最早用于解决图像分类问题。我们把向量 $ \\begin{equation} x = (x_1, x_2, ... , x_n)^T \\end{equation} $ 称为模式（Pattern）或特征（Feature）向量，比如 $ \\begin{equation} x_i \\end{equation} $ 表示图像中第 i 个像素的亮度。标量 y 称为类别标号（Class label）。感知器可以把一个模式 x 区分为两个不同的类别 $ \\begin{equation} (y = -1, +1) \\end{equation} $ ，这个过程称为分类（Classification）。\n\n## 1.2 定义\n假设输入空间（特征空间）是 $ \\begin{equation} \\mathcal{X} \\in R^n \\end{equation} $ ，输出空间是 $ \\begin{equation} \\mathcal{Y} \\in \\lbrace -1, 1 \\rbrace \\end{equation} $ ，其中输入 $ \\begin{equation} x \\in \\mathcal{X} \\end{equation} $ 表示实例的特征向量，对应于输入空间（特征空间）的点，输出 $ \\begin{equation} y \\in \\mathcal{Y} \\end{equation} $ 表示实例的类别，有输入空间到输出空间的函数：\n$$ \\begin{equation} \ng(x; w, b) = sgn(w^Tx + b) \n\\end{equation} $$\n称为感知器。其中 **g** 称为决策函数，**sgn** 称为符号函数：\n$$ \\begin{equation} \nsgn(x) = \n\\begin{cases}\n\\ \\ \\ 1, &x \\geqslant 0\\\\\n-1, &x < 0\n\\end{cases}\n\\end{equation} $$\n由判别函数得到一个方程：\n$$ \\begin{equation} \n\\mathcal{f} (x; w, b) = w^Tx + b = 0\n\\end{equation} $$\n该方程是一个线性方程，表示 d 维空间的一个超平面（hyper-plane），称为决策面（Decision Boundary），把该空间划分两半，位于该决策面一侧的样本 **x** 为正样本（**y** = 1）、位于另一侧的样本为负样本（**y**  = -1），**w** 为该超平面的法向量，**b** 为位置偏置。图 1 展示了 d = 2 时的情况。\n![图1 线性决策面](Perceptron/图1_线性决策面.jpg)\n<center><p>图1 线性决策面</p></center>\n由于 d 维感知器的决策面是一个超平面，因此一个感知器只能对可以用超平面分隔的样本进行区分，如果样本的分布不能用线性超平面区分（线性不可分），那么单个感知器就无法起作用。比如图 2 中的红色与蓝色样本，是线性不可分的。\n![图2 线性不可分](Perceptron/图2_线性不可分.jpg)\n\n<center><p>图2 线性不可分</p></center>\n\n\n# 2 感知器学习算法\n\n## 2.1 定义\n感知器模型由参数 $ \\begin{equation} \\Theta  = (w, b ) \\end{equation} $ 决定。但是在很多问题中，这些参数无法由人工决定。比如，图像分类中，权值 $ \\begin{equation} w_i \\end{equation} $ 表示第i个像素的权值，这个权值很难由人工分析确定。因此需要有一种方法能自动确定这些参数。在机器学习中，如果给定一组已知类别标号的样本集 $ \\begin{equation} D = \\lbrace (x^{(i)}, y^{(i)}) \\rbrace (i = 1, 2, ..., n) \\end{equation} $ ，那么可以从这组样本中学习（Learning）/训练（Training）出模型的参数 $ \\begin{equation} \\Theta \\end{equation} $ 。\n**感知器学习算法**（Perceptron Learning Algorithm，PLA）是 Rosenblatt 给出的一个用于学习感知器模型的算法。该算法是一个迭代算法，首先初化模型参数为 **w** = 0，**b** = 0，假设第 t 步得到的模型参数为 $ \\begin{equation} \\Theta  = (w, b ) \\end{equation} $ ，在 t + 1 步，从 **D** 中选取一个样本 $ \\begin{equation} (x^{(j)}, y^{(j)}) \\end{equation} $ ，用当前模型参数代入感知器中对该样本进行分类，得到分类结果为 $ \\begin{equation} \\bar y \\end{equation} $ 。如果分类正确（ $ \\begin{equation} \\bar y = y^{(j)} \\end{equation} $ ），那么权值不变；如果分类错误（ $ \\begin{equation} \\bar y \\neq y^{(j)} \\end{equation} $ ），根据类别标号  $ \\begin{equation} y = y^{(j)} \\end{equation} $  对权值做如下更新：\n$$\\begin{equation}\\begin{split} \n&w \\leftarrow w + y^{(j)}x^{(j)} \\\\ \n&b \\leftarrow b + y^{(j)}\n\\end{split}\\end{equation}$$  \n\n## 2.2 PLA算法（伪代码）\n下面的伪代码展示了感知器的学习过程：  \n![PLA算法伪代码](Perceptron/PLA算法伪代码.jpg)\n当训练样本集D是线性可分时，上述算法在有限步内能输出一个能对D中所有样本正确分类的模型$ \\begin{equation} g(x; w, b) \\end{equation} $。  \n\n## 2.3 PLA算法实现\n1. 算法思想：对样本集进行**重复迭代**，以实现**逐点修正**。\n\t- ① 获取样本集中本次迭代的样本的预测值  $ \\begin{equation} \\bar y \\end{equation} $ 。\n\t- ② 将预测值 $ \\begin{equation} \\bar y \\end{equation} $ 和该样本的真实值 $ \\begin{equation} y^{(i)} \\end{equation} $ 进行比较。\n\t\t- 分类正确，对样本集中的下一个样本进行预测，即跳转到 ① 处执行，直至样本集中的样本全部迭代，然后跳转至③。\n\t\t- 分类错误，标记出现错误分类，然后对 $ \\begin{equation} \\vec w \\end{equation} $  和 **b** 进行更新，完成后跳转到 ① 处执行，直至样本集中的样本全部迭代，然后跳转至③。\n\t- ③ 若样本集中的所有样本全部迭代，且**未出现错误分类**，即说明当前的权重和偏差值正确，输出此时的 $ \\begin{equation} \\vec w \\end{equation} $  和 **b** 。\n2. Java实现：\n\n- PLA算法核心\n```Java\n// 重复迭代样本集实现逐点修正\nwhile (true){\n    boolean flag = true;    // 错误分类标记（用于判断当前w、b是否可以实现二分类）\n    Collections.shuffle(data);  // 对测试集进行随机排序\n    for (Data d : data) {   // 迭代样本集\n        int y_hat = forecast(weight, b, d); // 预测值\n        int y = d.getY();   // 真实值\n        if (y * y_hat <= 0){  // 判断当前分类是否正确，>0正确\n            flag = false;   // 出现错误分类\n            weight = update(weight, d); // 更新权重\n            b += d.getY();  // 更新偏差值\n        }\n    }\n    if (flag)\t// 本次迭代未出现错误分类\n        break;\n}\n```\n\n- forecast(Weight weight, int b, Data data)方法\n```Java\n/**\n * 计算y_hat(预测值)\n * @param weight    权重\n * @param b         偏差值\n * @param data      数据集\n * @return          返回预测值\n */\npublic static int forecast(Weight weight, int b, Data data){\n    return ((weight.getW1() * data.getX1()) + (weight.getW2() * data.getX2()) + b);\n}\n\n```\n\n- update(Weight weight, Data data)方法\n```Java\n/**\n * 更新权重\n * @param weight    原权重值\n * @param data      数据集\n * @return          返回更新后的权重\n */\npublic static Weight update(Weight weight, Data data){\n    // 获取样本数据\n    int x1 = data.getX1();\n    int x2 = data.getX2();\n\n    // 获取实际值\n    int y = data.getY();\n\n    // 更新权重\n    int newW1 = weight.getW1() + (y * x1);\n    int newW2 = weight.getW2() + (y * x2);\n    weight.setW1(newW1);\n    weight.setW2(newW2);\n    return weight;\n}\n```\n\n- 运行结果\n\n（1）运行结果1  \n![运行结果1](Perceptron/PLA（java实现）运行结果1.jpg)\n\n（2）运行结果2\n![运行结果2](Perceptron/PLA（java实现）运行结果2.jpg)\n\n（3）运行结果3\n![运行结果3](Perceptron/PLA（java实现）运行结果3.jpg)\n\n（4）运行结果4\n![运行结果4](Perceptron/PLA（java实现）运行结果4.jpg)\n\n# 3 总结\n\n- 感知器主要可以解决线性可分的问题，他可以用来解决**二分类问题**，其具有如下的优点和缺点：\n\t- 优点：相较于其他模型，感知器模型简单，易于实现。\n\t- 缺点：\n\t\t- PLA算法每一次运行的结果不一致（不稳定），所以无法完美的处理线性不可分的训练集（数据）。\n\t\t- 感知机中的损失函数（衡量预测值与真实值之间的误差）的目标只是减小所有误分类点与超平面，最终很有可能导致部分样本点距离超平面很近。所以通过PLA得到的只是一个近似最优解的解，并不能得到最优解。\n- 导致PLA算法第一个缺点的主要原因是因为该算法的基本原理是**逐点修正**。首先，在超平面上随意取一条分类面，统计分类错误的点，然后随机对某个错误点进行修正，也就是改变直线的位置，使该错误点得以修正；接着再随机选一个错误点进行纠正，分类面不断变化，直到所有的点都完全分类正确了，就得到了最佳的分类面。正是因为每次运行PLA算法进行的是一种随机修正，所以得到的结果不一样。\n- PLA算法的第二个确定可以通过**SVM**（支持向量机）解决，另外SVM也可以很好地解决线性不可分问题。\n\n\n\n\n\n\n\n\n","tags":["ML（机器学习）","algorithm（算法）","Perceptron（感知器）","linear classification（线性分类）"],"categories":["AI（人工智能）"]}]