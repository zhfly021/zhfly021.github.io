[{"title":"MyBatis-Plus","url":"/article/MyBatis-Plus.html","tags":["MyBatis-Plus"],"categories":["Java"]},{"title":"关于ngrok的配置","url":"/article/ngrok.html","content":"\n# 简介\n\n> 官网：[ngrok](https://ngrok.com/)\n> 技术文档：[docs](https://ngrok.com/docs/what-is-ngrok/)\n\n![image-20240315015337391](./ngrok/image-20240315015337391.png)\n\n- ngrok 是一种全球分布式反向代理，无论您在何处运行应用程序和网络服务，都可以保护和加速您的应用程序和网络服务。您可以将 ngrok 视为应用程序的前门。\n\n- ngrok 是独立于环境的，因为它可以将流量传输到任何地方运行的服务，而无需更改环境的网络。在 AWS、Azure、Heroku、本地 Kubernetes 集群、Raspberry Pi 甚至笔记本电脑上运行您的应用程序。使用 ngrok，一切都是一样的。\n\n- ngrok 是一个统一的入口平台，因为它将所有组件结合在一起，将流量从您的服务传输到互联网。 ngrok 将您的反向代理、负载均衡器、API 网关、防火墙、交付网络、DDoS 防护等整合在一起。\n\n\t> 简而言之，ngrok可以帮助我们将本地主机通过反向代理使得公网可访问，可以解决没有服务器将主机作为临时服务器进行项目部署的一种快捷简单的解决方式。\n\n# 快速上手\n\n1. 下载安装\n\n   支持win、linux、mac、docker，从官网即可[下载](https://ngrok.com/download)，支持以安装包或者命令行的方式进行下载安装。\n\n2. 配置\n\n   需要进行注册，然后进入个人主页获取token信息，可以通过修改配置文件或者命令行的方式进行配置。\n\n   ```cmd\n   ngrok config add-authtoken ***(token)\n   ```\n\n3. 使用（开箱即用）\n\n   - 动态域名\n\n     > 每次使用ngrok做反向代理时都会生成一个新的域名用于公网访问，但是在开发中这种经常变化的域名不便于高效开发。\n\n     ```cmd\n     ngrok http port\n     ```\n\n   - 静态域名\n\n     > 登录ngrok官网，然后在个人主页点击静态域名，即可获取一个固定不变的静态域名（免费用户只有一个）。\n     \n     ```cmd\n     ngrok http --domain=*** port\n     ```\n     \n     \n","tags":["反向代理"],"categories":["server"]},{"title":"java","url":"/article/java.html","tags":["Java"],"categories":["Java"]},{"title":"hadoop","url":"/article/hadoop.html","content":"\nLoading...\n","tags":["Hadoop"],"categories":["BigData"]},{"title":"05. Transformer详解和主要模型概览","url":"/article/Prospective-Graduate-Summer-Training-05.html","content":"\n# 1. 背景介绍\n\n## 1.1 1 vs 1\n\n最基本的单层网络：单个输入单个输出\n\n![](Prospective-Graduate-Summer-Training-05/05-1.jpg)\n\n## 1.2 N vs N: RNN\n\n序列形的数据不太好用原始神经网络处理。为了建模序列问题，RNN引入了隐状态h（hidden state）的概念，h可以对序列形的数据提取特征，接着再转换为输出。h1的计算如下所示：\n\n![](Prospective-Graduate-Summer-Training-05/05-3.jpg)\n\nh2的计算和h1类似。值得注意的是，在计算时，每一步使用的参数U、W、b都是一样的，即每个步骤的参数都是共享的。\n\n![](Prospective-Graduate-Summer-Training-05/05-4.jpg)\n\n依次计算剩下来的（使用相同的参数U、W、b）:\n\nℎ3=𝑓(𝑈𝑥3+𝑊ℎ2+𝑏)\n\nℎ4=𝑓(𝑈𝑥4+𝑊ℎ3+𝑏)\n\n![](Prospective-Graduate-Summer-Training-05/05-5.jpg)\n\n直接通过h进行计算得到RNN的输出：\n\n![](Prospective-Graduate-Summer-Training-05/05-6.jpg)\n\n剩下的输出类似进行（使用和y1同样的参数）\n\n𝑦2=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ2+𝑐)\n\n𝑦3=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ3+𝑐)\n\n𝑦4=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ4+𝑐)\n\n![](Prospective-Graduate-Summer-Training-05/05-7.jpg)\n\n- 计算视频中每一帧的分类标签\n- 输入为字符，输出为下一个字符的概率\n- ……\n\n## 1.3 N vs 1\n\n输入是一个序列，输出一个值，通常用来处理序列分类问题\n\n𝑦=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ4+𝑐)\n\n![](Prospective-Graduate-Summer-Training-05/05-8.jpg)\n\n- 输入一段文字判别它所属的类别\n- 输入一个句子判断其情感倾向\n- 输入一段视频并判断它的类别\n- ……\n\n## 1.4 1 vs N\n\n输入是一个值，输出是一个序列\n\n𝑦1=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ1+𝑐)\n\n𝑦2=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ2+𝑐)\n\n𝑦3=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ3+𝑐)\n\n𝑦4=𝑆𝑜𝑓𝑡𝑚𝑎𝑥(𝑉ℎ4+𝑐)\n\n![](Prospective-Graduate-Summer-Training-05/05-9.jpg)\n\n![](Prospective-Graduate-Summer-Training-05/05-10.jpg)\n\n![](Prospective-Graduate-Summer-Training-05/05-11.jpg)\n\n- 从图像生成文字\n- 从类别生成语音或音乐等\n- ……\n\n## 1.5 N vs M: Sequence-to-sequence(Seq2seq)\n\n输入一个序列，输出一个序列，输出序列的长度由模型决定\n\n![](Prospective-Graduate-Summer-Training-05/05-2.jpg)\n\n输入一个序列，输出一个序列，这种结构又叫Encoder-Decoder模型，也可以称之为Seq2Seq模型\nEncoder-Decoder结构先将输入数据编码（Encoder）成一个上下文向量c：\n\n![](Prospective-Graduate-Summer-Training-05/05-12.jpg)\n\n(1)  𝑐=ℎ4\n\n(2)  𝑐=𝑞(ℎ4)\n\n(3)  𝑐=𝑞(ℎ1,ℎ2,ℎ3,ℎ4)\n\n用另一个RNN网络对其进行解码（Decoder）：\n\n![](Prospective-Graduate-Summer-Training-05/05-13.jpg)\n\n![](Prospective-Graduate-Summer-Training-05/05-14.jpg)\n\nEncoder-Decoder结构不限制输入和输出的序列长度，因此应用的范围非常广泛：\n\n- 机器翻译：Encoder-Decoder最先就是在机器翻译领域最先提出的\n- 文本摘要：输入一段文本序列，输出这段文本序列的摘要序列\n- 阅读理解：将输入的文章和问题分别编码，再对其进行解码得到问题的答案\n- 语音识别：输入是语音信号序列，输出是文字序列\n- ……\n\n## 1.6 Seq2seq\n\n在Seq2Seq结构中，编码器Encoder把所有的输入序列都编码成一个统一的语义向量Context，然后再由解码器Decoder解码。在解码器Decoder解码的过程中，不断地将前一个时刻t-1的输出作为后一个时刻t的输入，循环解码，直到输出停止符为止。\n\n![](Prospective-Graduate-Summer-Training-05/05-15.jpg)\n\n### Seq2seq训练问题\n\n在seq2seq结构中将 𝑦_𝑡作为下一时刻输入𝑥_(𝑡+1) 进网络，那么某一时刻输出 错误就会导致后面全错。在训练时由于网络尚未收敛，这种蝴蝶效应格外明显\nScheduled Sampling：在训练中𝑥_𝑡按照一定概率选择输入 𝑦_(𝑡−1)或 t-1时刻对应的真实值，即标签，既能加快训练速度，也能提高训练精度。\n\n### 基于Attention的Seq2seq\n\n通俗理解Attention：SE模块最终是学习出一个1x1xc的向量，然后逐通道乘以原始输入，从而对特征图的每个通道进行加权即通道注意力\n\n![](Prospective-Graduate-Summer-Training-05/05-16.png)\n\nAttention机制通过在每个时间输入不同的c来解决c长度受限问题，带有Attention机制的Decoder如下图所示：\n\n![](Prospective-Graduate-Summer-Training-05/05-17.jpg)\n\n- 每一个c会自动去选取与当前所要输出的y最合适的上下文信息。\n- 用$ \\begin{equation} a_{ij} \\end{equation} $衡量Encoder中第j阶段的hj和解码时第i阶段的相关性，最终Decoder中第i阶段的输入的上下文信息 ci就来自于hj对 $ \\begin{equation} a_{ij}  \\end{equation} $的加权和\n\n> 如何得到权重$  \\begin{equation} 𝒂_{𝒊𝒋} \\end{equation} $？\n> 从模型中学习，和Decoder的第i-1阶段的隐状态、Encoder第j个阶段的隐状态有关\n\n**基于attention的seq2seq的结构的缺陷：**\n\n- 不管是采用RNN、LSTM还是GRU都不利于并行训练和推理，因为相关算法只能从左向右依次计算或者从右向左依次计算。无法并行训练，不利于大规模快速训练和部署，也不利于整个算法领域发展。\n- 长依赖信息丢失问题，顺序计算过程中信息会丢失，虽然LSTM号称有缓解，但是无法彻底解决\n\n# 2. Transformer\n\n## 2.1 简介\n\nTransformer结合self-attention和cross-attention进行了改进。\n在encode阶段，重点学习输入元素之间的attention。在decode阶段，重点学习的输出查询与encode的结果之间的attention。\n\n![](Prospective-Graduate-Summer-Training-05/05-18.jpg)\n\n![](Prospective-Graduate-Summer-Training-05/05-19.jpg)\n\n### 深入分析\n- Q和所有K计算相似性\n- 对相似性采用softmax转化为概率分布\n- 将概率分布和V进行一一对应相乘，最后相加得到新的和Q一样长的向量输出\n\n### 编码器输入数据处理\n\n- 方法一：开一个很长的One-hot Encoding向量，忽略了词汇与词汇之间的关系\n- 方法二：Word embedding，含有语义信息\n\n> Embedding：任何一个单词，都可以被映射成为唯一的一个N维向量\n\n![](Prospective-Graduate-Summer-Training-05/05-20.jpg)\n\n## 2.2 Positional encoding\n\nTransformer内部没有类似RNN的循环结构，没有捕捉顺序序列的能力，或者说无论句子结构怎么打乱，transformer都会得到类似的结果。为了解决这个问题，在编码词向量时会额外引入了位置编码position encoding向量表示两个单词i和j之间的距离，简单来说就是在词向量中加入了单词的位置信息\n\n- 网络自动学习\n- 自己定义规则\n\n### 网络自动学习\n\n网络自动学习\n\n![](Prospective-Graduate-Summer-Training-05/05-21.png)\n\n比较简单，因为位置编码向量需要和输入embedding(b,N,512)相加，所以其shape为(1,N,512)表示N个位置，每个位置采用512长度向量进行编码\n\n\n### 自己定义规则：sin-cos规则\n\n- 将向量的512维度切分为奇数行和偶数行\n- 偶数行采用sin函数编码，奇数行采用cos函数编码\n- 然后按照原始行号拼接\n\n![](Prospective-Graduate-Summer-Training-05/05-22.png)\n\n## 2.3 Self-Attention\n\n### 编码器前向过程\n\n对于自注意力层self-attention来讲，Q(Query), K(Key), V(Value)三个矩阵均来自同一输入\n\n![](Prospective-Graduate-Summer-Training-05/05-23.png)\n\n1） 从每个编码器的输入向量创建三个向量。分别是查询向量Q、键向量K、值向量V\n2） 通过查询向量与正在评分的各个单词的关键向量的点积来计算分数\n\n### Self-Attention的矩阵计算\n\n1） 计算查询、键和值矩阵。通过将Embedding打包到矩阵X中，并将其乘以训练的权重矩阵（WQ、WK、WV）\n2）计算自注意力层的输出\n\n![](Prospective-Graduate-Summer-Training-05/05-24.png)\n\n### Self-Attention的代码实现\n\n先令 $ \\begin{equation} 𝑸∗𝑲^𝑻 \\end{equation}  $  ，再对结果按位乘以 Mask矩阵，再做 Softmax操作，最后的结果与 V相乘，得到self-attention的输出\n\n![](Prospective-Graduate-Summer-Training-05/05-25.png)\n\n### self-attention vs CNN\n\n- self-attention在处理一张图片的时候，1的那个pixel产生query，其他的各个pixel产生key。在做inner-product的时候，考虑的不是一个小的范围，而是一整张图片。\n- CNN只考虑感受野红框里面的资讯，而不是图片的全局信息。所以CNN可以看作是一种简化版本的self-attention。\n- self-attention是一种复杂化的CNN，在做CNN的时候是只考虑感受野红框里面的信息，而感受野的范围和大小是由人决定的。但是self-attention由attention找到相关的pixel，就好像是感受野的范围和大小是自动被学出来的，所以CNN可以看做是self-attention的特例。\n- self-attention是更广义的CNN，则这个模型更加flexible。一个模型越flexible，训练它所需要的数据量就越多，所以在训练self-attention模型时就需要更多的数据，这一点在下面介绍的论文 ViT 中有印证，它需要的数据集是有3亿张图片的JFT-300，而如果不使用这么多数据而只使用ImageNet，则性能不如CNN。\n\n![](Prospective-Graduate-Summer-Training-05/05-26.png)\n\n## 2.4 Multi-head Self-Attention\n\n- 它扩展了模型关注不同位置的能力\n- 为注意力层提供了多个“表示子空间”\n\n### Multi-head Self-Attention的代码实现\n\n![](Prospective-Graduate-Summer-Training-05/05-28.png)\n\n![](Prospective-Graduate-Summer-Training-05/05-29.png)\n\n### 前馈神经网络层的代码实现\n\n![](Prospective-Graduate-Summer-Training-05/05-30.png)\n\n### 单个编码层的代码实现\n\n除了第一个模块输入是单词嵌入向量与位置编码的和外，其余编码层输入是上一个编码器输出即后面的编码器输入不需要位置编码向量\n\n![](Prospective-Graduate-Summer-Training-05/05-31.png)\n\n![](Prospective-Graduate-Summer-Training-05/05-32.png)\n\n## 2.5 Masked Multi-Head Self-attention\n\n### 为什么需要mask?\n\n训练时：不采用上述类似RNN的方法一个一个目标单词嵌入向量顺序输入训练，想采用类似编码器中的矩阵并行算法，一步就把所有目标单词预测出来。要实现这个功能就可以参考编码器的操作，把目标单词嵌入向量组成矩阵一次输入即可。即：并行化训练。\n\n但是在解码have时候，不能利用到后面单词a和cat的目标单词嵌入向量信息，否则这就是作弊(测试时候不可能能未卜先知)。为此引入mask。具体是：在解码器中，self-attention层只被允许处理输出序列中更靠前的那些位置，在softmax步骤前，它会把后面的位置给隐去（把它们设为-inf） 。为此引入mask，目的是构成下三角矩阵，右上角全部设置为负无穷(相当于忽略)，从而实现当解码第一个字的时候，第一个字只能与第一个字计算相关性，当解出第二个字的时候，只能计算出第二个字与第一个字和第二个字的相关性。\n\n解码器内部的带有mask的MultiHeadAttention的qkv向量输入来自目标单词嵌入或者前一个解码器输出，三者是相同的，但是后面的MultiHeadAttention的qkv向量中的kv来自最后一层编码器的输入，而q来自带有mask的MultiHeadAttention模块的输出\n\n\n### Masked Multi-Head Self-attention的具体操作：\n\n- Step1：输入矩阵包含 \"\\<Begin> I have a cat\" (0, 1, 2, 3, 4) 五个单词的表示向量，Mask是一个 5×5 的矩阵。在Mask可以发现单词 0 只能使用单词 0 的信息，而单词 1 可以使用单词 0, 1 的信息，即只能使用之前的信息。\n- Step2： 𝑸^𝑻∗𝑲得到 Attention矩阵，此时先不急于做softmax的操作，而是先于一个Mask矩阵相乘，使得attention矩阵的有些位置归0，得到Masked Attention矩阵。 Mask矩阵是个下三角矩阵，为什么这样设计？是因为想在计算Z矩阵的某一行时，只考虑它前面token的作用。即：在计算Z的第一行时，刻意地把Attention矩阵第一行的后面几个元素屏蔽掉。在产生have这个单词时，只考虑 I，不考虑之后的have a cat，即只会attend on已经产生的sequence，这个很合理，因为还没有产生出来的东西不存在，就无法做attention。\n- Step3：Masked Attention矩阵进行 Softmax，每一行的和都为 1。但是单词 0 在单词 1, 2, 3, 4 上的 attention score 都为 0。得到的结果再与V矩阵相乘得到最终的self-attention层的输出结果Z1。\n- Step4： Z1只是某一个head的结果，将多个head的结果concat在一起之后再最后进行Linear Transformation得到最终的Masked Multi-Head Self-attention的输出结果Z。\n\n![](Prospective-Graduate-Summer-Training-05/05-33.jpg)\n\n### Mask的代码实现\n\nsrc_mask = get_pad_mask(src_seq, self.src_pad_idx)\n用于产生Encoder的Mask，它是一列Bool值，负责把标点mask掉。\ntrg_mask = get_pad_mask(trg_seq, self.trg_pad_idx) & get_subsequent_mask(trg_seq)\n用于产生Decoder的Mask矩阵。\n\n![](Prospective-Graduate-Summer-Training-05/05-34.png)\n\n### 单个解码层的代码实现\n\n![](Prospective-Graduate-Summer-Training-05/05-35.png)\n\n### 多个解码层的代码实现\n\n![](Prospective-Graduate-Summer-Training-05/05-36.png)\n\n## 2.6 传统Attention、Self Attention、Cross Attention\n\n- 传统的Attention是基于source端和target端的隐变量计算Attention的，得到的结果是source端的每个词与target端每个词之间的依赖关系。\n- 传统的Attention是基于source端和target端的隐变量计算Attention的，得到的结果是source端的每个词与target端每个词之间的依赖关系。\n- Self -Attention分别在source端和target端进行自身的attention，仅与source input或者target input自身相关的Self -Attention，以捕捉source端或target端自身的词与词之间的依赖关系。\n- Cross-Attention把source端的得到的self -Attention加入到target端得到的Attention中，以捕捉source端和target端词与词之间的依赖关系。\n- 传统的Attention机制忽略了源端或目标端句子中词与词之间的依赖关系，self Attention可以不仅可以得到源端与目标端词与词之间的依赖关系，同时还可以有效获取源端或目标端自身词与词之间的依赖关系。\n\n# 3. 视觉领域的Transformer\n\n## 3.1 Transformer+Classification：Vision Transformer\n\n![](Prospective-Graduate-Summer-Training-05/05-37.png)\n\n### 图片分块和降维\n\ntransformer的输入需要序列，最简单做法就是把图片切分为patch，然后拉成序列即可。 假设输入图片大小是256x256，打算分成64个patch，每个patch是32x32像素:\n\n![](Prospective-Graduate-Summer-Training-05/05-38.png)\n\nP代表patch大小，假设输入是b,3,256,256，则rearrange操作是先变成(b,3,8x32,8x32)，最后变成(b,8x8,32x32x3)即(b,64,3072)，将每张图片切分成64个小块，每个小块长度是32x32x3=3072，也就是说输入长度为64的图像序列，每个元素采用3072长度进行编码。\n考虑到3072维度偏大，故先对其进行降维：\n\n![](Prospective-Graduate-Summer-Training-05/05-39.png)\n\n> 没有解码器如何执行分类预测？\n> 使用CLS Token整合输出信息\n> Class的作用有点类似于解码器中的Query的作用，相对应的Key,Value就是其他9个编码向量的输出\n> 在整合图片信息时，一种是使用CLS Token，另一种是对所有Tokens的输出取平均，两者可以达到同样效果：\n> ![](Prospective-Graduate-Summer-Training-05/05-40.png)\n\n### 位置编码\n\n位置编码长度为1024，本文没有采用sincos编码，而是直接设置为可学习。\n\n位置越接近，往往具有更相似的位置编码。此外，出现了行列结构；同一行/列中的patch具有相似的位置编码。\n\n![](Prospective-Graduate-Summer-Training-05/05-43.png)\n\n### 编码器前向过程\n\n没有任何改动的transformer，假设输入是(b,65,1024)，那么transformer输出也是(b,65,1024)\n\n![](Prospective-Graduate-Summer-Training-05/05-41.png)\n\n### 分类head\n\n编码器后接fc分类器head\n\n![](Prospective-Graduate-Summer-Training-05/05-42.png)\n\n![](Prospective-Graduate-Summer-Training-05/05-44.jpg)\n\n### VIT整体流程：\n\n![](Prospective-Graduate-Summer-Training-05/05-45.png)\n\n![](Prospective-Graduate-Summer-Training-05/05-46.png)\n\n## 3.2 Transformer+Detection：DETR\n\n- 用transformer的encoder-decoder架构一次性生成 N个box prediction。其中N是一个事先设定的、比远远大于image中object个数的一个整数。将目标检测问题转化为无序集合预测问题。\n- 设计了bipartite matching loss，基于预测的boxes和ground truth boxes的二分图匹配计算loss的大小，从而使得预测的box的位置和类别更接近于ground truth。\n\t- 不需要设置先验anchor和proposal；超参很少；不需要nms（end to end）\n\n![](Prospective-Graduate-Summer-Training-05/05-47.png)\n\n### cnn主干网络特征提取\n\n主干网络可以是任何一种，作者选择resnet50，将最后一个stage即stride=32的特征图作为编码器输入。由于resnet仅仅作为一个小部分且已经经过了imagenet预训练，故和常规操作一样，会进行如下操作：\n\n- resnet中所有BN都固定，即采用全局均值和方差\n- resnet的stem和第一个stage不进行参数更新，即parameter.requires_grad_(False)\n- backbone的学习率小于transformer,lr_backbone=1e-05,其余为0.0001\n\n假设输入是(b,c,h,w)，则resnet50输出是(b,2048,h//32,w//32)，2048比较大，为了节省计算量，先采用1x1卷积降维为256,最后转化为序列格式输入到transformer中，输入shape=(h'xw',b,256)，h'=h//32\n\n![](Prospective-Graduate-Summer-Training-05/05-48.png)\n\n### 编码器设计和输入\n\n**位置编码需要考虑2d空间**\n\nDETR考虑了xy方向的位置编码，因为图像特征是2-D特征。采用的依然是 sincos模式，但是需要考虑 xy两个方向。不是类似vit做法将其拉伸为一个向量，然后从0-n进行长度为256的位置编码，而是考虑了xy方向同时编码，每个方向各编码128维向量，这种编码方式更符合图像特点。\n\nPositional Encoding的输出张量是:(B,d,H,W)，其中 d代表位置编码的长度， H,W代表张量的位置。特征图上的任意一个点(H1,W1)有个位置编码，这个编码的长度是256，其中，前128维代表 H1的位置编码，后128维代表H2的位置编码。\n\n计算任意一个位置 ($  \\begin{equation} 𝒑𝒐𝒔_𝒙  \\end{equation} $, $  \\begin{equation} 𝒑𝒐𝒔_𝒚 \\end{equation} $) 的Positional Encoding，把 $  \\begin{equation} 𝒑𝒐𝒔_𝒙 \\end{equation} $代入右式的 a式和 b式可以计算得到128维的向量，它代表 x的位置编码，再把 $  \\begin{equation} 𝒑𝒐𝒔_𝒚 \\end{equation} $ 代入右式的 c式和 d式可以计算得到128维的向量，它代表 y的位置编码，把这2个128维的向量拼接起来，就得到了一个256维的向量，它代表 ($  \\begin{equation} 𝒑𝒐𝒔_𝒙 \\end{equation} $, $  \\begin{equation} 𝒑𝒐𝒔_𝒚 \\end{equation} $) 的位置编码。\n\n计算所有位置的编码，就得到了(256,H,W)的张量，代表这个batch的位置编码。编码矩阵的维度是 (B,256,H,W)，也把它序列化成维度为 (HW,B,256)维的张量，准备与(HW,B,256)维的feature map相加以后输入Encoder。\n\n![](Prospective-Graduate-Summer-Training-05/05-49.png)\n\n> 与原始transformer编码器不同的地方：\n> - 输入编码器的位置编码需要考虑2d空间位置\n> - 位置编码向量需要加入到每个编码器中\n> - 在编码器内部位置编码仅仅和QK相加，V不做任何处理\n\n**代码实现：**\n\n![](Prospective-Graduate-Summer-Training-05/05-50.png)\n\n![](Prospective-Graduate-Summer-Training-05/05-51.png)\n\n### 解码器设计和输入\n\n- Transformer Encoder输出的Embedding与 position encoding 之和。\n- Object queries。\n\nObject queries是一个维度为(100,b,256)维的可学习张量，充当位置编码作用。\n\nObject queries矩阵内部通过学习建模了100个物体之间的全局关系，例如房间里面的桌子旁边(A类)一般是放椅子(B类)，而不会是放一头大象(C类)，那么在推理时候就可以利用该全局注意力更好的进行解码预测输出。\n\nDecoder的输入一开始也初始化成维度为 (100,b,256)维的全部元素都为0的张量，和Object queries加在一起之后充当第1个multi-head self-attention的Query和Key。第一个multi-head self-attention的Value为Decoder的输入，也就是全0的张量。\n\n**对Encoder和Decoder的每个self-attention的Query和Key的位置编码的归纳**\n\n![](Prospective-Graduate-Summer-Training-05/05-52.png)\n\n**无序集合输出的loss计算：**\n\nDETR输出是包括(b,100)个无序集合，每个集合包括类别c[长度为92的分类向量]和坐标信息(x,y,w,h)[长度为4的坐标向量]，故DETR输出集合包括两个分支：\n\n- 分支shape=(b,100,92)，bbox坐标分支shape=(b,100,4)\n- 对应的target也是包括分类target和bbox坐标target，如果不够100，则采用背景填充，计算loss时候bbox分支仅仅计算有物体位置，背景集合忽略。\n\n> 匈牙利算法： 广泛应用于最优分配的二分图匹配问题\n\n> 的bx100个检测结果是无序的，如何和gt bbox计算loss？\n> DETR中利用匈牙利算法先进行最优一对一匹配得到匹配索引，然后对(b,100)个结果进行重排实现和gt bbox对应。优化的目的是找到最优匹配排列，使得L_match和最小。\n\n**代码实现：**\n\n![](Prospective-Graduate-Summer-Training-05/05-53.png)\n\n![](Prospective-Graduate-Summer-Training-05/05-54.png)\n\n### 分类和回归head\n\n在解码器输出基础上构建分类和bbox回归head即可输出检测结果\n\n![](Prospective-Graduate-Summer-Training-05/05-55.png)\n\n> - **模型学习到了什么？**\n> 训练完以后，DETR模型学习到了一种能力，即：模型产生的100个预测框，它知道某个预测框该对应什么Object，比如，模型学习到：第1个预测框对应 Car(label=3)，第2个预测框对应 Bus(label=16) ，第3个预测框对应 Sky(label=21) ，第4-100个预测框对应 ∅(label=92)，等等\n> - **Object queries学习到了什么？**\n> 它是一个维度为(100,b,256)维的张量，初始时元素全为 0，是可训练的。考虑单张图片，所以假设Object queries是一个维度为 (100,256)维的张量。训练完模型以后，此时的Object queries究竟代表什么?\n> 把Object queries看成100个格子，每个格子是个256维的向量。训练完以后，这100个格子里面注入了不同Object的位置信息和类别信息。比如第1个格子里面的这个256维的向量代表着Car这种Object的位置信息，这种信息是通过训练，考虑了所有图片的某个位置附近的Car编码特征，属于和位置有关的全局Car统计信息。测试时，假设图片中有Car,Dog,Hourse三种物体，该图片会输入到编码器中进行特征编码，假设特征没有丢失，Decoder的Key和Value就是编码器输出的编码向量，而Query就是Object queries，就是我们的100个格子。\n> Query可以视作代表不同Object的信息，而Key和Value可以视作代表图像的全局信息。\n> 通过注意力模块将Query和Key计算，然后加权Value得到解码器输出。对于第1个格子的Query会和Key中的所有向量进行计算，目的是查找某个位置附近有没有Car，如果有那么该特征就会加权输出，对于第3个格子的Query会和Key中的所有向量进行计算，目的是查找某个位置附近有没有Sky，很遗憾，这个没有，所以输出的信息里面没有Sky。\n> 整个过程计算完成后就可以把编码向量中的Car,Dog,Hourse的编码嵌入信息提取出来，然后后面接 FFN进行分类和回归就比较容易，因为特征已经对齐了。\n\n### 整体推理流程\n\n- 将(b,3,800,1200)图片输入到resnet50中进行特征提取,输出shape=(b,1024,25,38)\n- 通过1x1卷积降维，变成(b,256,25,38)\n- 利用sincos函数计算位置编码\n- 将图像特征和位置编码向量相加，作为编码器输入，输出编码后的向量，shape不变\n- 初始化全0的(100,b,256)的输出嵌入向量，结合位置编码向量和query_embed，进行解码输出，解码器输出shape为(6,b,100,256)，后面的解码器接受该输出，然后再次结合置编码向量和query_embed进行输出，不断前向\n- 将最后一个解码器输出输入到分类和回归head中，得到100个无序集合\n- 对100个无序集合进行后处理，主要是提取前景类别和对应的bbox坐标，乘上(800,1200)即可得到最终坐标\n\n![](Prospective-Graduate-Summer-Training-05/05-56.png)\n\n## 3.3 Swin Transformer\n\n**Transformer 从 NLP 迁移到 CV 上没有大放异彩主要有两点原因：**\n\n- 最主要的原因是两个领域涉及的scale不同，NLP 任务以 token 为单位，scale 是标准固定的，而 CV 中基本元素的 scale 变化范围非常大。\n- CV 比起 NLP 需要更大的分辨率，而且 CV 中使用 Transformer 的计算复杂度是图像尺度的平方，这会导致计算量过于庞大， 例如语义分割，需要像素级的密集预测，这对于高分辨率图像上的Transformer来说是难以处理的。\n\nSwin Transformer 就是为了解决这两个问题所提出的一种通用的视觉架构。Swin Transformer 引入 CNN 中常用的**层次化**构建方式。\n\n### 图片预处理：分块和降维 (Patch Partition)\n\nSwin Transformer 首先把𝑯∗𝑾∗𝑪的图片，变成一个𝑵∗( $ \\begin{equation}  𝒑^𝟐  \\end{equation} $ ∗𝑪)的2维的image patches。它可以看做是一系列的展平的2D块的序列，这个序列中一共有𝑯∗𝑾/ $  \\begin{equation} 𝒑^𝟐 \\end{equation} $ 个展平的2D块，每个块的维度是$  \\begin{equation}𝒑^𝟐 \\end{equation} $ ∗𝑪。其中 𝒑是块大小。\n\n在 Swin Transformer 中，块的大小𝒑=𝟒，所以得到的块的大小𝑵∗𝟒𝟖 ，这里的𝑵= $  \\begin{equation} \\frac{𝑯∗𝑾}{𝟏𝟔} \\end{equation} $ = $  \\begin{equation} \\frac {𝑯}{𝟒} \\end{equation} $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟒} \\end{equation} $。\n\n所以经过了这一步的分块操作，一张 𝑯∗𝑾∗𝟑的图片就变成了 $  \\begin{equation} 𝑯 \\over 𝟒 \\end{equation} $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟒} \\end{equation} $ ∗ 𝟒𝟖的张量，可以理解成是 $  \\begin{equation} \\frac {𝑯}{𝟒} \\end{equation} $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟒}  \\end{equation} $个图片块，每个块是一个 𝟒𝟖 维的 token。\n\n![](Prospective-Graduate-Summer-Training-05/05-57.png)\n\n### Stage 1：线性变换 (Linear Embedding)\n\n现在得到的向量维度是：$  \\begin{equation} \\frac {𝑯}{𝟒} \\end{equation} $ ∗ $  \\begin{equation}  \\frac {𝑾}{𝟒}  \\end{equation} $ ∗ 𝟒𝟖 ，还需要做一步叫做Linear Embedding的步骤，对每个向量都做一个线性变换（即全连接层），变换后的维度为 𝑪 。这一步之后得到的张量维度是：$  \\begin{equation} \\frac {𝑯}{𝟒}  \\end{equation} $ ∗ $ \\begin{equation}  \\frac {𝑾}{𝟒} \\end{equation}  $ ∗ 𝑪 \n\n### Stage 1：Swin Transformer Block\n\n接下来 $  \\begin{equation} \\frac {𝑯}{𝟒}  \\end{equation}   $ ∗ $ \\begin{equation}  \\frac {𝑾}{𝟒}  \\end{equation}  $ ∗ 𝑪 这个张量进入2个连续的 Swin Transformer Block 中，这被称作 Stage 1，在整个的 Stage 1 里面 token 的数量一直维持 $  \\begin{equation} \\frac {𝑯}{𝟒} \\end{equation}  $ ∗ $ \\begin{equation}  \\frac {𝑾}{𝟒}  \\end{equation}  $ 不变\n\n一个 Swin Transformer Block 由一个带两层 MLP 的 Window-based MSA 组成，另一个 Swin Transformer Block 由一个带两层 MLP 的 Shifted Window-based MSA 组成\n\n### Stage 1：Swin Transformer Block：Window-based MSA\n\n标准 ViT 的多头注意力机制 MSA 采用的是全局自注意力机制，即：计算每个 token 和所有其他 token 的 attention map。全局自注意力机制的计算复杂度是 O(𝑵^𝟐∗𝒅) ，其中， 𝑵是 token的数量， 𝒅是 Embedding dimension。全局自注意力机制的计算复杂度与序列长度𝑵成平方关系。当图片分辨率较高或是密集预测任务中计算量会过大。\n\nWindow-based MSA 不同于普通的 MSA，它在一个个 window 里面去计算 self-attention。假设每个 window 里面包括𝑴∗𝑴个 image patches，则 Window-based MSA 和普通的 MSA 的计算量分别为：\n\n$$ \\begin{equation}\n𝛀(𝑴𝑺𝑨)=𝟒𝒉𝒘𝑪^𝟐+𝟐(𝒉𝒘)^𝟐 𝑪\n\\end{equation} $$\n\n$$ \\begin{equation}\n𝛀(𝑾−𝑴𝑺𝑨)=𝟒𝒉𝒘𝑪^𝟐+𝟐𝑴^𝟐 𝒉𝒘𝑪\n\\end{equation} $$\n\n由于 Window 的 patch 数量 𝑴远小于图片patch数量 𝒉𝒘，Window-based MSA 的计算量与序列长度 𝐍=𝒉𝒘成线性关系。\n\n### Stage 1：Swin Transformer Block：Shifted Window-based MSA\n\nWindow-based MSA 虽然大幅节约了计算量，但是牺牲了 windows 之间关系的建模，不重合的 Window 之间缺乏信息交流影响了模型的表征能力。\n\n为了解决这一问题，在两个连续的Swin Transformer Block中交替使用W-MSA 和 SW-MSA。将前一层 Swin Transformer Block 的 8x8 尺寸feature map划分成 2x2 个patch，每个 patch 尺寸为 4x4，然后将下一层 Swin Transformer Block 的 Window 位置进行移动，得到 3x3 个不重合的 patch。移动 window 的划分方式使上一层相邻的不重合 window 之间引入连接，大大的增加了感受野。\n\n在新的 window 里面做 self-attention 操作，就可以包括原有的 windows 的边界，实现 windows 之间关系的建模。\n\n> 引入 Shifted Window 会带来另一个问题就是会造成 window 数发生改变，而且有的 window 大，有的 window 小\n> 解放方案：cycle shift合并小的 windows\n> 经过了 cycle shift 的方法，一个 window 可能会包括来自不同 window 的内容。比右下角的 window，来自4个不同的 sub-window。因此，要采用 masked MSA 机制将 self-attention 的计算限制在每个子窗口内。最后通过 reverse cycle shift 的方法将每个 window 的 self-attention 结果返回\n\n> cycle shift过程：按照之前的 window 划分，就能够得到 window 5 的attention 的结果了。但是这样操作会使得 window 6 和 4 的 attention 混在一起，window 1,3,7 和 9 的 attention 混在一起。所以需要采用 masked MSA 机制将 self-attention 的计算限制在每个子窗口内，如何实现？\n> 按照 Swin Transformer 的代码实现 ，还是做正常的 self-attention (在 window_size 上做)，之后要进行一次 mask 操作，把不需要的 attention 值给它置为0\n\n### Stage 2/3/4\n\nStage 2 的输入是维度是 $  \\begin{equation} \\frac {𝑯}{𝟒} \\end{equation}  $ ∗ $  \\begin{equation}  \\frac {𝑾}{𝟒} \\end{equation}   $ ∗ 𝑪 的张量。从 Stage 2 到 Stage 4 的每个 stage 的初始阶段都会先做一步 Patch Merging 操作，Patch Merging 操作的目的是为了减少 tokens 的数量，它会把相邻的2×2个 tokens 给合并到一起，得到的 token 的维度是 𝟒𝑪 。Patch Merging 操作再通过一次线性变换把维度降为𝟐𝑪 。至此，维度是 $  \\begin{equation} \\frac {𝑯}{𝟒}  \\end{equation}  $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟒}  \\end{equation}  $ ∗ 𝑪 的张量经过Patch Merging 操作变成了维度是 $  \\begin{equation} \\frac {𝑯}{𝟖}  \\end{equation}  $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟖} \\end{equation}  $  ∗ 𝟐𝑪 的张量。\n\n同理，Stage 3 的Patch Merging 操作会把维度是 $  \\begin{equation} \\frac {𝑯}{𝟖}  \\end{equation}  $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟖} \\end{equation}  $  ∗ 𝟐𝑪 的张量变成维度是 $ \\begin{equation} \\frac {𝑯}{𝟏𝟔}  \\end{equation}  $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟏𝟔}  \\end{equation}  $ ∗ 𝟒𝑪 的张量。Stage 4 的Patch Merging 操作会把维度是  $  \\begin{equation} \\frac {𝑯}{𝟏𝟔}  \\end{equation}  $ ∗ $  \\begin{equation} \\frac {𝑾}{𝟏𝟔} \\end{equation}   $ ∗ 𝟒𝑪 的张量变成维度是 $  \\begin{equation} \\frac {𝑯}{𝟑𝟐} ∗ \\frac {𝑾}{𝟑𝟐} \\end{equation}   $ ∗ 𝟖𝑪 的张量。\n\n每个 Stage 都会改变张量的维度，形成一种层次化的表征。因此，这种层次化的表征可以方便地替换为各种视觉任务的骨干网络。\n\n### Swin Transformer 的位置编码\n\nSwin Transformer 的位置编码加在 attention 矩阵上\n\n![](Prospective-Graduate-Summer-Training-05/05-58.png)\n\n- 位置编码𝑩的第(𝒊,𝒋)个元素𝑩(𝒊,𝒋) ，它代表的是 Window 里面第𝒊个 Patch 和第𝒋个 Patch 的相对位置关系。\n- 所以应该有𝑩(𝟑,𝟕)=𝑩(𝟒,𝟖)=𝑩(𝟏,𝟓)=𝑩(𝟎,𝟒)，因为它们都代表着斜对角的位置关系。\n- 所以应该有 𝑩(𝟎,𝟔)=𝑩(𝟏,𝟕)=𝑩(𝟐,𝟖)  ，因为它们都代表着上下有间隔的位置关系。\n- ……\n","tags":["AI","DL","Transformer"],"categories":["AI"]},{"title":"04. 卷积神经网络基础和经典模型概览","url":"/article/Prospective-Graduate-Summer-Training-04.html","content":"\n# 1. 卷积神经网络基础知识\n\n## 1.1 卷积特征\n\n卷积核内的参数决定了提取的特征。\n\n> - 卷积核：卷积核就是图像处理时，给定输入图像，在输出图像中每一个像素是输入图像中一个小区域中像素的加权平均，其中权值由一个函数定义，这个函数称为卷积核。\n> - 卷积：卷积可以对应到2个函数叠加，因此用一个filter和图片叠加就可以求出整个图片的情况，可以用在图像的边缘检测，图片锐化，模糊等方面。\n\n### 深层原理\n\n提取特征，关键是要找到特征变化的分界点--特征的边缘\n\n当我们把图片的每一部分区域，依次带入到二阶导数时，对于灰度变化较小或者是均匀变化的区域，我们会得到一个接近0的值，而对于灰度变化大的区域，我们则会得到一个较大的值，从而识别出图片的边缘。\n\n![](Prospective-Graduate-Summer-Training-04/04-1.jpg)\n\n**边缘提取例子**：\n\n下图是一个矩形，我们希望过滤掉水平的上下边，而提取出垂直边。我们只需要计算水平方向上的梯度变化就可以。\n\n![](Prospective-Graduate-Summer-Training-04/04-2.jpg)\n\n![](Prospective-Graduate-Summer-Training-04/04-3.png)\n\n![](Prospective-Graduate-Summer-Training-04/04-4.png)\n\n在与提取垂直边缘的卷积核运算后，得到的就是图像水平方向的二阶导数。\n\n简言之：用卷积直接达到了二阶导数的结果，实现边缘特征提取。\n\n> 卷积后尺寸主要受kernel size、padding、stride等影响。\n\n## 1.2 感受野\n\n卷积神经网络每一层输出的特征图上的像素点映射回输入图像上的区域大小。\n\n![](Prospective-Graduate-Summer-Training-04/04-5.jpg)\n\n## 1.3 多通道卷积\n\n特征图的大小是`C×H×W`\n通常：卷积核的通道数目与被卷积的特征图的通道数目相等。\n输出特征的通道数与卷积核数目相同。\n\n![](Prospective-Graduate-Summer-Training-04/04-6.png)\n\n## 1.4 池化（Pooling）\n\n池化（Pooling）是卷积神经网络中的一个重要的概念，它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中“最大池化（Max pooling）”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。\n\n以最大池化（max pooling）为例：\n\n计算公式：`o = (i-k）/s+1`\n\n![](Prospective-Graduate-Summer-Training-04/04-7.png)\n\n> 直觉上，这种机制能够有效的原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。\n\n## 1.5 卷积神经网络\n\n### 简单的卷积神经网络流程\n\n![](Prospective-Graduate-Summer-Training-04/04-8.png)\n\n### 设计一个卷积神经网络需要确定的结构参数\n\n1. 卷积层(CONV)\n\t- 每一层卷积核的数目𝑛（确定了该层输出的特征图的通道数目）\n\t- 每一层卷积核的大小𝑓\n\t- 每一层卷积的跨度𝑠\n\t- 每一层卷积的非线性响应函数（ReLU）\n2. Pooling层(POOL)\n\t- Pooling区域的大小𝑓\n\t- Pooling的计算方式（Max,Mean）\n\t- Pooling的跨度𝑠\n3. 全连接层(FC)\n\t- MLP的层数𝑛\n\t- 每一层神经元数目𝑓与响应函数\n\t- 以上参数是超参数，不能通过梯度下降法优化\n\t- AutoML等工具可以自动搜寻合适的结构\n\n### 卷积神经网络的特点\n\n1. 从低层到高层，卷积、Pooling、Stride使得特征图的分辨率越来越低\n\t- 特殊情况（使用padding）例外，输入与输出的特征图分辨率相同\n2. 从低层到高层，特征图的通道数目通常越来越多\n3. 低层神经元感受野比较小（提取局部特征）\n\t- 提取底层特征（边缘）\n4. 高层神经元的感受野越来越大（提取全局特征）\n\t- 组合底层特征\n\t- 提取的特征越来越高级（目标、语义）\n5. Pooling会造成特征定位不准确\n\n\n# 2. 经典模型\n\n- 分类\n\t- VGGNet\n\t- ResNet\n- 分隔\n\t- UNet\n\t- DeepLab\n- 检测\n\t- YOLO\n\t- Faster RCNN\n\n## 2.1 分类模型\n\n输入图像往往仅包含一个物体，目的是判断每张图像是什么物体，是图像级别的任务，相对简单，发展最快。\n\n### VGGNet\n\nVery Deep Convolutional Networks for Large-Scale Image Recognition——用于大规模图像识别的深度卷积网络\n\nVGG是Oxford的Visual Geometry Group的团队在ILSVRC 2014上的相关工作。2014年ImageNet大规模视觉挑战赛，定位赛道冠军分类赛道亚军\n\n![](Prospective-Graduate-Summer-Training-04/04-9.png)\n\n**主要工作**：研究了卷积网络深度对其精度在大规模图像识别环境中的影响。\n\n**主要贡献**：使用具有非常小的(3×3)卷积滤波器的体系结构对增加深度的网络进行了彻底的评估，这表明通过将深度推进到16-19个权重层可以实现对现有技术配置的显著改进。\n\n![](Prospective-Graduate-Summer-Training-04/04-10.png)\n\n相比于 LeNet 网络，VGG 网络的一个改进点是将大尺寸的卷积核用多个小尺寸的卷积核代替。\n\nLeNet是一个 7 层的神经网络，包含 3 个卷积层，2 个池化层，1 个全连接层。其中所有卷积层的所有卷积核都为 5x5，步长 strid=1，池化方法都为全局 pooling，激活函数为 Sigmoid。\n\n![](Prospective-Graduate-Summer-Training-04/04-11.png)\n\n这样做的好处：\n\n- 在保证相同感受野的情况下，多个小卷积层堆积可以提升网络深度，增加特征提取能力（**非线性层增加**）。\n- **参数更少**。比如 1个大小为5的感受野等价于2个步长为1，3×3大小的卷积核堆叠。（即1个5×5的卷积核等于2个3×3的卷积核）。而1个5X5卷积核的参数量为 5×5×C。而2个3×3卷积核的参数量为 2×3×3×C。很显然，18C < 25C。\n- 3×3卷积核更有利于保持图像性质。\n\n> VGG16：包含16个隐藏层（13个卷积层+3个全连接层），左图D列。\n> VGG19：包含19个隐藏层（16个卷积层+3个全连接层），左图E列。\n\nVGG**优点**：\n\n- VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3×3）和最大池化尺寸（2×2）。\n- 几个小滤波器（3×3）卷积层的组合比一个大滤波器（5×5或7×7）卷积层好：\n- 验证了通过不断加深网络结构可以提升性能。\n\nVGG**缺点**：\n\n- VGG耗费更多计算资源，并且使用了更多的参数（这里不是因为3×3卷积），导致更多的内存占用（140M）。其中绝大多数的参数都是来自于第一个全连接层。VGG有3个全连接层。\n\n### ResNet\n\nDeep Residual Learning for Image Recognition——深度残差学习在图像识别中的应用\n\nResNet取得了在ILSVRC和COCO 2015上的5项第一，并又一次刷新了CNN模型在ImageNet上的历史：\n\n![](Prospective-Graduate-Summer-Training-04/04-12.png)\n\n![](Prospective-Graduate-Summer-Training-04/04-13.png)\n\nResNet的一个重要设计原则是：当feature map大小降低一半时，feature map的数量增加一倍，这保持了网络层的复杂度。\n\nResNet网络结构：\n\n![](Prospective-Graduate-Summer-Training-04/04-14.png)\n\n### Res2Net\nRes2Net: A New Multi-scale Backbone Architecture——Res2Net：一种新的多尺度骨干网体系结构\n\n![](Prospective-Graduate-Summer-Training-04/04-15.png)\n\n动机：\n1. 多尺度表示对于各种视觉任务至关重要，例如感知目标对象的边界，区域和语义类别。\n2. 感知不同比例尺的信息对于理解目标物体。\n3. 大多数现有方法以分层的方式表示多尺度特征。\n\n**主要思想**：在更细粒度的层次上提高了多尺度表示能力，并非和现有方法一样用不同分辨率的特征来提高多尺度能力，而是更细粒度的多个可用感受野。\n\n![](Prospective-Graduate-Summer-Training-04/04-16.png)\n\n**实现**：用一组较小的滤波器组替换n个通道的3×3滤波器，每个滤波器组有w个通道。\n这些滤波器组以分层类似残差样式的连接，以增加尺度表示输出特征。\n\n与ResNet的不同：就是将原来的resnet中间的3x3卷积换成了右侧切片处理的形式。最少是不经过3x3卷积，直接连接，最多会经过3个3x3的卷积，从而增加感受野。\n\n![](Prospective-Graduate-Summer-Training-04/04-17.png)\n\n在ImageNet数据集的top-1和top-5测试错误率。由表可看出Res2Net性能更优。\n\n![](Prospective-Graduate-Summer-Training-04/04-18.png)\n\n为了证明不同scale的有效性，下表显示了ImageNet数据集上具有不同scale的Res2Net-50的Top-1和Top-5测试误差（％）。w为各scale的通道数，s为scale。由表可看出，网络的性能随着scale的增加而增加。\n\n![](Prospective-Graduate-Summer-Training-04/04-19.png)\n\n> Res2Net是一个一个简单而高效的模块，以在更细粒度的水平上进一步探索CNN的多尺度能力。Res2Net揭示了一个新的维度，即“Scale”，这是除了现有的深度、宽度维度之外的一个基本和更有效的因素。Res2Net模块可以与现有最先进的方法集成。\n>Res2Net模块在以上视觉任务中均表现出良好的性能。\n\n## 2.2 分割模型\n\n与分类不同的是，分割需要判断图像每个像素点的类别，进行精确分割。图像分割是像素级别的。\n\n但是由于CNN在进行convolution和pooling过程中丢失了图像细节，即feature map size逐渐变小，所以不能很好地指出物体的具体轮廓、指出每个像素具体属于哪个物体，无法做到精确的分割。\n\n### FCN\n\n与经典的CNN在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全联接层＋softmax输出）不同，FCN对图像进行像素级的分类。\n\nFCN可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的feature map进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 接着在上采样的特征图上进行逐像素分类。最后逐个像素计算softmax分类的损失, 相当于每一个像素对应一个训练样本。\n\nFCN网络图：\n\n![](Prospective-Graduate-Summer-Training-04/04-20.png)\n\nFCN与CNN的区别在于把CNN最后的全连接层换成卷积层，输出的是一张已经Label好的图片。\n\n较浅的卷积层感知域较小，学习到一些局部区域的特征；较深的卷积层具有较大的感知域，能够学习到更加抽象一些的特征。这些抽象特征对物体的大小、位置和方向等敏感性更低，从而有助于识别性能的提高。\n\n通过融合来自不同跨度的层的信息来精炼完全卷积网络，提高了分割细节。前三张图片显示了32、16和8像素步幅网络的输出。\n\n![](Prospective-Graduate-Summer-Training-04/04-21.png)\n\nFCN的**缺点**：\n\n- **得到的结果还是不够精细**。进行8倍上采样虽然比32倍的效果好了很多，但是上采样的结果还是比较模糊和平滑，对图像中的细节不敏感。\n- 对各个像素进行分类，没有充分考虑像素与像素之间的关系，**缺乏空间一致性**。\n\n### U-Net\nU-Net: Convolutional Networks for Biomedical Image Segmentation——U-Net：用于生物医学图像分割的卷积网络\n\nUnet 的初衷是为了解决生物医学图像方面的问题，由于效果确实很好后来也被广泛的应用在语义分割的各个方向。\n\nUnet 跟 FCN 都是 Encoder-Decoder 结构，结构简单但很有效。\n\n网络结构：\n\n![](Prospective-Graduate-Summer-Training-04/04-22.png)\n\n首先进行Conv+Pooling下采样；然后Deconv反卷积进行上采样，crop之前的低层feature map，进行融合；然后再次上采样。重复这个过程，直到获得输出388x388x2的feature map，最后经softmax获得output segment map。总体来说与FCN思路非常类似。\n\n> Unet与FCN的不同U-Net采用了与FCN完全不同的特征融合方式：**拼接（Concatenate）**\n\n语义分割网络在特征融合时有2种办法：\n\n- FCN式的逐点相加，`torch.sum()`\n- U-Net式的channel维度拼接融合，`torch.cat()`\n\n基于CNN的图像语义分割的基本方法：\n\n- 下采样+上采样：`Convlution` + `Deconvlution／Resize`\n- 多尺度特征融合：特征逐点相加／特征`channel`维度拼接\n- 获得像素级别的`segamentation map`：对每一个像素点进行判断类别\n\n\n## 2.3 检测模型 \n\n输入图像中往往有很多物体，目的是判断出物体出现的位置与类别，是计算机视觉中非常核心的一个任务。\n\n### Faster R-CNN\n\nFaster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks——Faster R-CNN: 利用RPN进行实时目标检测\n\n![](Prospective-Graduate-Summer-Training-04/04-23.png)\n\nFaster RCNN包含4个主要内容：Conv layers、Region Proposal Networks (RPN)、Roi Pooling、Classification\n\n- **Conv layers**：作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础conv+relu+pooling：该层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。\n- **Region Proposal Networks**：RPN网络用于生成region proposals。该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。\n- **Roi Pooling**：该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。\n- **Classification**：利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。\n\n网络结构\n\n![](Prospective-Graduate-Summer-Training-04/04-24.png)\n\n网络的整个流程：\n\n1. 主干先提取特征\n2. 将最后一层的特征送入RPN网络中，首先生成对应的base anchor，经过rpn细化（就是进行二分类，保留前景anchor）生成对应的proposal。\n3. proposal的尺寸是相对于输入特征M×N的，在送入ROI Pooling层之前先要根据img imfo进行下采样到和Conv5_3一样的分辨率大小，也就是M/16 N/l16。再和Conv5_3输出的feature一起送入ROI Pooling得到尺寸一致的proposal features。\n4. 将proposal features送入分类回归层进一步修正回归框以及nms筛选完成检测。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`","tags":["AI","NN","DL"],"categories":["AI"]},{"title":"03. 深度学习实训","url":"/article/Prospective-Graduate-Summer-Training-03.html","content":"\n# 1. 深度学习环境搭建\n\n## 1.1 Ubuntu\n\n常用的检查服务器环境的命令：\n\n- 检查系统版本：`cat /etc/os-release`\n- 查看显卡信息：`nvidia-smi`\n- 查看CUDA版本：`nvcc –V`\n- CUDA的下载网站：https://developer.nvidia.com/cuda-downloads\n\n## 1.2 Anaconda\n\n### 镜像配置\n\n![](Prospective-Graduate-Summer-Training-03/03-1.jpg)\n\n- Anaconda镜像下载地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/\n- Anaconda镜像配置：https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/\n- Pypi镜像配置：https://mirrors.tuna.tsinghua.edu.cn/help/pypi/\n\n![](Prospective-Graduate-Summer-Training-03/03-2.jpg)\n\n### Conda环境管理命令\n\n- 创建环境：`conda create -n deep_learning`\n- 查看已有环境：`conda env list`\n- 选择一个环境：`conda activate deep_learning`\n- 退出当前环境：`conda deactivate`\n- 删除一个环境：`conda env remove -n deep_learning`\n\n## 1.3 PyTorch\n\n1. 基于清华镜像安装pytorch环境：\n`conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch`\n\n2. 查看环境中pytorch版本：`conda list | grep pytorch`\n\n3. 测试pytorch是否安装成功，以及cuda是否可用：\n```python\n>>> import torch\n>>> torch.cuda.is_available()\nTrue\n>>> a=torch.ones(1).cuda()\n>>> print(a)\n```\n\n**常用命令和工具**：\n\n- 查看GPU占用情况：`gpustat –I` （gpustat 需要使用conda安装）\n- 查看驱动详情：`watch -n 0.5 nvidia-smi`\n- 选择要使用的显卡卡号：`export CUDA_VISIBLE_DEVICES=‘2,3’`\n\n## 1.4 开发工具推荐\n\n- **MobaXterm**：远程连接工具，较 Xshell 而言，有更多的组件。\n- PyCharm\n- VS code\n- Jupyter\n\n\n# 2. PyTorch 基本概念\n\n![](Prospective-Graduate-Summer-Training-03/03-3.jpg)\n\n机器学习的过程主要分成数据、网络、损失、随机梯度下降几个模块，这些模块在pytorch中的对应了不同包的实现。\n\n## 2.1 DataLoader\n\nDataLoader数据加载 & transforms数据预处理：\n\n- 指定文件夹为数据集目录，按照固定格式生成数据集；\n- Compose以多种transforms编组，对数据做预处理或者增强；\n- DataLoader则为每次从数据集中随机选取16个的方式进行选取。\n\n![](Prospective-Graduate-Summer-Training-03/03-4.png)\n\n## 2.2 Transforms\n\nTransforms数据预处理：\n\n- 缩放到固定大小\n- 中心裁剪\n- 随机裁剪\n- 转成Tensor张量的类型\n\n![](Prospective-Graduate-Summer-Training-03/03-5.png)\n\nTransforms数据预处理效果：\n\n![](Prospective-Graduate-Summer-Training-03/03-6.png)\n\n## 2.3 Tensor\n\nTensor张量：Tensor的用法和Numpy中的ndarray非常相似，是PyTorch中重要的操作单元。\n\n```python\nfrom torch import tensor\n\nX=tensor([], requires_grad=True) 由数组生成tensor，并配置自动微分求导\nX.shape\t\t\t张量的尺寸\nX.view()\t\t\t张量尺寸的变形\nX.permute(2,1,0)\t\t张量的转置（指定第三维和第一维交换）\nX.transpose(2,0,1)\t\t张量的转置（把第三维交换到第一维）\ntorch.zeros()\t\t\t全零张量\ntorch.ones()\t\t\t全一张量\nX.to(device)\t\t\t指定张量转移到某一设备中\nX.to(torch.float32)\t\t张量中数据类型转成torch.float32型\nX.cuda()\t\t\t张量转移到GPU中\nX.cpu()\t\t\t张量转移到CPU中\nX.detach().numpy()\t\t张量取消微分并转成numpy数组\n```\n\n## 2.4 NN\n\ntorch.nn神经网络：\n\n```python\nnn.Sequential()\t\t序列形式用于组织网络中层级关系\nnn.Conv2d() \t\t\t针对二维数据的卷积网络\nnn.BatchNorm2d()\t\t批量归一化操作\nnn.ReLU()\t\t\tReLU非线性层\nnn.Sigmoid()\t\t\tSigmoid非线性层\nnn.Flatten()\t\t\t向量展平，即从三维拉成一维向量\nnn.MaxPool2d()\t\t最大池化层\nnn.AvgPool2d()\t\t平均池化层\nnn.LSTM()\t\t\t长短周期记忆网络\nnn.RNN()\t\t\t循环神经网络\nnn.MultiheadAttention() \t多头注意力结构\nnn.Transformer()\t\tTransfomer编解码结构\n```\n\n## 2.5 CrossEntropyLoss\n\ntorch.nn.loss损失函数：\n\n- nn.L1Loss()：L1绝对值损失\t\n- nn.SmoothL1Loss：区间平滑的L1损失\n- nn.MSELoss()：L2均方误差损失\n- nn.CrossEntropyLoss()：交叉熵损失\n\n![](Prospective-Graduate-Summer-Training-03/03-7.png)\n\n## 2.6 Optim\n\ntorch.optim优化函数：\n\n- optim.Adam：自适应动量估计优化法\n- optim.SGD：随机梯度下降法\n\n![](Prospective-Graduate-Summer-Training-03/image42-16554551509771.GIF)\n\n# 3. 编写图像分类代码\n\n## 3.1 基本流程\n\n有监督的深度学习的基本流程：\n\n![](Prospective-Graduate-Summer-Training-03/03-9.jpg)\n\n## 3.2 准备数据\n\n每个类别各200张图片，并划分成训练集和测试集，分别为160张图片和40张图片，\n训练集总共有320张图片，测试集则共有80张图片。\n\n皮卡丘数据集：\n\n![](Prospective-Graduate-Summer-Training-03/03-10.png)\n\n可达鸭数据集：\n\n![](Prospective-Graduate-Summer-Training-03/03-11.png)\n\n数据集划分：\n\n![](Prospective-Graduate-Summer-Training-03/03-12.png)\n\n## 3.3 网络模型设计\n\n以卷积的方式，设计一个五层的卷积特征提取网络，在每一层都进行一次下采样，将提取到的特征使用全连接的神经网络进行计算，得到最终的二分类预测。\n\n![](Prospective-Graduate-Summer-Training-03/03-13.png)\n\n## 3.4 代码实现\n\n> 以课程代码为例：\n\n```python\n## 实现皮卡丘和可达鸭的分类\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# 4. 学习和编程经验分享\n\n## 4.1 VS Code 配置\n\n1. 安装远程连接插件\n\n![](Prospective-Graduate-Summer-Training-03/03-14.png)\n\n2. 配置远程服务器，并远程访问工程目录\n\n![](Prospective-Graduate-Summer-Training-03/03-15.png)\n\n3. 代码调试\n\n![](Prospective-Graduate-Summer-Training-03/03-16.jpg)\n\n## 4.2 实验经验\n\n1. 训练挂载到后台，有效防止ssh超时导致的训练终断：\n    nohup python -u track.py > ../logs/log_20220613.log 2>&1 &\n2. 挂载到后台的日志，也可以实时查看训练进展：\n    tail -fn 100 ../logs/log_20220613.log\n3. 在~/.bashrc中配置一些命令别名，可以节省很多输入命令的时间例如：\n    alias \"nsw\"=\"watch -n 0.5 nvidia-smi”\n    alias “gst”=“gpustat –I”\n    alias \"ll\"=\"ls -alh“\n4. 要熟悉Linux下的文件系统，以及相对和绝对两种路径的区别：\n    绝对路径以”/”开头，相对路径以”../”开头。\n    绝对路径从root目录出发，相对路径从当前目录出发。\n5. 在windows本机安装git，不仅可以用于版本控制，还提供了一个git bash环境方便使用shell命令和脚本。\n6. 将本机和服务器之间配置免密登录，可以省去每次登录输入密码的时间，对VsCode也同样有效。\n7. 在学校服务器上下载代码的时候，可以下载到挂载的数据盘上，数据盘空间很大不会因为磁盘没有空间而导致训练终断。（数据盘的位置一般是/DATA或/data）\n\n## 4.3 常用科研工具\n\n1. 阅读文章的工具： ReadPaper、WPS\n2. 数据集下载和SOTA排名：超神经、Paperswithcode\n3. 下载论文的代码：Paperswithcode、Github\n4. [Linux命令速查手册](https://www.linuxcool.com/)\n5. Python开发文档：\n\t- [Python](https://docs.python.org/zh-cn/3/)\n\t- [PyTorch](https://pytorch.org/docs/stable/index.html)\n6. 镜像网站：\n\t- [Arxiv镜像](http://xxx.itp.ac.cn/)\n\t- [谷歌学术](https://gfsoso.99lb.net/)\n7. [神经网络在线模拟可视化](http://playground.tensorflow.org/)\n\n## 4.4 Other\n\n- [YOLOX（目标检测）](https://github.com/Megvii-BaseDetection/YOLOX)\n- [DeepSort（目标跟踪）](https://github.com/pmj110119/YOLOX_deepsort_tracker)\n- [SwinIR（图像超分）](https://github.com/JingyunLiang/SwinIR)\n- [商汤科技](https://github.com/open-mmlab)\n- [百度飞桨](https://github.com/PaddlePaddle)\n\n","tags":["AI","DL","image classification","PyTorch","Anaconda","SSH"],"categories":["AI"]},{"title":"02. 神经网络与深度学习基础","url":"/article/Prospective-Graduate-Summer-Training-02.html","content":"\n# 1. 神经网络基础\n\n## 1.1 感知机\n\n![](Prospective-Graduate-Summer-Training-02/02-1.jpg)\n\n> 感知机堆叠可以形成一个庞大的网状结构。\n>\n> => 但是通过感知机设计一个学习方案比较困难，因为通过该模型的输出时0和1，调参看不出明显的变化，即没有很好的反馈，并不能很好的设置w、b。\n\n## 1.2 神经网络的结构\n\n![](Prospective-Graduate-Summer-Training-02/02-2.jpg)\n\n> input_layer：输入层\n> hidden_layer：隐藏层\n> output_layer：输出层\n\n## 1.3 优化网络参数\n\n![](Prospective-Graduate-Summer-Training-02/02-3.jpg)\n\n### 如何优化\n\n![](Prospective-Graduate-Summer-Training-02/02-4.jpg)\n\n假设现在只考虑俩个变量v1和v2，不同情况下的代价函数如左图所示，我们希望优化参数使得总体损失最小。假设有一个小球放置在任意一点，那么受到重力影响，小球会滚下去，最终停在谷底。那么，小球滚下去的过程就是我们希望的优化的过程。\n\n在小球下降的过程中，可以看作小球分别沿着v1、v2方向下降。那么，如果我们分别将小球沿v1、v2分别移动一个小量，就可以改变代价值。\n\n![](Prospective-Graduate-Summer-Training-02/02-5.jpg)\n\n为了保证优化到最优，也就是C值最小，我们在优化过程中需要保证△C小于0，而AC取决于VC和△v的乘积，当函数形式和参数固定时，其梯度VC也固定了，但我们可以指定△v的值:\n\n![](Prospective-Graduate-Summer-Training-02/02-6.jpg)\n\n但是，不要忘记，我们真正关心的其实是参数v，因为v才是我们的优化目标:\n\n![](Prospective-Graduate-Summer-Training-02/02-7.jpg)\n\n### 如何计算梯度\n\n![](Prospective-Graduate-Summer-Training-02/02-8.jpg)\n\n**两种方案有什么优缺点：**\n\n- 二者在准确度上几乎无差异。\n- 直接计算方式：公式简单，代码实现难度较大。\n- 链式法则：公式较直接计算方式复杂，代码实现较易。\n\n### SGD\n\n![](Prospective-Graduate-Summer-Training-02/02-9.jpg)\n\n- SGD：只采集单个数据\n- mini-batch SGD：采集小批量数据\n- fullbatch Gradient Descent：采集整个数据集\n\n# 2. 让网络更有效\n\n## 2.1 MSE 与交叉熵\n\n> 损失函数用于描述模型预测值与真实值的差距大小，一般有两种比较常见的算法——均值平方差（MSE）和交叉熵。\n\n我们希望网络优化的力度，应该跟网络预测结果的偏差相关，即当网络预测偏\n差较大时，网络优化力度大；当网络预测偏差较小时，网络优化力度较小。\n\n1、均值平方差（MSE）：指参数估计值与参数真实值之差平方的期望值。\n\n![](Prospective-Graduate-Summer-Training-02/02-10.jpg)\n\n在神经网络计算时，预测值要与真实值控制在同样的数据分布内，假设将预测值经过Sigmoid激活函数得到取值范围在0~1之间，那么真实值也归一化到0~1之间。\n\n2、交叉熵：预测输入样本属于某一类的概率。\n\n![](Prospective-Graduate-Summer-Training-02/02-11.jpg)\n\n其中y代表真实值分类（0或1），a代表预测值，交叉熵值越小，预测结果越准。\n\n3、损失函数的选取\n\n损失函数的选取取决于输入标签数据的类型，如果输入的是实数、无界的值，损失函数使用平方差；如果输入标签是位矢量（分类标签），使用交叉熵会更合适。\n\n## 2.2 正则化（ regularization）\n\n仅仅依靠交叉熵或者MSE损失对网络进行约束， 虽然能让网络不断拟合训练数据， 但是这样拟合的方式可能不是我们想要的， 比如导致过拟合。 在这种情况下， 为了让网络按照我们想要的方式学习， 我们可以引入正则化项来对网络进行进一步的约束。\n\n- **L1范数**: 为x向量各个元素绝对值之和，简化模型，使权值稀疏，防止过拟合。\n- **L2范数**: 为x向量各个元素平方和的1/2次方，让模型平滑，也可以防止过拟合。\n- **Lp范数**: 为x向量各个元素绝对值p次方和的1/p次方.\n\n![](Prospective-Graduate-Summer-Training-02/02-17.jpg)\n\n## 2.3 参数初始化\n\n- 0初始化： https://mp.weixin.qq.com/s/OcEqqQq59adjZqBsh_7Zw\n- 随机初始化：随机初始化的时候常常采用高斯或均匀分布初始化网络权重，但可能会出现梯度消失和梯度爆炸现象。\n- Xavier初始化：通过保持输入和输出的方差一致（服从相同的分布）避免梯度消失和梯度爆炸问题，使得信号在神经网络中可以传递得更深，在经过多层神经元后保持在合理的范围（不至于太小或太大）\n\n## 2.4 激活函数改进\n\n### 激活函数定义\n\n在神经网络中，输入经过权值加权计算并求和之后，需要经过一个函数的作用，这个函数就是激活函数（Activation Function）。\n### 激活函数的作用\n\n首先我们需要知道，如果在神经网络中不引入激活函数，那么在该网络中，每一层的输出都是上一层输入的线性函数，无论最终的神经网络有多少层，输出都是输入的线性组合；其一般也只能应用于线性分类问题中，例如非常典型的多层感知机。若想在非线性的问题中继续发挥神经网络的优势，则此时就需要通过添加激活函数来对每一层的输出做处理，引入非线性因素，使得神经网络可以逼近任意的非线性函数，进而使得添加了激活函数的神经网络可以在非线性领域继续发挥重要作用！\n\n更进一步的，激活函数在神经网络中的应用，除了引入非线性表达能力，其在提高模型鲁棒性、缓解梯度消失问题、将特征输入映射到新的特征空间以及加速模型收敛等方面都有不同程度的改善作用！\n\n### Sigmoid：\n\n![](Prospective-Graduate-Summer-Training-02/02-12.jpg)\n\n- **优点**: \n\t- Sigmoid的取值范围在(0, 1)，而且是单调递增，比较容易优化\n\t- Sigmoid求导比较容易，可以直接推导得出\n- **缺点**：\n\t- sigmoid整体梯度较小， 最大只有0.25， 随着网络层数的加深梯度将逐渐减小， 造成梯度消失， 导致训练困难\n\t- sigmoid俩端平滑， 容易饱和， 只对中间区域敏感， 不利于参数学习\n\t- sigmoid的输出不是zero-centered ， 使得前后特征分布容易发生改变\n\t- Sigmoid函数收敛比较缓慢\n\n### Tanh\n\n![](Prospective-Graduate-Summer-Training-02/02-13.jpg)\n\n- **优点**：\n\t- 函数输出以（0,0）为中心\n\t- 收敛速度相对于Sigmoid更快\n- **缺点**：\n\t- tanh并没有解决sigmoid梯度消失的问题\n### ReLU\n\n![](Prospective-Graduate-Summer-Training-02/02-14.jpg)\n\n- **优点**：\n\t- 在SGD中收敛速度要比Sigmoid和tanh快很多\n\t- 有效的缓解了梯度消失问题\n\t- 对神经网络可以使用稀疏表达\n\t- 对于无监督学习，也能获得很好的效果\n- **缺点**：\n\t- 在训练过程中容易出现神经元失望，之后梯度永远为0的情况。比如一个特别大的梯度结果神经元之后，我们调整权重参数，就会造成这个ReLU神经元对后来来的输入永远都不会被激活，这个神经元的梯度永远都会是0，造成不可逆的死亡。\n## 2.5 dropout\n\ndropout在训练过程中随机忽略一部分神经元的结果，能够有效减轻过拟合现象。\n\n## 2.6 批归一化\n\n为了克服特征分布中包含的不利因素，一些归一化方式被提出，并使得网络训练效率大幅提升，以BN（batch normalization） 为例。\n\n### BN 的作用和缺陷\n![](Prospective-Graduate-Summer-Training-02/02-15.jpg)\n\n- BN的作用：\n\t- 允许较大的学习率\n\t- 减弱对初始化的强依赖性\n\t- 保持隐藏层中数值的均值、方差不变，让数值更稳定，为后面网络提供坚实的基础\n\t- 有轻微的正则化作用（相当于给隐藏层加入噪声，类似Dropout）\n- BN的缺陷：\n\t- 效果与batchsize相关， batch较小时，效果较差\n\t- 对于某些特定的模型，效果不佳，例如RNN\n\t- 训练和测试的统计量不一致\n\n### BN、LN、IN、GN 四种不同归一化方式的对比：\n\n![](Prospective-Graduate-Summer-Training-02/02-16.jpg)\n\n### BN 起作用的深层次原因\n\n- 对于输入数据进行标准化操作能够加速学习，那么对于隐藏层来说，学习具有统一分布的数据相对也会更具简单。\n- 解决了internal covariance shift问题\n- 起到了一定的正则化作用\n\n> 一篇较新的论文指出， BN的深层次作用机理与internal covariance shift无关，而是平滑了损失函数的landspace， How Does Batch Normalization Help Optimization?\n\n# 3. 深度学习\n\n## 3.1 CNN的出现\n\n卷积神经网络与普通神经网络的区别在于，卷积神经网络包含了一个由卷积层和子采样层（池化层）构成的特征抽取器。在卷积神经网络的卷积层中，一个神经元只与部分邻层神经元连接。在CNN的一个卷积层中，通常包含若干个特征图(featureMap)，每个特征图由一些矩形排列的的神经元组成，同一特征图的神经元共享权值，这里共享的权值就是卷积核。卷积核一般以随机小数矩阵的形式初始化，在网络的训练过程中卷积核将学习得到合理的权值。共享权值（卷积核）带来的直接好处是减少网络各层之间的连接，同时又降低了过拟合的风险。子采样也叫做池化（pooling），通常有均值子采样（mean pooling）和最大值子采样（max pooling）两种形式。子采样可以看作一种特殊的卷积过程。卷积和子采样大大简化了模型复杂度，减少了模型的参数。\n\n![](Prospective-Graduate-Summer-Training-02/02-18.jpg)\n\nCNN是一种人工神经网络，CNN的结构可以分为3层：\n\n- 卷积层(Convolutional Layer)：主要作用是提取特征。\n- 池化层(Max Pooling Layer)：主要作用是下采样(downsampling)，却不会损坏识别结果。\n- 全连接层(Fully Connected Layer)：主要作用是分类。\n\n基本概念：\n\n- 卷积核：卷积核就是图像处理时，给定输入图像，在输出图像中每一个像素是输入图像中一个小区域中像素的加权平均，其中权值由一个函数定义，这个函数称为卷积核。\n- 卷积：卷积可以对应到2个函数叠加，因此用一个filter和图片叠加就可以求出整个图片的情况，可以用在图像的边缘检测，图片锐化，模糊等方面。\n\n## 3.2 何谓“深度”\n\n### 为什么要变得更深？\n\n- 提升同样效果需要增加的宽度远远超过需要增加的深度\n- 宽而浅的网络可能比较擅长记忆，却不擅长概括，即泛化能力差\n\n### 网络变得更深要克服哪些问题？\n\n- 误差信号的多层反向传播容易产生“梯度消失”、“梯度爆炸”现象\n- 随着深度神经网络层数的增加，训练误差没有降低反而升高\n\n## 3.3 代表作ResNet\n\n![](Prospective-Graduate-Summer-Training-02/02-19.jpg)\n\nResNet也称为残差网络，ResNet要解决的是深度神经网络的”退化(degradation)”问题，即使用浅层直接堆叠成深层网络，不仅难以利用深层网络强大的特征提取能力，而且准确率会下降，这个退化不是由于过拟合引起的。\n\n","tags":["AI","NN","CNN","DL"],"categories":["AI"]},{"title":"01. 机器学习入门和研究生阶段学习建议","url":"/article/Prospective-Graduate-Summer-Training-01.html","content":"\n# 1. 机器学习\n\n## 1.1 人工智能的发展历程\n\n**逻辑推理** => **知识工程** => **机器学习**\n\n- 逻辑推理\n\t- 主要通过谓词逻辑演算模拟人类智能。\n\t- 主流核心技术是符号逻辑计算，在数学定理自动证明等领域获得了一定成功。\n- 知识工程\n\t- 专家系统使用基于专家知识库的知识推理取代纯粹的符号逻辑计算。\n\t- 在故障诊断、游戏博弈等领域取得了巨大成功。\n- 机器学习\n\t- 对于**给定的任务**和**性能度量标准**，使用**先验信息**，通过某种计算方式**改进初始模型**，获得一个**性能更好的模型**。\n\n## 1.2 AI & ML\n\n深度学习 ⊆ 表示学习 ⊆ 机器学习 ⊆ 人工智能\n\n\n## 1.3 ML 定义\n\n**假设用E来评估计算机程序在某任务类T上的性能，若一个程序通过利用经验P在T中任务上获得了性能改善，则我们就说关于T和E，该程序对P进行了学习。**\n\n> 机器学习：数据 -> 机器学习 -> 提高某种性能指标\n> => 简单点说，就是对数据通过机器学习来提高某种性能指标。\n\n## 1.4 三类任务\n\n- **回归**：通过若干带有标注的样本数据构造出一个预测模型分f(x)，使得f(x)的预测输出尽可能符合真实值。\n- **分类**：通过训练样本构建合适的分类器f(x)，完成对目标的分类。\n- **聚类**：对样本数据实现物以类聚的效果，聚类的类别由不同样本之间的某种相似性确定。\n\n## 1.5 三种常见类型\n\n- **监督学习**：利用一组带标注样本调整模型参数，提升模型性能的学习方式。\n- **无监督学习**：通过比较样本之间的某种联系实现对样本的数据分析。\n- **强化学习**：根据反馈信息来调整及其行为来实现自动决策的一种机器学习方式。\n\n> 比如上述所说的回归和分类任务就属于监督学习，因为他们都是有标签信息；聚类是无标签信息，属于无监督学习。\n\n## 1.6 机器学习三要素\n\n1. **模型**\n\n- 感知机、朴素贝叶斯模型、支持向量机、决策树、随机森林……\n- 线性回归、逻辑回归……\n- 神经网络……\n\n2. **学习准则**\n\n- 经验风险最小化\n- 损失函数\n\n3. **优化算法**\n\n- 梯度下降法\n- 反向传播算法\n- 动态规划算法\n- ……\n\n\n## 1.7 其他重要概念\n\n- **泛化误差**\n- **模型偏好**\n- **误差与损失函数**\n- **过/欠拟合**\n- **数据问题**\n- **评测问题**\n- **模型问题**\n- **算法问题**\n\n# 2. 研究生阶段学习建议\n\n## 2.1 论文\n\n### ① 如何读论文？\n\n![](01/01-1.jpg)\n\n> 通过论文，如何得到思路，然后如何通过实验实现这个思路，最后就是实验结果如何。\n\n### ② 怎么写论文？\n\n![](01/01-2.jpg)\n\n> 通过读论文，获得了哪些启发，进而形成自己的思路，再通过实验来实现思路并对实验结果进行观测、分析。如果结果不符合预期，还需要对思路进行验证、纠正，再重新进行实验并观测、分析结果，知道符合预期结果，然后就可以着手写论文了。\n\n## 2.2 多读多写\n\n> 多读论文、多写代码\n\n**论文获取来源：**\n\n1. 被动式\n\n- 大小组会、论坛、汇报\n- 各类科研群、同学老师的分享\n- 微信公众号、知乎等的推送\n\n> 1. 知乎专栏搜索\n> 2. Valse Webinar\n>\t(1) [幻灯片](http://valser.org/webinar/slide/)\n>\t(2) [往期简介](http:/valser.org/portal.php?mod=list&catid=6)\n> 3. 公众号:CVer, arXiv每日学术速递，专知,52CV,VALSE...\n\n2. 主动式\n\n- 网站\n\t- arXiv\n\t- Papers with Code\n\t- 会议期刊官网\n\t- GoogleSchooler\n\n- 论文章节\n\t- 相关工作\n\t- 参考文献\n\n> 1. [arXiv](https:/larxiv.org/)\n> 2. [极市平台的Github](https://github.com/extreme-assistant)\n> 3. [三大视觉顶会(ECCV Iccv CVPR)](https:/lopenaccess.thecvf.com/menu)\n> 4. 机器学习:ICML,ICLR,NeurlPS...\n>\t[ICML](https:/icml.cc/Conferences/2022/Schedule)\n>\t[ICLR](https://iclr.cc/)\n>\t[NeurlPS](https://proceedings.neurips.cc/)\n\n## 2.3 阅读论文方法\n\n### ① 论文结构\n\n![](01/01-03.jpg)\n\n### ② 阅读方法\n\n![](01/01-04.jpg)\n\n- 批判式阅读\n- 抱着学习的态度阅读\n- 带着问题阅读，阅读中要有思考\n- 不拘泥于自己研究方向的论文。\n\n## 2.4 科研工具推荐\n\n- 论文管理工具\n\t- [Zotero](https://www.zotero.org/)\n\n- 翻译工具\n\t- [Copytranslator](https://copytranslator.github.io)\n\t- [Bob](https://github.com/ripperhe/Bob/releases)\n","tags":["ML","AI","paper","research tools"],"categories":["AI"]},{"title":"Python3 基础","url":"/article/Python3.html","content":"\n# 1. 基础语法\n\n## 1.1 编码\n\n默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码\n\n```python\n# -*- coding: cp-1252 -*-\n```\n上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码。\n\n## 1.2 标识符\n\n- 第一个字符必须是字母表中字母或下划线 _ 。\n- 标识符的其他的部分由字母、数字和下划线组成。\n- **标识符对大小写敏感。**\n\n在 `Python 3` 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。\n\n## 1.3 Python 保留字\n\n保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：\n\n```python\n>>> import keyword\n>>> keyword.kwlist\n['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n\n## 1.4 注释\n\n- Python中单行注释以 `#` 开头\n- 多行注释可以用多个 `#` 号，还有 `'''` 和 `\"\"\"`\n\n## 1.5 行与缩进\n\npython最具特色的就是使用缩进来表示代码块，不需要使用大括号 `{}` 。\n\n缩进的空格数是可变的，但是**同一个代码块的语句必须包含相同的缩进空格数**。\n\n以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：\n\n```python\nif True:\n    print (\"Answer\")\n    print (\"True\")\nelse:\n    print (\"Answer\")\n  print (\"False\")    # 缩进不一致，会导致运行错误\n```\n\n以上程序由于缩进不一致，执行后会出现类似以下错误：\n\n```python\n File \"test.py\", line 6\n    print (\"False\")    # 缩进不一致，会导致运行错误\n                                      ^\nIndentationError: unindent does not match any outer indentation level\n```\n\n## 1.6 多行语句\n\nPython 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \\ 来实现多行语句，例如：\n\n```python\ntotal = item_one + \\\n        item_two + \\\n        item_three\n```\n\n在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \\，例如：\n\n```python\ntotal = ['item_one', 'item_two', 'item_three',\n        'item_four', 'item_five']\n```\n\n## 1.7 数字(Number)类型\n\n- **int ** (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\n- **bool ** (布尔), 如 True。\n- **float ** (浮点数), 如 1.23、3E-2\n- **complex ** (复数), 如 1 + 2j、 1.1 + 2.2j\n\n## 1.8 字符串(String)\n\n- Python 中单引号 `'` 和双引号 `\"` 使用完全相同。\n- 使用三引号( `'''` 或 `\"\"\"` )可以指定一个多行字符串。\n- 转义符 `\\` 。\n- 反斜杠可以用来转义，使用 `r` 可以让反斜杠不发生转义。 如 ** r\"this is a line with \\n **\"则 \\n 会显示，并不是换行。\n- 按字面意义级联字符串，如** \"this \" \"is \" \"string\" **会被自动转换为** this is string **。\n- 字符串可以用 `+` 运算符连接在一起，用 `*` 运算符重复。\n- Python 中的字符串有两种索引方式，从左往右以 `0` 开始，从右往左以 `-1` 开始。\n- Python 中的**字符串不能改变**。\n- Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n- 字符串的截取的语法格式如下：变量[头下标:尾下标:步长]\n\n```python\nword = '字符串'\nsentence = \"这是一个句子。\"\nparagraph = \"\"\"这是一个段落，\n可以由多行组成\"\"\"\n```\n\n```python\nstr='123456789'\n \nprint(str)                 # 输出字符串\nprint(str[0:-1])           # 输出第一个到倒数第二个的所有字符\nprint(str[0])              # 输出字符串第一个字符\nprint(str[2:5])            # 输出从第三个开始到第五个的字符\nprint(str[2:])             # 输出从第三个开始后的所有字符\nprint(str[1:5:2])          # 输出从第二个开始到第五个且每隔一个的字符（步长为2）\nprint(str * 2)             # 输出字符串两次\nprint(str + '你好')         # 连接字符串\n \nprint('------------------------------')\n \nprint('hello\\nrunoob')      # 使用反斜杠(\\)+n转义特殊字符\nprint(r'hello\\nrunoob')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义\n```\n\n这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如：\n\n```python\n>>> print('\\n')       # 输出空行\n\n>>> print(r'\\n')      # 输出 \\n\n\\n\n>>>\n```\n\n以上实例输出结果：\n```python\n123456789\n12345678\n1\n345\n3456789\n24\n123456789123456789\n123456789你好\n------------------------------\nhello\nrunoob\nhello\\nrunoob\n```\n\n## 1.9 空行\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n\n空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n> **记住：**空行也是程序代码的一部分。\n\n## 1.10 等待用户输入\n\n执行下面的程序在按回车键后就会等待用户输入：\n\n```python\ninput(\"\\n\\n按下 enter 键后退出。\")\n```\n\n以上代码中 ，\\n\\n 在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。\n\n## 1.11 同一行显示多条语句\n\nPython 可以在同一行中使用多条语句，语句之间使用分号 `;` 分割，以下是一个简单的实例：\n\n```python\n>>> import sys; x = 'runoob'; sys.stdout.write(x + '\\n')\nrunoob\n7\n```\n\n此处的 7 表示字符数，runoob 有 6 个字符，**\\n 表示一个字符**，加起来 7 个字符。\n\n## 1.12 多个语句构成代码组\n\n缩进相同的一组语句构成一个代码块，称之代码组。\n\n像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。\n\n将首行及后面的代码组称为一个子句(clause)。\n\n如下实例：\n\n```python\nif expression : \n   suite\nelif expression : \n   suite \nelse : \n   suite\n```\n\n## 1.13 print 输出\n\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=\"\"`：\n\n## 1.14 import 与 from...import\n在 python 用 `import` 或者` from...import` 来导入相应的模块。\n\n将整个模块(somemodule)导入，格式为： `import somemodule`\n\n从某个模块中导入某个函数,格式为：` from somemodule import somefunction`\n\n从某个模块中导入多个函数,格式为：` from somemodule import firstfunc, secondfunc, thirdfunc`\n\n将某个模块中的全部函数导入，格式为：` from somemodule import *`\n\n```python\n# 导入 sys 模块\nimport sys\nprint('================Python import mode==========================')\nprint ('命令行参数为:')\nfor i in sys.argv:\n    print (i)\nprint ('\\n python 路径为',sys.path)\n```\n\n```python\n# 导入 sys 模块的 argv,path 成员\nfrom sys import argv,path  #  导入特定的成员\n \nprint('================python from import===================================')\nprint('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path\n```\n\n## 1.15 命令行参数\n\n很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息\n\n\n# 2. 基本数据类型\n\nPython 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n\n在 Python 中，变量就是变量，它没有类型，我们所说的\"类型\"是变量所指的内存中对象的类型。\n\n等号（=）用来给变量赋值。\n\n等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。\n\n## 2.1 多个变量赋值\n\nPython允许你同时为多个变量赋值。例如：\n\n```python\na = b = c = 1\n```\n\n以上实例，**创建一个整型对象**，值为 1，从后向前赋值，三个变量被赋予相同的数值。\n\n您也可以为多个对象指定多个变量。例如：\n\n```python\na, b, c = 1, 2, \"runoob\"\n```\n\n以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 \"runoob\" 分配给变量 c。\n\n## 2.2 标准数据类型\n\nPython3 中有六个标准的数据类型：\n\n- Number（数字）\n- String（字符串）\n- List（列表）\n- Tuple（元组）\n- Set（集合）\n- Dictionary（字典）\n\nPython3 的六个标准数据类型中：\n\n- **不可变数据**（3 个）：Number（数字）、String（字符串）、Tuple（元组）；\n- **可变数据**（3 个）：List（列表）、Dictionary（字典）、Set（集合）。\n\n## 2.3 Number（数字）\n\nPython3 支持 **int、float、bool、complex（复数）**。\n\n**在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。**\n\n像大多数语言一样，数值类型的赋值和计算都是很直观的。\n\n内置的**type() 函数**可以用来查询变量所指的**对象类型**。\n\n```python\n>>> a, b, c, d = 20, 5.5, True, 4+3j\n>>> print(type(a), type(b), type(c), type(d))\n<class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n```\n\n此外还可以用 isinstance 来判断：\n```python\n>>> a = 111\n>>> isinstance(a, int)\nTrue\n>>>\n```\n\n**isinstance 和 type 的区别在于：**\n\n- type()不会认为子类是一种父类类型。\n- isinstance()会认为子类是一种父类类型。\n\n```python\n>>> class A:\n...     pass\n... \n>>> class B(A):\n...     pass\n... \n>>> isinstance(A(), A)\nTrue\n>>> type(A()) == A \nTrue\n>>> isinstance(B(), A)\nTrue\n>>> type(B()) == A\nFalse\n```\n\n> Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加，` True==1、False==0` 会返回 True，但可以通过 `is` 来判断类型。\n\n```python\n>>> issubclass(bool, int) \nTrue\n>>> True==1\nTrue\n>>> False==0\nTrue\n>>> True+1\n2\n>>> False+1\n1\n>>> 1 is True\nFalse\n>>> 0 is False\nFalse\n```\n\n> 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。\n\n当指定一个值时，Number 对象就会被创建：\n\n```python\nvar1 = 1\nvar2 = 10\n```\n\n也可以使用del语句删除一些对象引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n可以通过使用del语句删除单个或多个对象。例如：\n\n```python\ndel var\ndel var_a, var_b\n```\n\n**注意：**\n\n- 1、Python可以同时为多个变量赋值，如a, b = 1, 2。\n- 2、一个变量可以通过赋值指向不同类型的对象。\n- 3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。\n- 4、在混合计算时，Python会把整型转换成为浮点数。\n\nPython还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型\n\n## 2.4 String（字符串）\n\nPython中的字符串用单引号 `'` 或双引号 `\"` 括起来，同时使用反斜杠 `\\ ` 转义特殊字符。\n\n字符串的截取的语法格式如下：\n\n> 变量[头下标:尾下标]\n\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n\n![](Python3/123456-20200923-1.svg)\n\n加号 `+` 是字符串的连接符， 星号 `*` 表示复制当前字符串，与之结合的数字为复制的次数。\n\nPython 使用反斜杠 `\\ `转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 `r`，表示原始字符串\n\n```python\n>>> print('Ru\\noob')\nRu\noob\n>>> print(r'Ru\\noob')\nRu\\noob\n>>>\n```\n\n另外，反斜杠(\\)可以作为续行符，表示下一行是上一行的延续。也可以使用 \"\"\"...\"\"\" 或者 '''...''' 跨越多行。\n\n注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。\n\n```python\n>>> word = 'Python'\n>>> print(word[0], word[5])\nP n\n>>> print(word[-1], word[-6])\nn P\n```\n\n与 C 字符串不同的是，**Python 字符串不能被改变**。向一个索引位置赋值，比如word[0] = 'm'会导致错误。\n\n**注意：**\n\n- 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。\n- 2、字符串可以用+运算符连接在一起，用*运算符重复。\n- 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。\n- 4、Python中的字符串不能改变。\n\n## 2.5 List（列表）\n\nList（列表） 是 Python 中使用最频繁的数据类型。\n\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。\n\n列表是写在方括号 `[]` 之间、用逗号分隔开的元素列表。\n\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。\n\n列表截取的语法格式如下：\n\n> 变量[头下标:尾下标]\n\n索引值以 `0` 为开始值，`-1` 为从末尾的开始位置。\n\n![](Python3/list_slicing1_new1.png)\n\n加号 + 是列表连接运算符，星号 * 是重复操作。\n\n**与Python字符串不一样的是，列表中的元素是可以改变的：**\n\n```python\n>>> a = [1, 2, 3, 4, 5, 6]\n>>> a[0] = 9\n>>> a[2:5] = [13, 14, 15]\n>>> a\n[9, 2, 13, 14, 15, 6]\n>>> a[2:5] = []   # 将对应的元素值设置为 []\n>>> a\n[9, 2, 6]\n```\n\nList 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。\n\n**注意：**\n\n- 1、List写在方括号之间，元素用逗号隔开。\n- 2、和字符串一样，list可以被索引和切片。\n- 3、List可以使用+操作符进行拼接。\n- 4、List中的元素是可以改变的。\n\nPython 列表截取可以接收**第三个参数**，参数作用是**截取的步长**，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n![](Python3/py-dict-1.png)\n\n**如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：**\n\n```python\ndef reverseWords(input):\n     \n    # 通过空格将字符串分隔符，把各个单词分隔为列表\n    inputWords = input.split(\" \")\n \n    # 翻转字符串\n    # 假设列表 list = [1,2,3,4],  \n    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)\n    # inputWords[-1::-1] 有三个参数\n    # 第一个参数 -1 表示最后一个元素\n    # 第二个参数为空，表示移动到列表末尾\n    # 第三个参数为步长，-1 表示逆向\n    inputWords=inputWords[-1::-1]\n \n    # 重新组合字符串\n    output = ' '.join(inputWords)\n     \n    return output\n \nif __name__ == \"__main__\":\n    input = 'I like runoob'\n    rw = reverseWords(input)\n    print(rw)\n```\n\n输出结果为：\n```python\nrunoob like I\n```\n\n## 2.6 Tuple（元组）\n\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。\n\n元组中的元素类型也可以不相同。\n\n元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。\n\n其实，**可以把字符串看作一种特殊的元组**。\n\n```python\n>>> tup = (1, 2, 3, 4, 5, 6)\n>>> print(tup[0])\n1\n>>> print(tup[1:5])\n(2, 3, 4, 5)\n>>> tup[0] = 11  # 修改元组元素的操作是非法的\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>>\n```\n\n**虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。**\n\n构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：\n\n```python\ntup1 = ()    # 空元组\ntup2 = (20,) # 一个元素，需要在元素后添加逗号\n```\n\n> string、list 和 tuple 都属于 sequence（序列）。\n\n注意：\n\n- 1、与字符串一样，元组的元素不能修改。\n- 2、元组也可以被索引和切片，方法一样。\n- 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。\n- 4、元组也可以使用+操作符进行拼接。\n\n## 2.7 Set（集合）\n\n集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。\n\n基本功能是进行成员关系测试和删除重复元素。\n\n可以使用大括号 `{ }` 或者 `set()` 函数创建集合，注意：创建一个空集合必须用 `set()` 而不是 `{ }`，因为 `{ }` 是用来创建一个空字典。\n\n创建格式：\n```python\nparame = {value01,value02,...}\n或者\nset(value)\n```\n\n```python\nsites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}\n\nprint(sites)   # 输出集合，重复的元素被自动去掉\n\n# 成员测试\nif 'Runoob' in sites :\n    print('Runoob 在集合中')\nelse :\n    print('Runoob 不在集合中')\n\n\n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n\nprint(a)\n\nprint(a - b)     # a 和 b 的差集\n\nprint(a | b)     # a 和 b 的并集\n\nprint(a & b)     # a 和 b 的交集\n\nprint(a ^ b)     # a 和 b 中不同时存在的元素\n```\n\n以上实例输出结果：\n\n```python\n{'Zhihu', 'Baidu', 'Taobao', 'Runoob', 'Google', 'Facebook'}\nRunoob 在集合中\n{'b', 'c', 'a', 'r', 'd'}\n{'r', 'b', 'd'}\n{'b', 'c', 'a', 'z', 'm', 'r', 'l', 'd'}\n{'c', 'a'}\n{'z', 'b', 'm', 'r', 'l', 'd'}\n```\n\n## 2.8 Dictionary（字典）\n\n字典（dictionary）是Python中另一个非常有用的**内置数据类型**。\n\n**列表是有序的对象集合，字典是无序的对象集合**。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。\n\n字典是一种映射类型，字典用 `{ }` 标识，它是一个无序的` 键(key) : 值(value)` 的集合。\n\n键(key)必须使用不可变类型。\n\n**在同一个字典中，键(key)必须是唯一的。**\n\n```python\ndict = {}\ndict['one'] = \"1 - 菜鸟教程\"\ndict[2]     = \"2 - 菜鸟工具\"\n\ntinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}\n\n\nprint (dict['one'])       # 输出键为 'one' 的值\nprint (dict[2])           # 输出键为 2 的值\nprint (tinydict)          # 输出完整的字典\nprint (tinydict.keys())   # 输出所有键\nprint (tinydict.values()) # 输出所有值\n```\n\n以上实例输出结果：\n```python\n1 - 菜鸟教程\n2 - 菜鸟工具\n{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}\ndict_keys(['name', 'code', 'site'])\ndict_values(['runoob', 1, 'www.runoob.com'])\n```\n\n构造函数 dict() 可以直接从键值对序列中构建字典如下：\n\n```python\n>>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])\n{'Runoob': 1, 'Google': 2, 'Taobao': 3}\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n>>> dict(Runoob=1, Google=2, Taobao=3)\n{'Runoob': 1, 'Google': 2, 'Taobao': 3}\n```\n\n`{x: x**2 for x in (2, 4, 6)}` 该代码使用的是字典推导式，更多推导式内容可以参考：Python 推导式。\n\n另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。\n\n**注意：**\n\n- 1、字典是一种映射类型，它的元素是键值对。\n- 2、字典的关键字必须为不可变类型，且不能重复。\n- 3、创建空字典使用 { }。\n\n## 2.9 Python数据类型转换\n\n有时候，需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，在下一章节 数据类型转换 会具体介绍。\n\n# 3. 数据类型转换\n\n有时候，需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。\n\nPython 数据类型转换可以分为两种：\n\n- **隐式**类型转换 - 自动完成\n- **显式**类型转换 - 需要使用类型函数来转换\n\n## 3.1 隐式类型转换\n\n在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。\n\n以下实例中，对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。\n\n```python\nnum_int = 123\nnum_flo = 1.23\n\nnum_new = num_int + num_flo\n\nprint(\"datatype of num_int:\",type(num_int))\nprint(\"datatype of num_flo:\",type(num_flo))\n\nprint(\"Value of num_new:\",num_new)\nprint(\"datatype of num_new:\",type(num_new))\n```\n\n以上实例输出结果为：\n\n```python\nnum_int 数据类型为: <class 'int'>\nnum_flo 数据类型为: <class 'float'>\nnum_new: 值为: 124.23\nnum_new 数据类型为: <class 'float'>\n```\n\n代码解析：\n\n- 实例中我们对两个不同数据类型的变量 num_int 和 num_flo 进行相加运算，并存储在变量 num_new 中。\n- 然后查看三个变量的数据类型。\n- 在输出结果中，我们看到 num_int 是 整型（integer） ， num_flo 是 浮点型（float）。\n- 同样，新的变量 num_new 是 浮点型（float），这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。\n\n再看一个实例，整型数据与字符串类型的数据进行相加：\n\n```python\nnum_int = 123\nnum_str = \"456\"\n\nprint(\"Data type of num_int:\",type(num_int))\nprint(\"Data type of num_str:\",type(num_str))\n\nprint(num_int+num_str)\n```\n\n以上实例输出结果为：\n\n```python\nnum_int 数据类型为: <class 'int'>\nnum_str 数据类型为: <class 'str'>\nTraceback (most recent call last):\n  File \"/runoob-test/test.py\", line 7, in <module>\n    print(num_int+num_str)\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n```\n\n从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。\n\n但是，Python 为这些类型的情况提供了一种解决方案，称为显式转换。\n\n## 3.2 显式类型转换\n\n在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。\n\n整型和字符串类型进行运算，就可以用强制类型转换来完成：\n\n```python\nnum_int = 123\nnum_str = \"456\"\n\nprint(\"num_int 数据类型为:\",type(num_int))\nprint(\"类型转换前，num_str 数据类型为:\",type(num_str))\n\nnum_str = int(num_str)    # 强制转换为整型\nprint(\"类型转换后，num_str 数据类型为:\",type(num_str))\n\nnum_sum = num_int + num_str\n\nprint(\"num_int 与 num_str 相加结果为:\",num_sum)\nprint(\"sum 数据类型为:\",type(num_sum))\n```\n\n以上实例输出结果为：\n\n```python\nnum_int 数据类型为: <class 'int'>\n类型转换前，num_str 数据类型为: <class 'str'>\n类型转换后，num_str 数据类型为: <class 'int'>\nnum_int 与 num_str 相加结果为: 579\nsum 数据类型为: <class 'int'>\n```\n\n以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。\n\n|函数|描述|备注|\n|-|-|-|\n|int(x [,base])|将x转换为一个整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|float(x)|将x转换到一个浮点数||\n|complex(real [,imag])|创建一个复数|real -- int, long, float或字符串；imag -- int, long, float；|\n|str(x)|将对象 x 转换为字符串||\n|repr(x)|将对象 x 转换为表达式字符串||\n|eval(str)|用来计算在字符串中的有效Python表达式,并返回一个对象||\n|tuple(s)|将序列 s 转换为一个元组||\n|list(s)|将序列 s 转换为一个列表||\n|set(s)|转换为可变集合||\n|dict(d)|创建一个字典。d 必须是一个序列 (key,value)元组。||\n|frozenset(s)|转换为不可变集合||\n|chr(x)|将一个整数转换为一个字符||\n|ord(x)|将一个字符转换为它的整数值||\n|hex(x)|将一个整数转换为一个十六进制字符串||\n|oct(x)|将一个整数转换为一个八进制字符串||\n\n# 4. 推导式\n\nPython 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。\n\nPython 支持各种数据结构的推导式：\n\n- 列表(list)推导式\n- 字典(dict)推导式\n- 集合(set)推导式\n- 元组(tuple)推导式\n\n## 4.1 列表推导式\n列表推导式格式为：\n\n`[表达式 for 变量 in 列表]`\n\n`[out_exp_res for out_exp in input_list]`\n\n或者 \n\n`[表达式 for 变量 in 列表 if 条件]`\n\n`[out_exp_res for out_exp in input_list if condition]`\n\n- out_exp_res：列表生成元素表达式，可以是有返回值的函数。\n- for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。\n- if condition：条件语句，可以过滤列表中不符合条件的值。\n\n过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：\n\n```python\n>>> names = ['Bob','Tom','alice','Jerry','Wendy','Smith']\n>>> new_names = [name.upper()for name in names if len(name)>3]\n>>> print(new_names)\n['ALICE', 'JERRY', 'WENDY', 'SMITH']\n```\n\n计算 30 以内可以被 3 整除的整数：\n\n```python\n>>> multiples = [i for i in range(30) if i % 3 == 0]\n>>> print(multiples)\n[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]\n```\n> python range() 函数可创建一个整数列表，一般用在 for 循环中。\n> 函数语法range(start, stop[, step])\n> 参数说明：\n> start: 计数从 start 开始。默认是从 0 开始。例如range(5)等价于range(0， 5);\n> stop: 计数到 stop 结束，但不包括 stop。例如：range(0， 5) 是[0, 1, 2, 3, 4]没有5\n> step：步长，默认为1。例如：range(0， 5) 等价于 range(0, 5, 1)\n\n\n## 4.2 字典推导式\n\n字典推导基本格式：\n\n`{ key_expr: value_expr for value in collection }`\n\n或\n\n`{ key_expr: value_expr for value in collection if condition }`\n\n使用字符串及其长度创建字典：\n\n```python\nlistdemo = ['Google','Runoob', 'Taobao']\n# 将列表中各字符串值为键，各字符串的长度为值，组成键值对\n>>> newdict = {key:len(key) for key in listdemo}\n>>> newdict\n{'Google': 6, 'Runoob': 6, 'Taobao': 6}\n```\n\n提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：\n\n```python\n>>> dic = {x: x**2 for x in (2, 4, 6)}\n>>> dic\n{2: 4, 4: 16, 6: 36}\n>>> type(dic)\n<class 'dict'>\n```\n\n## 4.3 集合推导式\n\n集合推导式基本格式：\n\n`{ expression for item in Sequence }`\n\n或\n\n`{ expression for item in Sequence if conditional }`\n\n计算数字 1,2,3 的平方数：\n\n```python\n>>> setnew = {i**2 for i in (1,2,3)}\n>>> setnew\n{1, 4, 9}\n```\n\n判断不是 abc 的字母并输出：\n\n```python\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'d', 'r'}\n>>> type(a)\n<class 'set'>\n```\n\n## 4.4 元组推导式\n\n元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。\n\n元组推导式基本格式：\n\n`(expression for item in Sequence )`\n\n或\n\n`(expression for item in Sequence if conditional )`\n\n元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外**元组推导式返回的结果是一个生成器对象**。\n\n例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：\n\n```python\n>>> a = (x for x in range(1,10))\n>>> a\n<generator object <genexpr> at 0x7faf6ee20a50>  # 返回的是生成器对象\n\n>>> tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组\n(1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n\n\n# 5. 解释器\n\nPython 解释器有 CPython、IPython、Jython、PyPy 等。\n\n顾名思义，CPython 就是用 C 语言开发的了，是官方标准实现，拥有良好的生态，所以应用也就最为广泛了。\n\n而 [IPython](http://ipython.org/) 是在 CPython 的基础之上在交互式方面得到增强的解释器。\n\n[Jython](http://www.jython.org/) 是专为 Java 平台设计的 Python 解释器，它把 Python 代码编译成 Java 字节码执行。\n\n[PyPy](http://pypy.org/) 是 Python 语言（2.7.13和3.5.3）的一种快速、兼容的替代实现，以速度快著称。\n\n# 6. 注释\n\n确保对模块, 函数, 方法和行内注释使用正确的风格。\n\nPython 中的注释有单行注释和多行注释。\n\n- Python 中单行注释以 `#` 开头，例如\n- 多行注释用三个单引号 `'''` 或者三个双引号 `\"\"\"` 将注释括起来\n\n# 7. 运算符\n\nPython语言支持以下类型的运算符:\n\n- 算术运算符\n- 比较（关系）运算符\n- 赋值运算符\n- 逻辑运算符\n- 位运算符\n- 成员运算符\n- 身份运算符\n- 运算符优先级\n\n## 7.1 算术运算符\n\n以下假设变量： a=10，b=20：\n\n|运算符|描述|实例|\n|-|-|-|\n|%|取模 - 返回除法的余数|b % a 输出结果 0|\n|\\*\\*|幂 - 返回x的y次幂|a\\*\\*b 为10的20次方， 输出结果 100000000000000000000|\n|//|取整除 - 返回商的整数部分（**向下取整**）|9//2 输出 4 ; -9//2 输出 -5|\n\n> **注意：**  `Python2.x` 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。\n> 在 `Python 3.x` 中 / 除法不再这么做了，对于整数之间的相除，结果也会是浮点数。\n\n## 7.2 赋值运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|:=|海象运算符，可在表达式内部为变量赋值。**Python3.8 版本新增运算符。**|在下方示例中，赋值表达式可以避免调用 len() 两次: |\n\n```python\nif (n := len(a)) > 10:\n    print(f\"List is too long ({n} elements, expected <= 10)\")\n```\n\n## 7.3 位运算符\n\n按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n\n下表中变量 a 为 60，b 为 13，二进制格式如下：\n\n```python\na = 0011 1100\n\nb = 0000 1101\n\n-----------------\n\na&b = 0000 1100\n\na|b = 0011 1101\n\na^b = 0011 0001\n\n~a  = 1100 0011\n```\n|运算符|描述|实例|\n|-|-|-|\n|&|按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0|(a & b) 输出结果 12 ，二进制解释： 0000 1100|\n|\\||按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。|(a | b) 输出结果 61 ，二进制解释： 0011 1101|\n|^|按位异或运算符：当两对应的二进位相异时，结果为1|(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|\n|~|按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|\n|<<|左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。|a << 2 输出结果 240 ，二进制解释： 1111 0000|\n|>>|右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|\n\n## 7.4 逻辑运算符\n\nPython语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n> **注意：** 关注and、or的返回值问题\n\n|运算符|逻辑表达式|描述|实例|\n|-|-|-|-|\n|and|x and y|布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它**返回 y 的计算值**。|(a and b) 返回 20。|\n|or|x or y|布尔\"或\" - **如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。**|(a or b) 返回 10。|\n|not|not x|布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|not(a and b) 返回 False|\n\n## 7.5 成员运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|in|如果在指定的序列中找到值返回 True，否则返回 False。|x 在 y 序列中 , 如果 x 在 y 序列中返回 True。|\n|not in|如果在指定的序列中没有找到值返回 True，否则返回 False。|x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。|\n\n## 7.6 身份运算符\n\n身份运算符用于比较两个对象的存储单元\n\n|运算符|描述|实例|\n|-|-|-|\n|is|is 是判断两个标识符是不是引用自一个对象|x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False|\n|is not|is not 是判断两个标识符是不是引用自不同对象|x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。|\n\n>注： id() 函数用于获取对象内存地址。\n>id() 函数返回对象的唯一标识符，标识符是一个整数。CPython 中 id() 函数用于获取对象的内存地址\n>id 语法：id([object])，参数说明：object -- 对象。\n\n### is 与 == 区别：\n\n**is **用于判断两个变量引用对象是否为**同一个(同一块内存空间)**，**==**用于判断引用变量的**值是否相等**。\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a \nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\n## 7.7 运算符优先级\n\n以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）：\n\n|运算符|描述|\n|-|-|\n|(expressions...),[expressions...], {key: value...}, {expressions...}|圆括号的表达式|\n|x[index], x[index:index], x(arguments...), x.attribute|读取，切片，调用，属性引用|\n|await x|await 表达式|\n|\\*\\*|乘方(指数)|\n|+x, -x, ~x|正，负，按位非 NOT|\n|\\*, @, /, //, %|乘，矩阵乘，除，整除，取余|\n|+, -|加和减|\n|<<, >>|移位|\n|&|按位与 AND|\n|^|按位异或 XOR|\n|\\||按位或 OR|\n|in,not in, is,is not, <, <=, >, >=, !=, ==|比较运算，包括成员检测和标识号检测|\n|not x|逻辑非 NOT|\n|and|逻辑与 AND|\n|or|逻辑或 OR|\n|if -- else|条件表达式|\n|lambda|lambda 表达式|\n|:=|赋值表达式|\n\n> 注意：Pyhton3 已不支持 <> 运算符，可以使用 != 代替，如果你一定要使用这种比较运算符，可以使用以下的方式：\n> ```python\n> >>> from __future__ import barry_as_FLUFL\n> >>> 1 <> 2\n> True\n> ```\n\n# 8. 数字（Number）\n\nPython 数字数据类型用于存储数值。\n\n**数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。**\n\n以下实例在变量赋值时 Number 对象将被创建：\n\n```python\nvar1 = 1\nvar2 = 10\n```\n\n也可以使用del语句删除一些数字对象的引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n可以通过使用del语句删除单个或多个对象的引用，例如：\n```python\ndel var\ndel var_a, var_b\n```\n\nPython 支持三种不同的数值类型：\n\n- **整型**(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。\n\n- **浮点型**(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）\n\n- **复数**( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。\n\n> Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是**浮点型**。\n\n## 8.1 数字类型转换\n\n有时候，我们需要对数据内置的类型进行转换，数据类型的转换，只需要将数据类型作为函数名即可。\n\n- int(x) 将x转换为一个整数。\n- float(x) 将x转换到一个浮点数。\n- complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。\n- complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。\n\n## 8.2 数字运算\n\nPython 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。\n\n表达式的语法很直白： `+`, `-`, `*` 和 `/`, 和其它语言（如Pascal或C）里一样。\n\n注意：在不同的机器上浮点运算的结果可能会不一样。\n\n在整数除法中，**除法 `/` 总是返回一个浮点数**，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 `//`。\n\n注意：// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。\n\n```python\n>>> 7//2\n3\n>>> 7.0//2\n3.0\n>>> 7//2.0\n3.0\n>>> \n```\n\n变量在使用前必须先\"定义\"（即赋予变量一个值），否则会出现错误：\n\n```python\n>>> n   # 尝试访问一个未定义的变量\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'n' is not defined\n```\n\n不同类型的数混合运算时会将整数转换为浮点数。\n\n[数学函数、随机数函数、三角函数、数学常量](https://www.runoob.com/python3/python3-number.html)\n\n\n# 9. 字符串（String）\n\n字符串是 Python 中最常用的数据类型。我们可以使用引号( `'` 或 `\"` )来创建字符串。\n\n创建字符串很简单，只要为变量分配一个值即可。\n\n## 9.1 访问字符串中的值\n\nPython 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。\n\nPython 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下：\n\n`变量[头下标:尾下标]`\n\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n\n![](Python3/123456-20200923-1.svg)\n\n![](Python3/python-str-runoob.png)\n\n## 9.2 转义字符\n\n在需要在字符中使用特殊字符时，python 用反斜杠 `\\ ` 转义字符\n\n> [\\, \\\\, \\', \\\", \\a, \\b, \\000, \\n, \\v, \\t, \\r, \\f, \\yyy, \\xyy ,\\other ](https://www.runoob.com/python3/python3-string.html)\n\n## 9.3 字符串运算符\n\n> [+, \\*, [], [ : ], in, not in, r/R, %](https://www.runoob.com/python3/python3-string.html)\n\n## 9.4 字符串格式化\n\nPython 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。\n\n在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。\n\n```python\nprint (\"我叫 %s 今年 %d 岁!\" % ('小明', 10))\n```\n\n以上实例输出结果：\n```python\n我叫 小明 今年 10 岁!\n```\n\n> [python字符串格式化符号](https://www.runoob.com/python3/python3-string.html)\n> [格式化操作符辅助指令](https://www.runoob.com/python3/python3-string.html)\n\nPython2.6 开始，新增了一种格式化字符串的函数 [str.format()](https://www.runoob.com/python/att-string-format.html)，它增强了字符串格式化的功能。\n\n## 9.5 三引号\n\npython三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下：\n\n```python\npara_str = \"\"\"这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB ( \\t )。\n也可以使用换行符 [ \\n ]。\n\"\"\"\nprint (para_str)\n```\n\n以上实例执行结果为：\n\n```python\n这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB (    )。\n也可以使用换行符 [ \n ]。\n```\n\n三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的**WYSIWYG（所见即所得）**格式的。\n\n## 9.6 f-string\n\nf-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。\n\n之前我们习惯用百分号 (%):\n\n```python\n>>> name = 'Runoob'\n>>> 'Hello %s' % name\n'Hello Runoob'\n```\n\nf-string 格式化字符串以 `f` 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：\n\n```python\n>>> name = 'Runoob'\n>>> f'Hello {name}'  # 替换变量\n'Hello Runoob'\n>>> f'{1+2}'         # 使用表达式\n'3'\n\n>>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}\n>>> f'{w[\"name\"]}: {w[\"url\"]}'\n'Runoob: www.runoob.com'\n```\n\n用了这种方式明显更简单了，**不用再去判断使用 %s，还是 %d**。\n\n**在 Python 3.8 的版本中可以使用 `=` 符号来拼接运算表达式与结果：**\n\n```python\n>>> x = 1\n>>> print(f'{x+1}')   # Python 3.6\n2\n\n>>> x = 1\n>>> print(f'{x+1=}')   # Python 3.8\nx+1=2\n```\n\n## 9.7 Unicode 字符串\n\n在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。\n\n在Python3中，所有的字符串都是Unicode字符串。\n\n## 9.8 字符串内建函数\n\n[Python 的字符串常用内建函数](https://www.runoob.com/python3/python3-string.html)\n\n# 10. 列表（List）\n\n序列是 Python 中最基本的数据结构。\n\n序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。\n\nPython 有 6 个序列的内置类型，但最常见的是列表和元组。\n\n列表都可以进行的操作包括索引，切片，加，乘，检查成员。\n\n此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。\n\n列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。\n\n列表的数据项不需要具有相同的类型\n\n创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：\n\n```python\nlist1 = ['Google', 'Runoob', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5 ]\nlist3 = [\"a\", \"b\", \"c\", \"d\"]\nlist4 = ['red', 'green', 'blue', 'yellow', 'white', 'black']\n```\n\n## 10.1 访问列表中的值\n与字符串的索引一样，列表索引从 `0` 开始，第二个索引是 `1`，依此类推。\n\n通过索引列表可以进行截取、组合等操作。\n\n![](Python3/positive-indexes-1.png)\n\n索引也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2，以此类推。\n\n![](Python3/negative-indexes.png)\n\n使用下标索引来访问列表中的值，同样也可以使用方括号 [] 的形式截取字符，如下所示：\n\n![](Python3/first-slice.png)\n\n使用负数索引值截取：\n\n```python\nlist = ['Google', 'Runoob', \"Zhihu\", \"Taobao\", \"Wiki\"]\n \n# 读取第二位\nprint (\"list[1]: \", list[1])\n# 从第二位开始（包含）截取到倒数第二位（不包含）\nprint (\"list[1:-2]: \", list[1:-2])\n```\n\n以上实例输出结果：\n\n```python\nlist[1]:  Runoob\nlist[1:-2]:  ['Runoob', 'Zhihu']\n```\n\n## 10.2 列表脚本操作符\n\n列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，\\* 号用于重复列表。\n\n## 10.3 嵌套列表\n\n使用嵌套列表即在列表里创建其它列表，例如：\n\n```python\n>>> a = ['a', 'b', 'c']\n>>> n = [1, 2, 3]\n>>> x = [a, n]\n>>> x\n[['a', 'b', 'c'], [1, 2, 3]]\n>>> x[0]\n['a', 'b', 'c']\n>>> x[0][1]\n'b'\n```\n\n## 10.4 列表比较\n\n列表比较需要引入 operator 模块的 eq 方法（详见：[Python operator 模块](https://www.runoob.com/python3/python-operator.html)）：\n\n```python\n# 导入 operator 模块\nimport operator\n\na = [1, 2]\nb = [2, 3]\nc = [2, 3]\nprint(\"operator.eq(a,b): \", operator.eq(a,b))\nprint(\"operator.eq(c,b): \", operator.eq(c,b))\n```\n\n以上代码输出结果为：\n\n```python\noperator.eq(a,b):  False\noperator.eq(c,b):  True\n```\n\n## 10.5 Python列表函数&方法\n\n[Python包含以下函数和方法](https://www.runoob.com/python3/python3-list.html)。\n\n# 11. 元组（Tuple）\n\nPython 的元组与列表类似，不同之处在于元组的元素不能修改。\n\n## 11.1 访问元组中的值\n\n元组使用小括号 `( )`，列表使用方括号 `[ ]`。\n\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n\n![](Python3/tup-2020-10-27-10-26-2.png)\n\n```python\n>>> tup1 = ('Google', 'Runoob', 1997, 2000)\n>>> tup2 = (1, 2, 3, 4, 5 )\n>>> tup3 = \"a\", \"b\", \"c\", \"d\"   #  不需要括号也可以\n>>> type(tup3)\n<class 'tuple'>\n```\n\n创建空元组\n\ntup1 = ()\n**元组中只包含一个元素时，需要在元素后面添加逗号 `,` ，否则括号会被当作运算符使用：**\n\n```python\n>>> tup1 = (50)\n>>> type(tup1)     # 不加逗号，类型为整型\n<class 'int'>\n\n>>> tup1 = (50,)\n>>> type(tup1)     # 加上逗号，类型为元组\n<class 'tuple'>\n```\n\n元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等。\n\n![](Python3/py-tup-10-26.png)\n\n\n**元组中的元素值是不允许修改的，但我们可以对元组进行连接组合。**\n\n## 11.2 元组内置函数\n\n[Python元组包含了以下内置函数](https://www.runoob.com/python3/python3-tuple.html)\n\n## 11.3 关于元组是不可变的\n\n所谓元组的不可变指的是**元组所指向的内存中的内容**不可变。\n\n```python\n>>> tup = ('r', 'u', 'n', 'o', 'o', 'b')\n>>> tup[0] = 'g'     # 不支持修改元素\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> id(tup)     # 查看内存地址\n4440687904\n>>> tup = (1,2,3)\n>>> id(tup)\n4441088800    # 内存地址不一样了\n```\n\n**从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。**\n\n# 12. 字典（Dictionary）\n\n字典是另一种可变容器模型，且可存储任意类型对象。\n\n字典的每个键值 `key=>value` 对用冒号 `:` 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 `{}` 中 ,格式如下所示：\n\nd = {key1 : value1, key2 : value2, key3 : value3 }\n\n注意：`dict` 作为 Python 的关键字和内置函数，变量名不建议命名为 **dict**。\n\n![](Python3/py-dict-3.png)\n\n**键必须是唯一的，但值则不必。**\n\n值可以取任何数据类型，但**键必须是不可变的**，如字符串，数字。\n\n## 12.1 创建空字典\n\n**使用大括号 { } 创建空字典：**\n\n```python\n# 使用大括号 {} 来创建空字典\nemptyDict = {}\n \n# 打印字典\nprint(emptyDict)\n \n# 查看字典的数量\nprint(\"Length:\", len(emptyDict))\n \n# 查看类型\nprint(type(emptyDict))\n```\n\n以上实例输出结果：\n\n```python\n{}\nLength: 0\n<class 'dict'>\n```\n\n**使用内建函数 dict() 创建字典：**\n\n```python\nemptyDict = dict()\n \n# 打印字典\nprint(emptyDict)\n \n# 查看字典的数量\nprint(\"Length:\",len(emptyDict))\n \n# 查看类型\nprint(type(emptyDict))\n```\n\n以上实例输出结果：\n\n```python\n{}\nLength: 0\n<class 'dict'>\n```\n\n## 12.2 删除字典元素\n\n能**删单一的元素**也能**清空字典**，清空只需一项操作。\n\n**显式删除**一个字典用del命令，如下实例：\n\n```python\ntinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}\n \ndel tinydict['Name'] # 删除键 'Name'\ntinydict.clear()     # 清空字典\ndel tinydict         # 删除字典\n \nprint (\"tinydict['Age']: \", tinydict['Age'])\nprint (\"tinydict['School']: \", tinydict['School'])\n```\n\n但这会引发一个异常，因为用执行 del 操作后字典不再存在：\n\n```python\nTraceback (most recent call last):\n  File \"/runoob-test/test.py\", line 9, in <module>\n    print (\"tinydict['Age']: \", tinydict['Age'])\nNameError: name 'tinydict' is not defined\n```\n\n## 12.3 字典键的特性\n\n字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。\n\n两个重要的点需要记住：\n\n**1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住**，如下实例：\n\n```python\ntinydict = {'Name': 'Runoob', 'Age': 7, 'Name': '小菜鸟'}\n \nprint (\"tinydict['Name']: \", tinydict['Name'])\n```\n\n以上实例输出结果：\n\n```python\ntinydict['Name']:  小菜鸟\n```\n\n**2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行**，如下实例：\n\n```python\ntinydict = {['Name']: 'Runoob', 'Age': 7}\n \nprint (\"tinydict['Name']: \", tinydict['Name'])\n```\n\n以上实例输出结果：\n\n```python\nTraceback (most recent call last):\n  File \"test.py\", line 3, in <module>\n    tinydict = {['Name']: 'Runoob', 'Age': 7}\nTypeError: unhashable type: 'list'\n```\n\n## 12.4 字典内置函数&方法\n\n[Python字典包含了以下内置函数、方法](https://www.runoob.com/python3/python3-dictionary.html)\n\n# 13. 集合（Set）\n\n集合（set）是一个无序的不重复元素序列。\n\n## 13.1 访问集合中的值\n可以使用大括号 `{ }` 或者 `set()` 函数创建集合，注意：**创建一个空集合必须用 set() 而不是 { }**，因为 { } 是用来创建一个空字典。\n\n创建格式：\n\n`parame = {value01,value02,...}`\n\n或者\n\n`set(value)`\n\n```python\n>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n>>> print(basket)                      # 这里演示的是去重功能\n{'orange', 'banana', 'pear', 'apple'}\n>>> 'orange' in basket                 # 快速判断元素是否在集合内\nTrue\n>>> 'crabgrass' in basket\nFalse\n\n>>> # 下面展示两个集合间的运算.\n...\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  \n{'a', 'r', 'b', 'c', 'd'}\n>>> a - b                              # 集合a中包含而集合b中不包含的元素\n{'r', 'd', 'b'}\n>>> a | b                              # 集合a或b中包含的所有元素\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n>>> a & b                              # 集合a和b中都包含了的元素\n{'a', 'c'}\n>>> a ^ b                              # 不同时包含于a和b的元素\n{'r', 'd', 'b', 'm', 'z', 'l'}\n```\n\n类似列表推导式，同样集合支持集合推导式(Set comprehension):\n\n```python\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\n{'r', 'd'}\n```\n\n## 13.2 集合内置方法完整列表\n\nTips：\n\n- s.add( x ) 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。\n- s.update( x ) 可以添加元素，且参数可以是列表，元组，字典等；x 可以有多个，用逗号分开。\n- s.remove( x ) 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。\n- s.discard( x ) 方法也是移除集合中的元素，且如果元素不存在，不会发生错误。\n- s.pop()  随机删除集合中的一个元素。set 集合的 pop 方法会**对集合进行无序的排列**，然后将这个无序排列集合的**左面第一个元素进行删除**。\n\n[集合内置方法](https://www.runoob.com/python3/python3-set.html)\n\n\n# 14. 编程第一步\n\n通过前面所学的 Python3 基本语法知识，尝试来写一个斐波纳契数列。\n\n```python\n# Fibonacci series: 斐波纳契数列\n# 两个元素的总和确定了下一个数\na, b = 0, 1\nwhile b < 10:\n    print(b)\n    a, b = b, a+b\n```\n\n执行以上程序，输出结果为：\n\n```python\n1\n1\n2\n3\n5\n8\n```\n\n这个例子介绍了几个新特征。\n\n第一行包含了一个**复合赋值**：变量 a 和 b 同时得到新值 0 和 1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。\n\n## 14.1 end 关键字\n\n关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：\n\n```python\n# Fibonacci series: 斐波纳契数列\n# 两个元素的总和确定了下一个数\na, b = 0, 1\nwhile b < 1000:\n    print(b, end=',')\n    a, b = b, a+b\n```\n\n执行以上程序，输出结果为：\n\n```python\n1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n```\n\n# 15. 条件控制\n\nPython 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。\n\n可以通过下图来简单了解条件语句的执行过程:\n\n![](Python3/if-condition.jpg)\n\n代码执行过程：\n\n![](Python3/python-if.webp)\n\n## 15.1 if 语句\nPython中if语句的一般形式如下所示：\n\n```python\nif condition_1:\n    statement_block_1\nelif condition_2:\n    statement_block_2\nelse:\n    statement_block_3\n```\nPython 中用 `elif` 代替了 `else if`，所以if语句的关键字为：`if – elif – else`。\n\n注意：\n\n- 1、每个条件后面要使用冒号 `:`，表示接下来是满足条件后要执行的语句块。\n- 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。\n- 3、**在Python中没有switch – case语句。**\n\n![](Python3/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif)\n\n## 15.2 if 嵌套\n在嵌套 if 语句中，可以把 `if...elif...else` 结构放在另外一个 `if...elif...else` 结构中。\n\n```python\nif 表达式1:\n    语句\n    if 表达式2:\n        语句\n    elif 表达式3:\n        语句\n    else:\n        语句\nelif 表达式4:\n    语句\nelse:\n    语句\n```\n\n# 16. 循环控制\n\nPython 中的循环语句有 for 和 while。\n\nPython 循环语句的控制结构图如下所示：\n\n![](Python3/loop.png)\n\n## 16.1 while 循环\n\nPython 中 while 语句的一般形式：\n\n```python\nwhile 判断条件(condition)：\n    执行语句(statements)……\n```\n\n执行流程图如下：\n\n![](Python3/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg)\n\n执行 Gif 演示：\n\n![](Python3/006faQNTgw1f5wnm06h3ug30ci08cake.gif)\n\n同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。\n\n## 16.2 无限循环\n\n我们可以通过**设置条件表达式永远不为 false** 来实现无限循环，实例如下：\n\n```python\nvar = 1\nwhile var == 1 :  # 表达式永远为 true\n   num = int(input(\"输入一个数字  :\"))\n   print (\"你输入的数字是: \", num)\n \nprint (\"Good bye!\")\n```\n\n执行以上脚本，输出结果如下：\n\n```python\n输入一个数字  :5\n你输入的数字是:  5\n输入一个数字  :\n```\n\n可以使用 `CTRL+C` 来退出当前的无限循环。\n\n无限循环在**服务器上客户端的实时请求**非常有用。\n\n## 16.3 while 循环使用 else 语句\n\n如果 while 后面的条件语句为 false 时，则执行 else 的语句块。\n\n语法格式如下：\n\n```python\nwhile <expr>:\n    <statement(s)>\nelse:\n    <additional_statement(s)>\n```\n\nexpr 条件语句为 true 则执行 statement(s) 语句块，如果为 false，则执行 additional_statement(s)。\n\n循环输出数字，并判断大小：\n\n```python\ncount = 0\nwhile count < 5:\n   print (count, \" 小于 5\")\n   count = count + 1\nelse:\n   print (count, \" 大于或等于 5\")\n```\n\n执行以上脚本，输出结果如下：\n\n```python\n0  小于 5\n1  小于 5\n2  小于 5\n3  小于 5\n4  小于 5\n5  大于或等于 5\n```\n\n## 16.4 简单语句组\n类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：\n\n```python\nflag = 1\n \nwhile (flag): print ('欢迎访问菜鸟教程!')\n \nprint (\"Good bye!\")\n```\n\n## 16.5 for 语句\nPython for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。\n\nfor循环的一般格式如下：\n\n```python\nfor <variable> in <sequence>:\n    <statements>\nelse:\n    <statements>\n```\n\n流程图：\n\n![](Python3/A71EC47E-BC53-4923-8F88-B027937EE2FF.jpg)\n\n以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：\n\n```python\nsites = [\"Baidu\", \"Google\",\"Runoob\",\"Taobao\"]\nfor site in sites:\n    if site == \"Runoob\":\n        print(\"菜鸟教程!\")\n        break\n    print(\"循环数据 \" + site)\nelse:\n    print(\"没有循环数据!\")\nprint(\"完成循环!\")\n```\n\n执行脚本后，在循环到 \"Runoob\"时会跳出循环体：\n\n```python\n循环数据 Baidu\n循环数据 Google\n菜鸟教程!\n完成循环!\n```\n\n## 16.6 range()函数\n\n1. 如果需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:\n\n```python\n>>>for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\n```\n\n2. 也可以使用range指定区间的值：\n\n```python\n>>>for i in range(5,9) :\n    print(i)\n \n    \n5\n6\n7\n8\n>>>\n```\n\n3. 也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'**步长**'):\n\n```python\n>>>for i in range(0, 10, 3) :\n    print(i)\n \n    \n0\n3\n6\n9\n>>>\n```\n\n4. 负数：\n\n```python\n>>>for i in range(-10, -100, -30) :\n    print(i)\n \n    \n-10\n-40\n-70\n>>>\n```\n\n5. 也可以结合range()和len()函数以遍历一个序列的索引,如下所示:\n\n```python\n>>>a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']\n>>> for i in range(len(a)):\n...     print(i, a[i])\n... \n0 Google\n1 Baidu\n2 Runoob\n3 Taobao\n4 QQ\n>>>\n```\n\n6. 还可以使用range()函数来创建一个列表：\n\n```python\n>>>list(range(5))\n[0, 1, 2, 3, 4]\n>>>\n```\n\n## 16.7 break 和 continue 语句及循环中的 else 子句\nbreak 执行流程图：\n\n![](Python3/E5A591EF-6515-4BCB-AEAA-A97ABEFC5D7D.jpg)\n\ncontinue 执行流程图：\n\n![](Python3/8962A4F1-B78C-4877-B328-903366EA1470.jpg)\n\nwhile 语句代码执行过程：\n\n![](Python3/python-while.webp)\n\nfor 语句代码执行过程：\n\n![](Python3/break-continue-536.png)\n\n`break` 语句可以跳出 for 和 while 的循环体。如果从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。\n\n`continue` 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\n\n循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。\n\n如下实例用于查询质数的循环例子:\n\n```python\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            print(n, '等于', x, '*', n//x)\n            break\n    else:\n        # 循环中没有找到元素\n        print(n, ' 是质数')\n```\n执行以上脚本输出结果为：\n\n```python\n2  是质数\n3  是质数\n4 等于 2 * 2\n5  是质数\n6 等于 2 * 3\n7  是质数\n8 等于 2 * 4\n9 等于 3 * 3\n```\n\n## 16.8 pass 语句\n\nPython pass是空语句，是为了保持程序结构的完整性。\n\n`pass` 不做任何事情，一般用做占位语句，如下实例\n\n```python\n>>>while True:\n...     pass  # 等待键盘中断 (Ctrl+C)\n```\n\n最小的类:\n\n```python\n>>>class MyEmptyClass:\n...     pass\n```\n\n# 17. 迭代器与生成器\n\n## 17.1 迭代器\n\n迭代是Python最强大的功能之一，是访问集合元素的一种方式。\n\n迭代器是一个可以记住遍历的位置的对象。\n\n迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n\n迭代器有两个基本的方法：`iter()` 和 `next()`。\n\n字符串，列表或元组对象都可用于创建迭代器：\n\n```python\n>>> list=[1,2,3,4]\n>>> it = iter(list)    # 创建迭代器对象\n>>> print (next(it))   # 输出迭代器的下一个元素\n1\n>>> print (next(it))\n2\n>>>\n```\n\n迭代器对象可以使用常规for语句进行遍历：\n\n```python\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nfor x in it:\n    print (x, end=\" \")\n```\n\n执行以上程序，输出结果如下：\n\n```python\n1 2 3 4\n```\n\n也可以使用 next() 函数：\n\n```python\nimport sys         # 引入 sys 模块\n \nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\n \nwhile True:\n    try:\n        print (next(it))\n    except StopIteration:\n        sys.exit()\n```\n\n执行以上程序，输出结果如下：\n\n```python\n1\n2\n3\n4\n```\n\n## 17.2 创建一个迭代器\n\n把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。\n\n如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 __init__(), 它会在对象初始化的时候执行。\n\n更多内容查阅：Python3 面向对象\n\n__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。\n\n__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。\n\n创建一个返回数字的迭代器，初始值为 1，逐步递增 1：\n\n```python\nclass MyNumbers:\n  def __iter__(self):\n    self.a = 1\n    return self\n \n  def __next__(self):\n    x = self.a\n    self.a += 1\n    return x\n \nmyclass = MyNumbers()\nmyiter = iter(myclass)\n \nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\nprint(next(myiter))\n```\n\n执行输出结果为：\n\n```python\n1\n2\n3\n4\n5\n```\n\n### StopIteration\nStopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。\n\n在 20 次迭代后停止执行：\n\n```python\nclass MyNumbers:\n  def __iter__(self):\n    self.a = 1\n    return self\n \n  def __next__(self):\n    if self.a <= 20:\n      x = self.a\n      self.a += 1\n      return x\n    else:\n      raise StopIteration\n \nmyclass = MyNumbers()\nmyiter = iter(myclass)\n \nfor x in myiter:\n  print(x)\n  \n```\n\n执行输出结果为：\n\n```python\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n```\n\n## 17.3 生成器\n在 Python 中，使用了 yield 的函数被称为生成器（generator）。\n\n跟普通函数不同的是，**生成器是一个返回迭代器的函数，只能用于迭代操作**，更简单点理解生成器就是一个迭代器。\n\n在调用生成器运行的过程中，**每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行**。\n\n调用一个生成器函数，返回的是一个迭代器对象。\n\n以下实例使用 yield 实现斐波那契数列：\n\n```python\nimport sys\n \ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n \nwhile True:\n    try:\n        print (next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n```\n\n执行以上程序，输出结果如下：\n\n```python\n0 1 1 2 3 5 8 13 21 34 55\n```\n\n# 18. 函数\n\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。\n\n函数能提高**应用的模块性**，和**代码的重复利用率**。你已经知道Python提供了许多**内建函数**，比如print()。但你也可以自己创建函数，这被叫做**用户自定义函数**。\n\n## 18.1 定义一个函数\n\n你可以定义一个由自己想要功能的函数，以下是简单的规则：\n\n- 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。\n- 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n- 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。\n- 函数内容以冒号 `:` 起始，并且缩进。\n- **return [表达式]** 结束函数，选择性地返回一个值给调用方，**不带表达式的 return 相当于返回 None**。\n\n![](Python3/py-tup-10-26-1.png)\n\n### 语法\n\nPython 定义函数使用 def 关键字，一般格式如下：\n\n```python\ndef 函数名（参数列表）:\n    函数体\n```\n\n默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。\n\n## 18.2 函数调用\n\n定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。\n\n这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。\n\n## 18.3 参数传递\n\n在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：\n\n```python\na=[1,2,3]\n\na=\"Runoob\"\n```\n\n以上代码中，[1,2,3] 是 List 类型，\"Runoob\" 是 String 类型，而**变量 a 是没有类型，她仅仅是一个对象的引用（一个指针）**，可以是指向 List 类型对象，也可以是指向 String 类型对象。\n\n### 可更改(mutable)与不可更改(immutable)对象\n\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\n\n- **不可变类型**：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。\n\n- **可变类型**：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n\npython 函数的参数传递：\n\n- **不可变类型**：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。\n\n- **可变类型**：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响\n\n**python 中一切都是对象**，严格意义我们不能说值传递还是引用传递，我们应该说**传不可变对象**和**传可变对象**。\n\n### 传不可变对象实例\n\n通过 id() 函数来查看内存地址变化：\n\n```python\ndef change(a):\n    print(id(a))   # 指向的是同一个对象\n    a=10\n    print(id(a))   # 一个新对象\n \na=1\nprint(id(a))\nchange(a)\n```\n\n以上实例输出结果为：\n\n```python\n4379369136\n4379369136\n4379369424\n```\n\n可以看见在调用函数前后，**形参和实参指向的是同一个对象（对象 id 相同）**，在函数内部修改形参后，形参指向的是不同的 id。\n\n### 传可变对象实例\n可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：\n\n```python\n# 可写函数说明\ndef changeme( mylist ):\n   \"修改传入的列表\"\n   mylist.append([1,2,3,4])\n   print (\"函数内取值: \", mylist)\n   return\n \n# 调用changeme函数\nmylist = [10,20,30]\nchangeme( mylist )\nprint (\"函数外取值: \", mylist)\n```\n\n传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：\n\n```python\n函数内取值:  [10, 20, 30, [1, 2, 3, 4]]\n函数外取值:  [10, 20, 30, [1, 2, 3, 4]]\n```\n\n## 18.4 参数\n\n以下是调用函数时可使用的正式参数类型：\n\n- 必需参数\n- 关键字参数\n- 默认参数\n- 不定长参数\n\n### 必需参数\n\n必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的**一样**。\n\n### 关键字参数\n\n关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。\n\n使用关键字参数允许函数调用时参数的顺序与声明时**不一致**，因为 *Python 解释器能够用参数名匹配参数值*。\n\n以下实例中演示了函数参数的使用不需要使用指定顺序：\n\n```python\n#可写函数说明\ndef printinfo( name, age ):\n   \"打印任何传入的字符串\"\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n \n#调用printinfo函数\nprintinfo( age=50, name=\"runoob\" )\n```\n\n以上实例输出结果：\n\n```python\n名字:  runoob\n年龄:  50\n```\n\n### 默认参数\n\n调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：\n\n```python\n#可写函数说明\ndef printinfo( name, age = 35 ):\n   \"打印任何传入的字符串\"\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n \n#调用printinfo函数\nprintinfo( age=50, name=\"runoob\" )\nprint (\"------------------------\")\nprintinfo( name=\"runoob\" )\n```\n\n以上实例输出结果：\n\n```python\n名字:  runoob\n年龄:  50\n------------------------\n名字:  runoob\n年龄:  35\n```\n\n### 不定长参数\n\n你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：\n\n```python\ndef functionname([formal_args,] *var_args_tuple ):\n   \"函数_文档字符串\"\n   function_suite\n   return [expression]\n```\n\n1. 加了星号 * 的参数会以**元组(tuple)**的形式导入，存放所有未命名的变量参数。\n\n```python\n# 可写函数说明\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   print (vartuple)\n \n# 调用printinfo 函数\nprintinfo( 70, 60, 50 )\n```\n\n以上实例输出结果：\n\n```python\n输出: \n70\n(60, 50)\n```\n\n2. 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：\n\n```python\n# 可写函数说明\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   for var in vartuple:\n      print (var)\n   return\n \n# 调用printinfo 函数\nprintinfo( 10 )\nprintinfo( 70, 60, 50 )\n```\n\n以上实例输出结果：\n\n```python\n输出:\n10\n输出:\n70\n60\n50\n```\n\n3. 还有一种就是参数带两个星号 `**`基本语法如下：\n\n```python\ndef functionname([formal_args,] **var_args_dict ):\n   \"函数_文档字符串\"\n   function_suite\n   return [expression]\n```\n\n加了两个星号 `**` 的参数会以 **字典** 的形式导入。\n\n```python\n# 可写函数说明\ndef printinfo( arg1, **vardict ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   print (vardict)\n \n# 调用printinfo 函数\nprintinfo(1, a=2,b=3)\n```\n\n以上实例输出结果：\n\n```python\n输出: \n1\n{'a': 2, 'b': 3}\n```\n\n4. 声明函数时，参数中星号 * 可以单独出现，例如:\n\n```python\ndef f(a,b,*,c):\n    return a+b+c\n```\n\n如果单独出现星号 *，则星号 * 后的参数必须用关键字传入：\n\n```python\n>>> def f(a,b,*,c):\n...     return a+b+c\n... \n>>> f(1,2,3)   # 报错\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: f() takes 2 positional arguments but 3 were given\n>>> f(1,2,c=3) # 正常\n6\n>>>\n```\n\n## 18.5 匿名函数\n\nPython 使用 `lambda` 来创建匿名函数。\n\n所谓匿名，意即**不再使用 def 语句这样标准的形式定义一个函数**。\n\n- `lambda` 只是一个表达式，函数体比 **def** 简单很多。\n- `lambda` 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。\n- `lambda` 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n- 虽然 `lambda` 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n\n### 语法\nlambda 函数的语法只包含一个语句，如下：\n\n`lambda [arg1 [,arg2,.....argn]]:expression`\n\n1. 设置参数 a 加上 10:\n\n```python\nx = lambda a : a + 10\nprint(x(5))\n```\n\n以上实例输出结果：\n\n```python\n15\n```\n\n2. 以下实例匿名函数设置两个参数：\n\n```python \n# 可写函数说明\nsum = lambda arg1, arg2: arg1 + arg2\n \n# 调用sum函数\nprint (\"相加后的值为 : \", sum( 10, 20 ))\nprint (\"相加后的值为 : \", sum( 20, 20 ))\n```\n\n以上实例输出结果：\n\n```python\n相加后的值为 :  30\n相加后的值为 :  40\n```\n\n3. 可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。\n\n以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：\n\n```python\ndef myfunc(n):\n  return lambda a : a * n\n \nmydoubler = myfunc(2)\nmytripler = myfunc(3)\n \nprint(mydoubler(11))\nprint(mytripler(11))\n```\n\n以上实例输出结果：\n\n```python\n22\n33\n```\n\n## 18.6 return 语句\n\nreturn [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。\n\n## 18.7 强制位置参数\n\nPython3.8 新增了一个函数形参语法 `/` 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。\n\n在以下的例子中，**形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参**:\n\n```python\ndef f(a, b, /, c, d, *, e, f):\n    print(a, b, c, d, e, f)\n```\n\n- 以下使用方法是正确的:\n\n```python\nf(10, 20, 30, d=40, e=50, f=60)\n```\n\n- 以下使用方法会发生错误:\n\n```python\nf(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式\nf(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式\n```\n\n# 19. 数据结构\n\n## 19.1 列表\n\nPython中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。\n\n|方法|描述|\n|-|-|\n|list.append(x)|把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。|\n|list.extend(L)|通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。|\n|list.insert(i, x)|在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。|\n|list.remove(x)|删除列表中值为 x 的**第一个元素**。如果没有这样的元素，就会返回一个错误。|\n|list.pop([i])|从列表的指定位置移除元素，**并将其返回**。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的**方括号**表示这个**参数是可选**的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）|\n|list.clear()|移除列表中的所有项，等于del a[:]。|\n|list.index(x)|返回列表中**第一个值为 x 的元素的索引**。如果没有匹配的元素就会返回一个错误。|\n|list.count(x)|返回 x 在列表中出现的次数。|\n|list.sort()|对列表中的元素进行排序。|\n|list.reverse()|倒排列表中的元素。|\n|list.copy()|返回列表的浅复制，等于a[:]。|\n\n> 注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。\n\n## 19.2 将列表当做堆栈使用\n\n列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 `append()` 方法可以把一个元素添加到堆栈顶。用不指定索引的 `pop()` 方法可以把一个元素从堆栈顶释放出来。\n\n## 19.3 将列表当作队列使用\n\n也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。\n\n## 19.4 列表推导式\n\n列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。\n\n每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。\n\n一些关于循环和其它技巧的演示：\n\n```python\n>>> vec1 = [2, 4, 6]\n>>> vec2 = [4, 3, -9]\n>>> [x*y for x in vec1 for y in vec2]\n[8, 6, -18, 16, 12, -36, 24, 18, -54]\n>>> [x+y for x in vec1 for y in vec2]\n[6, 5, -7, 8, 7, -5, 10, 9, -3]\n>>> [vec1[i]*vec2[i] for i in range(len(vec1))]\n[8, 12, -54]\n```\n\n列表推导式可以使用复杂表达式或嵌套函数：\n\n```python\n>>> [str(round(355/113, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n```\n\n> round() 方法返回浮点数x的四舍五入值。\n> 语法： `round( x [, n]  )`\n> 参数：x -- 数值表达式。n -- 数值表达式，表示从小数点位数。\n> 返回值：返回浮点数x的四舍五入值。\n\n## 19.5 嵌套列表解析\n\nPython的列表还可以嵌套。\n\n以下实例展示了3X4的矩阵列表：\n\n```python\n>>> matrix = [\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12],\n... ]\n```\n\n以下实例将3X4的矩阵列表转换为4X3列表：\n\n```python\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n\n也可以使用以下方法来实现：\n\n```python\n>>> transposed = []\n>>> for i in range(4):\n...     transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n\n另外一种实现方法：\n\n```python\n>>> transposed = []\n>>> for i in range(4):\n...     # the following 3 lines implement the nested listcomp\n...     transposed_row = []\n...     for row in matrix:\n...         transposed_row.append(row[i])\n...     transposed.append(transposed_row)\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n```\n\n## 19.6 del 语句\n使用 del 语句可以从一个列表中根据**索引**来删除一个元素，而不是值来删除元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：\n\n```python\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\n```\n\n也可以用 del 删除实体变量：\n\n```python\n>>> del a\n```\n\n## 19.7 元组和序列\n\n元组由若干逗号分隔的值组成，例如：\n\n```python\n>>> t = 12345, 54321, 'hello!'\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')\n>>> # Tuples may be nested:\n... u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n```\n\n如上所示，元组在输出时总是有括号的，以便于正确表达嵌套结构。**在输入时可能有或没有括号**， *不过括号通常是必须的（如果元组是更大的表达式的一部分）*。\n\n## 19.8 集合\n\n集合是一个**无序不重复元素的集**。基本功能包括**关系测试**和**消除重复元素**。\n\n可以用大括号(`{}`)创建集合。注意：如果要创建一个空集合，你必须用 `set()` 而不是 `{}` ；后者创建一个空的字典。\n\n集合也支持推导式。\n\n## 19.9 字典\n\n另一个非常有用的 Python 内建数据类型是字典。\n\n序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。\n\n理解字典的最佳方式是把它看做无序的键=>值对集合。在同一个字典之内，关键字必须是互不相同。\n\n一对大括号创建一个空的字典：`{}`。\n\n1. 构造函数 `dict()` 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：\n\n```python\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n```\n\n2. 此外，字典推导可以用来创建任意键和值的表达式词典：\n\n```python\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n```\n\n3. 如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：\n\n```python\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n```\n\n## 19.10 遍历技巧\n\n1. 在字典中遍历时，关键字和对应的值可以使用 `items()` 方法同时解读出来：\n\n```python\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\n```\n\n2. 在序列中遍历时，索引位置和对应值可以使用 `enumerate()` 函数同时得到：\n\n```python\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\n```\n\n3. 同时遍历两个或更多的序列，可以使用 `zip()` 组合：\n\n```python\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\n```\n\n> zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后**返回由这些元组组成的对象**，这样做的好处是*节约了不少的内存*。\n> 我们可以使用 list() 转换来输出列表。\n> 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。\n\n> Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。\n> 基本语法是通过 {} 和 : 来代替以前的 % 。\n> format 函数可以接受不限个参数，位置可以不按顺序。\n\n4. 要反向遍历一个序列，首先指定这个序列，然后调用 `reversed()` 函数：\n\n```python\n>>> for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\n```\n\n5. 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：\n\n```python\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\n```\n\n> set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。\n> 语法：`class set([iterable])`\n> 参数说明：iterable -- 可迭代对象对象；\n> 返回值：返回新的集合对象\n\n\n# 20. 模块\n\n如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。\n\n为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。\n\n模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。\n\n下面是一个使用 python 标准库中模块的例子：\n\n```python\n# 文件名: using_sys.py\n \nimport sys\n \nprint('命令行参数如下:')\nfor i in sys.argv:\n   print(i)\n \nprint('\\n\\nPython 路径为：', sys.path, '\\n')\n```\n\n执行结果如下所示：\n\n```python\n$ python using_sys.py 参数1 参数2\n命令行参数如下:\nusing_sys.py\n参数1\n参数2\n\n\nPython 路径为： ['/root', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages'] \n```\n\n- 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。\n- 2、sys.argv 是一个包含命令行参数的列表。\n- 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。\n\n## 20.1 import 语句\n\n想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：\n\n`import module1[, module2[,... moduleN]`\n\n当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。\n\n搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：\n\n- support.py 文件代码\n```python\n# Filename: support.py\n \ndef print_func( par ):\n    print (\"Hello : \", par)\n    return\ntest.py 引入 support 模块：\n```\n\n- test.py 文件代码\n\n```python\n# Filename: test.py\n \n# 导入模块\nimport support\n \n# 现在可以调用模块里包含的函数了\nsupport.print_func(\"Runoob\")\n```\n\n以上实例输出结果：\n\n```python\n$ python3 test.py \nHello :  Runoob\n```\n\n一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。\n\n当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？\n\n这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。\n\n这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。\n\n搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：\n\n```python\n>>> import sys\n>>> sys.path\n['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']\n>>> \n```\n\n`sys.path` 输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。\n\n因此若在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。\n\n了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。\n\n现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：\n\n```python\n# 斐波那契(fibonacci)数列模块\n \ndef fib(n):    # 定义到 n 的斐波那契数列\n    a, b = 0, 1\n    while b < n:\n        print(b, end=' ')\n        a, b = b, a+b\n    print()\n \ndef fib2(n): # 返回到 n 的斐波那契数列\n    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a+b\n    return result\n```\n\n然后进入Python解释器，使用下面的命令导入这个模块：\n\n```python\n>>> import fibo\n```\n\n**这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。**\n\n可以使用模块名称来访问函数：\n\n```python\n>>>fibo.fib(1000)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\n```\n\n如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：\n\n```python\n>>> fib = fibo.fib\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```\n\n## 20.2 from … import 语句\nPython 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：\n\n`from modname import name1[, name2[, ... nameN]]`\n\n例如，要导入模块 fibo 的 fib 函数，使用如下语句：\n\n```python\n>>> from fibo import fib, fib2\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n```\n\n**这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。**\n\n## 20.3 from … import * 语句\n\n把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：\n\n`from modname import *`\n\n这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。\n\n## 20.4 深入模块\n\n模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。\n\n每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。\n\n所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。\n\n从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。\n\n模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。\n\n## 20.5 __name__属性\n\n一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 `__name__` 属性来使该程序块仅在该模块自身运行时执行。\n\n```python\n# Filename: using_name.py\n\nif __name__ == '__main__':\n   print('程序自身在运行')\nelse:\n   print('我来自另一模块')\n```\n\n运行输出如下：\n\n```python\n$ python using_name.py\n```\n\n程序自身在运行\n\n```python\n$ python\n>>> import using_name\n我来自另一模块\n>>>\n```\n\n> 说明：1.  每个模块都有一个 `__name__` 属性，当其值是 `'__main__'` 时，表明该模块自身在运行，否则是被引入。\n> 2. `__name__` 与 `__main__` 底下是双下划线， `_ _` 是这样去掉中间的那个空格。\n\n## 20.6 dir() 函数\n\n内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:\n\n```python\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)  \n['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',\n '__package__', '__stderr__', '__stdin__', '__stdout__',\n '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',\n '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',\n 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',\n 'call_tracing', 'callstats', 'copyright', 'displayhook',\n 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',\n 'executable', 'exit', 'flags', 'float_info', 'float_repr_style',\n 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',\n 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',\n 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',\n 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',\n 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',\n 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',\n 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',\n 'thread_info', 'version', 'version_info', 'warnoptions']\n```\n\n## 20.7 标准模块\n\nPython 本身带着一些标准的模块库。\n\n有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。\n\n这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。\n\n应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串。\n\n## 20.8 包\n\n包是一种管理 Python 模块命名空间的形式，采用\"点模块名称\"。\n\n比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。\n\n就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。\n\n这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。\n\n不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个\"包\"）。\n\n现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。\n\n并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。\n\n[关于包的详解](https://www.runoob.com/python3/python3-module.html)\n\n# 21. 输入和输出\n\n## 21.1 输出格式美化\n\nPython两种输出值的方式: 表达式语句和 print() 函数。\n\n第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。\n\n如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。\n\n如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。\n\n- `str()`： 函数返回一个用户易读的表达形式。\n- `repr()`： 产生一个解释器易读的表达形式。\n\n> 1. `repr()` 函数可以转义字符串中的特殊字符\n> 2. `repr()` 的参数可以是 Python 的任何对象\n\n[其他关于输出格式美化内容](https://www.runoob.com/python3/python3-inputoutput.html)\n\n## 21.2 旧式字符串格式化\n\n`%` 操作符也可以实现字符串格式化。 它将左边的参数作为类似 `sprintf()` 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:\n\n```python\n>>> import math\n>>> print('常量 PI 的值近似为：%5.3f。' % math.pi)\n常量 PI 的值近似为：3.142。\n```\n\n因为 `str.format()` 是比较新的函数， 大多数的 Python 代码仍然使用 `%` 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 `str.format()`。\n\n## 21.3 读取键盘输入\n\nPython 提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。\n\n```python\nstr = input(\"请输入：\");\nprint (\"你输入的内容是: \", str)\n```\n\n这会产生如下的对应着输入的结果：\n\n```python\n请输入：菜鸟教程\n你输入的内容是:  菜鸟教程\n```\n\n## 21.4 读和写文件\n\n`open()` 将会返回一个 file 对象，基本语法格式如下:\n\n`open(filename, mode)`\n\n- filename：包含了你要访问的文件名称的字符串值。\n- mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，**默认文件访问模式为只读(r)**。\n\n不同模式打开文件的完全列表：\n\n|模式|描述|\n|-|-|\n|r|以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。|\n|rb|以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。|\n|r+|打开一个文件用于读写。文件指针将会放在文件的开头。|\n|rb+|以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。|\n|w|打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|\n|wb|以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|\n|w+|打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|\n|wb+|以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|\n|a|打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|\n|ab|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|\n|a+|打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。|\n|ab+|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。|\n\n下图很好的总结了这几种模式：\n\n![](Python3/2112205-861c05b2bdbc9c28.png)\n\n|    模式    |  r   |  r+  |  w   |  w+  |  a   |  a+  |\n| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|     读     |  +   |  +   |      |  +   |      |  +   |\n|     写     |      |  +   |  +   |  +   |  +   |  +   |\n|    创建    |      |      |  +   |  +   |  +   |  +   |\n|    覆盖    |      |      |  +   |  +   |      |      |\n| 指针在开始 |  +   |  +   |  +   |  +   |      |      |\n| 指针在结尾 |      |      |      |      |  +   |  +   |\n\n## 21.5 文件对象的方法\n\n1. `f.read()`\n\t- 为了读取一个文件的内容，调用 `f.read(size)`, 这将读取一定数目的数据, 然后作为**字符串**或**字节对象**返回。\n\t- `size` 是一个*可选*的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。\n\n2. `f.readline()`\n\t- `f.readline()` 会从文件中读取单独的一行。换行符为 '\\n'。`f.readline()` 如果返回一个空字符串, 说明已经已经读取到最后一行。\n\n3. `f.readlines()`\n\t- `f.readlines()` 将返回该文件中包含的所有行。\n\t- 如果设置可选参数 `sizehint`, 则读取指定长度的字节, 并且将这些字节按行分割。\n\n4. `f.write()`\n\t- `f.write(string)` 将 `string` 写入到文件中, 然后返回写入的字符数。\n\n5. `f.tell()`\n\t- `f.tell()` 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。\n\n6. `f.seek()`\n\t- 如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。\n\t- from_what 的值, 如果是 0（默认值） 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：\n\t\t- `seek(x,0)` ： 从起始位置即文件首行首字符开始移动 x 个字符\n\t\t- `seek(x,1)` ： 表示从当前位置往后移动x个字符\n\t\t- `seek(-x,2)`：表示从文件的结尾往前移动x个字符\n\n7. `f.close()`\n\t- 在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。\n\t- 当你处理完一个文件后, 调用 `f.close()` 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。\n\t- 当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:\n```python\n>>> with open('/tmp/foo.txt', 'r') as f:\n...     read_data = f.read()\n>>> f.closed\nTrue\n```\n\n## 21.6 pickle 模块\n\npython的pickle模块实现了基本的数据**序列**和**反序列化**。\n\n通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。\n\n通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。\n\n基本接口：\n\n`pickle.dump(obj, file, [,protocol])`\n\n有了 pickle 这个对象, 就能对 file 以读取的形式打开:\n\n`x = pickle.load(file)`\n\n注解：从 file 中读取一个字符串，并将它重构为原来的python对象。\n\nfile: 类文件对象，有read()和readline()接口。\n\n# 22. File(文件) 方法\n\n## 22.1 open() 方法\n\nPython `open()` 方法用于打开一个文件，并返回文件对象。\n\n在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。\n\n注意：使用 `open()` 方法一定要保证关闭文件对象，即调用 `close()` 方法。\n\n`open()` 函数常用形式是接收两个参数：文件名(file)和模式(mode)。\n\n`open(file, mode='r')`\n\n完整的语法格式为：\n\n`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`\n\n参数说明:\n\n- file: 必需，文件路径（相对或者绝对路径）。\n- mode: 可选，文件打开模式\n- buffering: 设置缓冲\n- encoding: 一般使用utf8\n- errors: 报错级别\n- newline: 区分换行符\n- closefd: 传入的file参数类型\n- opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。\n\nmode 参数有：\n\n| 模式 | 描述                                             |\n| :--- | :----------------------------------------------- |\n| t    | 文本模式 (默认)。                                |\n| x    | 写模式，新建一个文件，如果该文件已存在则会报错。 |\n| b    | 二进制模式。                                     |\n| +    | 打开一个文件进行更新(可读可写)。                 |\n| U    | 通用换行模式（**Python 3 不支持**）。            |\n\n> mode 其他参数详见 **21.4 读和写文件**。\n> 默认为文本模式，如果要以二进制模式打开，加上 b 。\n\n## 22.2 file 对象\n\nfile 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：\n\n| 序号 | 方法及描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [file.close()](https://www.runoob.com/python3/python3-file-close.html)关闭文件。关闭后文件不能再进行读写操作。 |\n| 2    | [file.flush()](https://www.runoob.com/python3/python3-file-flush.html)刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 |\n| 3    | [file.fileno()](https://www.runoob.com/python3/python3-file-fileno.html)返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 |\n| 4    | [file.isatty()](https://www.runoob.com/python3/python3-file-isatty.html)如果文件连接到一个终端设备返回 True，否则返回 False。 |\n| 5    | [file.next()](https://www.runoob.com/python3/python3-file-next.html)**Python 3 中的 File 对象不支持 next() 方法。**返回文件下一行。 |\n| 6    | [file.read([size\\])](https://www.runoob.com/python3/python3-file-read.html)从文件读取指定的字节数，如果未给定或为负则读取所有。 |\n| 7    | [file.readline([size\\])](https://www.runoob.com/python3/python3-file-readline.html)读取整行，包括 \"\\n\" 字符。 |\n| 8    | [file.readlines([sizeint\\])](https://www.runoob.com/python3/python3-file-readlines.html)读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 |\n| 9    | [file.seek(offset[, whence\\])](https://www.runoob.com/python3/python3-file-seek.html)移动文件读取指针到指定位置 |\n| 10   | [file.tell()](https://www.runoob.com/python3/python3-file-tell.html)返回文件当前位置。 |\n| 11   | [file.truncate([size\\])](https://www.runoob.com/python3/python3-file-truncate.html)从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 |\n| 12   | [file.write(str)](https://www.runoob.com/python3/python3-file-write.html)将字符串写入文件，返回的是写入的字符长度。 |\n| 13   | [file.writelines(sequence)](https://www.runoob.com/python3/python3-file-writelines.html)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |\n\n# 23. OS 文件/目录方法\n\nos 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：\n\n| 序号 | 方法及描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [os.access(path, mode)](https://www.runoob.com/python3/python3-os-access.html) 检验权限模式 |\n| 2    | [os.chdir(path)](https://www.runoob.com/python3/python3-os-chdir.html) 改变当前工作目录 |\n| 3    | [os.chflags(path, flags)](https://www.runoob.com/python3/python3-os-chflags.html) 设置路径的标记为数字标记。 |\n| 4    | [os.chmod(path, mode)](https://www.runoob.com/python3/python3-os-chmod.html) 更改权限 |\n| 5    | [os.chown(path, uid, gid)](https://www.runoob.com/python3/python3-os-chown.html) 更改文件所有者 |\n| 6    | [os.chroot(path)](https://www.runoob.com/python3/python3-os-chroot.html) 改变当前进程的根目录 |\n| 7    | [os.close(fd)](https://www.runoob.com/python3/python3-os-close.html) 关闭文件描述符 fd |\n| 8    | [os.closerange(fd_low, fd_high)](https://www.runoob.com/python3/python3-os-closerange.html) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 |\n| 9    | [os.dup(fd)](https://www.runoob.com/python3/python3-os-dup.html) 复制文件描述符 fd |\n| 10   | [os.dup2(fd, fd2)](https://www.runoob.com/python3/python3-os-dup2.html) 将一个文件描述符 fd 复制到另一个 fd2 |\n| 11   | [os.fchdir(fd)](https://www.runoob.com/python3/python3-os-fchdir.html) 通过文件描述符改变当前工作目录 |\n| 12   | [os.fchmod(fd, mode)](https://www.runoob.com/python3/python3-os-fchmod.html) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 |\n| 13   | [os.fchown(fd, uid, gid)](https://www.runoob.com/python3/python3-os-fchown.html) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 |\n| 14   | [os.fdatasync(fd)](https://www.runoob.com/python3/python3-os-fdatasync.html) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 |\n| 15   | [os.fdopen(fd[, mode[, bufsize\\]])](https://www.runoob.com/python3/python3-os-fdopen.html) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 |\n| 16   | [os.fpathconf(fd, name)](https://www.runoob.com/python3/python3-os-fpathconf.html) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 |\n| 17   | [os.fstat(fd)](https://www.runoob.com/python3/python3-os-fstat.html) 返回文件描述符fd的状态，像stat()。 |\n| 18   | [os.fstatvfs(fd)](https://www.runoob.com/python3/python3-os-fstatvfs.html) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 |\n| 19   | [os.fsync(fd)](https://www.runoob.com/python3/python3-os-fsync.html) 强制将文件描述符为fd的文件写入硬盘。 |\n| 20   | [os.ftruncate(fd, length)](https://www.runoob.com/python3/python3-os-ftruncate.html) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 |\n| 21   | [os.getcwd()](https://www.runoob.com/python3/python3-os-getcwd.html) 返回当前工作目录 |\n| 22   | [os.getcwdb()](https://www.runoob.com/python3/python3-os-getcwdb.html) 返回一个当前工作目录的Unicode对象 |\n| 23   | [os.isatty(fd)](https://www.runoob.com/python3/python3-os-isatty.html) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 |\n| 24   | [os.lchflags(path, flags)](https://www.runoob.com/python3/python3-os-lchflags.html) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 |\n| 25   | [os.lchmod(path, mode)](https://www.runoob.com/python3/python3-os-lchmod.html) 修改连接文件权限 |\n| 26   | [os.lchown(path, uid, gid)](https://www.runoob.com/python3/python3-os-lchown.html) 更改文件所有者，类似 chown，但是不追踪链接。 |\n| 27   | [os.link(src, dst)](https://www.runoob.com/python3/python3-os-link.html) 创建硬链接，名为参数 dst，指向参数 src |\n| 28   | [os.listdir(path)](https://www.runoob.com/python3/python3-os-listdir.html) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 |\n| 29   | [os.lseek(fd, pos, how)](https://www.runoob.com/python3/python3-os-lseek.html) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 |\n| 30   | [os.lstat(path)](https://www.runoob.com/python3/python3-os-lstat.html) 像stat(),但是没有软链接 |\n| 31   | [os.major(device)](https://www.runoob.com/python3/python3-os-major.html) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 |\n| 32   | [os.makedev(major, minor)](https://www.runoob.com/python3/python3-os-makedev.html) 以major和minor设备号组成一个原始设备号 |\n| 33   | [os.makedirs(path[, mode\\])](https://www.runoob.com/python3/python3-os-makedirs.html) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 |\n| 34   | [os.minor(device)](https://www.runoob.com/python3/python3-os-minor.html) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 |\n| 35   | [os.mkdir(path[, mode\\])](https://www.runoob.com/python3/python3-os-mkdir.html) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 |\n| 36   | [os.mkfifo(path[, mode\\])](https://www.runoob.com/python3/python3-os-mkfifo.html) 创建命名管道，mode 为数字，默认为 0666 (八进制) |\n| 37   | [os.mknod(filename[, mode=0600, device\\])](https://www.runoob.com/python3/python3-os-mknod.html) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 |\n| 38   | [os.open(file, flags[, mode\\])](https://www.runoob.com/python3/python3-os-open.html) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 |\n| 39   | [os.openpty()](https://www.runoob.com/python3/python3-os-openpty.html) 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 |\n| 40   | [os.pathconf(path, name)](https://www.runoob.com/python3/python3-os-pathconf.html) 返回相关文件的系统配置信息。 |\n| 41   | [os.pipe()](https://www.runoob.com/python3/python3-os-pipe.html) 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 |\n| 42   | [os.popen(command[, mode[, bufsize\\]])](https://www.runoob.com/python3/python3-os-popen.html) 从一个 command 打开一个管道 |\n| 43   | [os.read(fd, n)](https://www.runoob.com/python3/python3-os-read.html) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 |\n| 44   | [os.readlink(path)](https://www.runoob.com/python3/python3-os-readlink.html) 返回软链接所指向的文件 |\n| 45   | [os.remove(path)](https://www.runoob.com/python3/python3-os-remove.html) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 |\n| 46   | [os.removedirs(path)](https://www.runoob.com/python3/python3-os-removedirs.html) 递归删除目录。 |\n| 47   | [os.rename(src, dst)](https://www.runoob.com/python3/python3-os-rename.html) 重命名文件或目录，从 src 到 dst |\n| 48   | [os.renames(old, new)](https://www.runoob.com/python3/python3-os-renames.html) 递归地对目录进行更名，也可以对文件进行更名。 |\n| 49   | [os.rmdir(path)](https://www.runoob.com/python3/python3-os-rmdir.html) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 |\n| 50   | [os.stat(path)](https://www.runoob.com/python3/python3-os-stat.html) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 |\n| 51   | [os.stat_float_times([newvalue\\])](https://www.runoob.com/python3/python3-os-stat_float_times.html) 决定stat_result是否以float对象显示时间戳 |\n| 52   | [os.statvfs(path)](https://www.runoob.com/python3/python3-os-statvfs.html) 获取指定路径的文件系统统计信息 |\n| 53   | [os.symlink(src, dst)](https://www.runoob.com/python3/python3-os-symlink.html) 创建一个软链接 |\n| 54   | [os.tcgetpgrp(fd)](https://www.runoob.com/python3/python3-os-tcgetpgrp.html) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 |\n| 55   | [os.tcsetpgrp(fd, pg)](https://www.runoob.com/python3/python3-os-tcsetpgrp.html) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 |\n| 56   | os.tempnam([dir[, prefix]]) **Python3 中已删除。**返回唯一的路径名用于创建临时文件。 |\n| 57   | os.tmpfile() **Python3 中已删除。**返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 |\n| 58   | os.tmpnam() **Python3 中已删除。**为创建一个临时文件返回一个唯一的路径 |\n| 59   | [os.ttyname(fd)](https://www.runoob.com/python3/python3-os-ttyname.html) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 |\n| 60   | [os.unlink(path)](https://www.runoob.com/python3/python3-os-unlink.html) 删除文件路径 |\n| 61   | [os.utime(path, times)](https://www.runoob.com/python3/python3-os-utime.html) 返回指定的path文件的访问和修改的时间。 |\n| 62   | [os.walk(top[, topdown=True[, onerror=None[, followlinks=False\\]]])](https://www.runoob.com/python3/python3-os-walk.html) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 |\n| 63   | [os.write(fd, str)](https://www.runoob.com/python3/python3-os-write.html) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 |\n| 64   | [os.path 模块](https://www.runoob.com/python3/python3-os-path.html) 获取文件的属性信息。 |\n| 65   | [os.pardir()](https://www.runoob.com/python3/python3-os-pardir.html) 获取当前目录的父目录，以字符串形式显示目录名。 |\n\n# 24. 错误和异常\n\nPython 有两种错误很容易辨认：语法错误和异常。\n\nPython assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。\n\n![](Python3/assets-py.webp)\n\n## 24.1 语法错误\n\nPython 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例：\n\n```python\n>>> while True print('Hello world')\n  File \"<stdin>\", line 1, in ?\n    while True print('Hello world')\n                   ^\nSyntaxError: invalid syntax\n```\n\n这个例子中，函数 `print()` 被检查到有错误，是它前面缺少了一个冒号 : 。\n\n语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。\n\n## 24.2 异常\n\n即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。\n\n大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:\n\n```python\n>>> 10 * (1/0)             # 0 不能作为除数，触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nZeroDivisionError: division by zero\n>>> 4 + spam*3             # spam 未定义，触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nNameError: name 'spam' is not defined\n>>> '2' + 2               # int 不能与 str 相加，触发异常\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate str (not \"int\") to str\n```\n\n异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。\n\n错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。\n\n## 24.3 异常处理\n\n### try/except\n\n异常捕捉可以使用 `try/except` 语句。\n\n![](Python3/try_except.png)\n\n以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。\n\n```python\nwhile True:\n    try:\n        x = int(input(\"请输入一个数字: \"))\n        break\n    except ValueError:\n        print(\"您输入的不是数字，请再次尝试输入！\")\n```\n\ntry 语句按照如下方式工作；\n\n- 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。\n- 如果没有异常发生，忽略 except 子句，try 子句执行后结束。\n- 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。\n- 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。\n\n一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。\n\n处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。\n\n一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:\n\n```python\nexcept (RuntimeError, TypeError, NameError):\n    pass\n```\n最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。\n\n```python\nimport sys\n\ntry:\n    f = open('myfile.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept OSError as err:\n    print(\"OS error: {0}\".format(err))\nexcept ValueError:\n    print(\"Could not convert data to an integer.\")\nexcept:\n    print(\"Unexpected error:\", sys.exc_info()[0])\n    raise\n```\n\n### try/except...else\n\n`try/except` 语句还有一个可选的 **else** 子句，如果使用这个子句，那么必须放在所有的 **except** 子句之后。\n\n**else 子句将在 try 子句没有发生任何异常的时候执行。**\n\n![](Python3/try_except_else.png)\n\n使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。\n\n异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:\n\n```python\n>>> def this_fails():\n        x = 1/0\n   \n>>> try:\n        this_fails()\n    except ZeroDivisionError as err:\n        print('Handling run-time error:', err)\n   \nHandling run-time error: int division or modulo by zero\n```\n\n### try-finally \n\n`try-finally` 语句无论是否发生异常都将执行最后的代码。\n\n![](Python3/try_except_else_finally.png)\n\n## 24.4 抛出异常\n\nPython 使用 raise 语句抛出一个指定的异常。\n\nraise语法格式如下：\n\n`raise [Exception [, args [, traceback]]]`\n\n![](Python3/raise.png)\n\n以下实例如果 x 大于 5 就触发异常:\n\n```python\nx = 10\nif x > 5:\n    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))\n```\n\n执行以上代码会触发异常：\n\n```python\nTraceback (most recent call last):\n  File \"test.py\", line 3, in <module>\n    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))\nException: x 不能大于 5。x 的值为: 10\n```\n\nraise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。\n\n如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。\n\n```python\n>>> try:\n        raise NameError('HiThere')\n    except NameError:\n        print('An exception flew by!')\n        raise\n   \nAn exception flew by!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in ?\nNameError: HiThere\n```\n\n## 24.6 用户自定义异常\n\n可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:\n\n```python\n>>> class MyError(Exception):\n        def __init__(self, value):\n            self.value = value\n        def __str__(self):\n            return repr(self.value)\n   \n>>> try:\n        raise MyError(2*2)\n    except MyError as e:\n        print('My exception occurred, value:', e.value)\n   \nMy exception occurred, value: 4\n>>> raise MyError('oops!')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\n__main__.MyError: 'oops!'\n```\n\n在这个例子中，类 Exception 默认的 __init__() 被覆盖。\n\n当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:\n\n```python\nclass Error(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    pass\n\nclass InputError(Error):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        expression -- input expression in which the error occurred\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, expression, message):\n        self.expression = expression\n        self.message = message\n\nclass TransitionError(Error):\n    \"\"\"Raised when an operation attempts a state transition that's not\n    allowed.\n\n    Attributes:\n        previous -- state at beginning of transition\n        next -- attempted new state\n        message -- explanation of why the specific transition is not allowed\n    \"\"\"\n\n    def __init__(self, previous, next, message):\n        self.previous = previous\n        self.next = next\n        self.message = message\n```\n\n大多数的异常的名字都以\"Error\"结尾，就跟标准的异常命名一样。\n\n## 24.7 定义清理行为\n\ntry 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:\n\n```python\n>>> try:\n...     raise KeyboardInterrupt\n... finally:\n...     print('Goodbye, world!')\n...\nGoodbye, world!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nKeyboardInterrupt\n```\n\n以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。\n\n**如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。\n**\n\n下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:\n\n```python\n>>> def divide(x, y):\n        try:\n            result = x / y\n        except ZeroDivisionError:\n            print(\"division by zero!\")\n        else:\n            print(\"result is\", result)\n        finally:\n            print(\"executing finally clause\")\n   \n>>> divide(2, 1)\nresult is 2.0\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\n  File \"<stdin>\", line 3, in divide\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n```\n\n## 24.8 预定义的清理行为\n\n一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。\n\n这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:\n\n```python\nfor line in open(\"myfile.txt\"):\n    print(line, end=\"\")\n```\n\n以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。\n\n关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:\n\n```python\nwith open(\"myfile.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n```\n以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。\n\n更多 with 关键字内容参考：[Python with 关键字](https://www.runoob.com/python3/python-with.html)\n\n> with 语句实现原理建立在上下文管理器之上。\n> 上下文管理器是一个实现 __enter__ 和 __exit__ 方法的类。\n> 使用 with 语句确保在嵌套块的末尾调用 __exit__ 方法。\n> 这个概念类似于 try...finally 块的使用。\n\n# 25. 面向对象\n\nPython从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。\n\n## 25.1 面向对象技术简介\n\n- **类(Class):** 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n- **方法：**类中定义的函数。\n- **类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n- **数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。\n- **方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n- **局部变量：**定义在方法中的变量，只作用于当前实例的类。\n- **实例变量：**在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。\n- **继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。\n- **实例化：**创建一个类的实例，类的具体对象。\n- **对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n\n和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。\n\nPython中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。\n\n对象可以包含任意数量和类型的数据。\n\n## 25.2 类定义\n语法格式如下：\n\n```python\nclass ClassName:\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。\n\n## 25.3 类对象\n类对象支持两种操作：属性引用和实例化。\n\n属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。\n\n类对象创建后，类命名空间中所有的命名都是有效属性名。\n\n类有一个名为 `__init__()` 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：\n\n```python\ndef __init__(self):\n    self.data = []\n```\n\n类定义了 `__init__()` 方法，类的实例化操作会自动调用 `__init__()` 方法。如下实例化类 MyClass，对应的 `__init__()` 方法就会被调用:\n\n```python\nx = MyClass()\n```\n\n当然， `__init__()` 方法可以有参数，参数通过 `__init__()` 传递到类的实例化操作上。例如:\n\n```python\nclass Complex:\n    def __init__(self, realpart, imagpart):\n        self.r = realpart\n        self.i = imagpart\nx = Complex(3.0, -4.5)\nprint(x.r, x.i)   # 输出结果：3.0 -4.5\n```\n\n### self代表类的实例，而非类\n类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的**第一个参数名称**, 按照惯例它的名称是 self。\n\n```python\nclass Test:\n    def prt(self):\n        print(self)\n        print(self.__class__)\n \nt = Test()\nt.prt()\n```\n\n以上实例执行结果为：\n\n```python\n<__main__.Test instance at 0x100771878>\n__main__.Test\n```\n\n从执行结果可以很明显的看出，**self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类**。\n\n**self 不是 python 关键字**，我们把他换成 runoob 也是可以正常执行的:\n\n```python\nclass Test:\n    def prt(runoob):\n        print(runoob)\n        print(runoob.__class__)\n \nt = Test()\nt.prt()\n```\n\n以上实例执行结果为：\n\n```python\n<__main__.Test instance at 0x100771878>\n__main__.Test\n```\n\n## 25.4 类的方法\n\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，**类方法必须包含参数 self**, 且为第一个参数，self 代表的是类的实例。\n\n```python\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n# 实例化类\np = people('runoob',10,30)\np.speak()\n```\n\n执行以上程序输出结果为：\n\n```python\nrunoob 说: 我 10 岁。\n```\n\n## 25.5 继承\n\nPython 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:\n\n```python\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。\n\nBaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:\n\n`class DerivedClassName(modname.BaseClassName):`\n\n```python\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n#单继承示例\nclass student(people):\n    grade = ''\n    def __init__(self,n,a,w,g):\n        #调用父类的构函\n        people.__init__(self,n,a,w)\n        self.grade = g\n    #覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))\n \n \n \ns = student('ken',10,60,3)\ns.speak()\n```\n\n执行以上程序输出结果为：\n\n```python\nken 说: 我 10 岁了，我在读 3 年级\n```\n\n## 25.6 多继承\n\nPython同样有限的支持多继承形式。多继承的类定义形如下例:\n\n```python\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n**需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。**\n\n```python\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n#单继承示例\nclass student(people):\n    grade = ''\n    def __init__(self,n,a,w,g):\n        #调用父类的构函\n        people.__init__(self,n,a,w)\n        self.grade = g\n    #覆写父类的方法\n    def speak(self):\n        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))\n \n#另一个类，多重继承之前的准备\nclass speaker():\n    topic = ''\n    name = ''\n    def __init__(self,n,t):\n        self.name = n\n        self.topic = t\n    def speak(self):\n        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic))\n \n#多重继承\nclass sample(speaker,student):\n    a =''\n    def __init__(self,n,a,w,g,t):\n        student.__init__(self,n,a,w,g)\n        speaker.__init__(self,n,t)\n \ntest = sample(\"Tim\",25,80,4,\"Python\")\ntest.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法\n```\n\n执行以上程序输出结果为：\n\n```python\n我叫 Tim，我是一个演说家，我演讲的主题是 Python\n```\n\n## 25.7 方法重写\n\n如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：\n\n```python \nclass Parent:        # 定义父类\n   def myMethod(self):\n      print ('调用父类方法')\n \nclass Child(Parent): # 定义子类\n   def myMethod(self):\n      print ('调用子类方法')\n \nc = Child()          # 子类实例\nc.myMethod()         # 子类调用重写方法\nsuper(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法\n```\n\n执行以上程序输出结果为：\n\n```python\n调用子类方法\n调用父类方法\n```\n\n> super() 函数是用于调用父类(超类)的一个方法。\n> super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。\n> MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。\n> 语法：`super(type[, object-or-type])`\n> 参数：type -- 类。object-or-type -- 类，一般是 self\n> 返回值：无。\n\n## 25.8 类属性与方法\n\n### 类的私有属性\n`__private_attrs`：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 `self.__private_attrs`。\n\n类的私有属性实例如下：\n\n```python\nclass JustCounter:\n    __secretCount = 0  # 私有变量\n    publicCount = 0    # 公开变量\n \n    def count(self):\n        self.__secretCount += 1\n        self.publicCount += 1\n        print (self.__secretCount)\n \ncounter = JustCounter()\ncounter.count()\ncounter.count()\nprint (counter.publicCount)\nprint (counter.__secretCount)  # 报错，实例不能访问私有变量\n```\n\n执行以上程序输出结果为：\n\n```python\n1\n2\n2\nTraceback (most recent call last):\n  File \"test.py\", line 16, in <module>\n    print (counter.__secretCount)  # 报错，实例不能访问私有变量\nAttributeError: 'JustCounter' object has no attribute '__secretCount'\n```\n\n### 类的方法\n在类的内部，使用 `def` 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 `self`，且为第一个参数，self 代表的是类的实例。\n\nself 的名字并不是规定死的，也可以使用 `this`，但是最好还是按照约定使用 `self`。\n\n### 类的私有方法\n`__private_method`：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。`self.__private_methods`。\n\n类的私有方法实例如下：\n\n```python\nclass Site:\n    def __init__(self, name, url):\n        self.name = name       # public\n        self.__url = url   # private\n \n    def who(self):\n        print('name  : ', self.name)\n        print('url : ', self.__url)\n \n    def __foo(self):          # 私有方法\n        print('这是私有方法')\n \n    def foo(self):            # 公共方法\n        print('这是公共方法')\n        self.__foo()\n \nx = Site('菜鸟教程', 'www.runoob.com')\nx.who()        # 正常输出\nx.foo()        # 正常输出\nx.__foo()      # 报错\n```\n\n以上实例执行结果：\n\n![](Python3/F5C2A308-3A88-42B4-B575-C719EB8F1CC4.jpg)\n\n### 类的专有方法：\n\n- **__init__ :** 构造函数，在生成对象时调用\n- **__del__ :** 析构函数，释放对象时使用\n- **__repr__ :** 打印，转换\n- **__setitem__ :** 按照索引赋值\n- **__getitem__:** 按照索引获取值\n- **__len__:** 获得长度\n- **__cmp__:** 比较运算\n- **__call__:** 函数调用\n- **__add__:** 加运算\n- **__sub__:** 减运算\n- **__mul__:** 乘运算\n- **__truediv__:** 除运算\n- **__mod__:** 求余运算\n- **__pow__:** 乘方\n\n### 运算符重载\n\nPython同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：\n\n```python\nclass Vector:\n   def __init__(self, a, b):\n      self.a = a\n      self.b = b\n \n   def __str__(self):\n      return 'Vector (%d, %d)' % (self.a, self.b)\n   \n   def __add__(self,other):\n      return Vector(self.a + other.a, self.b + other.b)\n \nv1 = Vector(2,10)\nv2 = Vector(5,-2)\nprint (v1 + v2)\n```\n\n以上代码执行结果如下所示:\n\n```python\nVector(7,8)\n```\n\n# 26. 命名空间/作用域\n\n## 26.1 命名空间\n\n先看看官方文档的一段话：\n\n> A namespace is a mapping from names to objects.Most namespaces are currently implemented as Python dictionaries。\n\n命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。\n\n命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。\n\n我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。\n\n一般有三种命名空间：\n\n- **内置名称（built-in names**）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n- **全局名称（global names）**，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n- **局部名称（local names）**，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）\n\n![](Python3/types_namespace-1.png)\n\n命名空间查找顺序:\n\n假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间去 -> 全局命名空间 -> 内置命名空间。\n\n如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:\n\n```python\nNameError: name 'runoob' is not defined。\n```\n\n命名空间的生命周期：\n\n命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。\n\n因此，**我们无法从外部命名空间访问内部命名空间的对象**。\n\n如下图所示，相同的对象名称可以存在于多个命名空间中。\n\n![](Python3/namespaces.png)\n\n## 26.2 作用域\n\n> A scope is a textual region of a Python program where a namespace is directly accessible. \"Directly accessible\" here means that an unqualified reference to a name attempts to find the name in the namespace.\n\n作用域就是一个 Python 程序可以直接访问命名空间的正文区域。\n\n在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。\n\nPython 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。\n\n变量的作用域**决定了在哪一部分程序可以访问哪个特定的变量名称**。Python 的作用域一共有4种，分别是：\n\n- **L（Local）**：最内层，包含局部变量，比如一个函数/方法内部。\n- **E（Enclosing）**：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。\n- **G（Global）**：当前脚本的最外层，比如当前模块的全局变量。\n- **B（Built-in）**： 包含了内建的变量/关键字等，最后被搜索。\n\n规则顺序： **L –> E –> G –> B**。\n\n![](Python3/1418490-20180906153626089-1835444372.png)\n\n```python\ng_count = 0  # 全局作用域\ndef outer():\n    o_count = 1  # 闭包函数外的函数中\n    def inner():\n        i_count = 2  # 局部作用域\n```\n\n内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:\n\n```python\n>>> import builtins\n>>> dir(builtins)\n```\n**Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。**\n\n### 全局变量和局部变量\n\n定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。\n\n局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。\n\n```python\ntotal = 0 # 这是一个全局变量\n# 可写函数说明\ndef sum( arg1, arg2 ):\n    #返回2个参数的和.\"\n    total = arg1 + arg2 # total在这里是局部变量.\n    print (\"函数内是局部变量 : \", total)\n    return total\n \n#调用sum函数\nsum( 10, 20 )\nprint (\"函数外是全局变量 : \", total)\n```\n\n以上实例输出结果：\n\n```python\n函数内是局部变量 :  30\n函数外是全局变量 :  0\n```\n\n### global 和 nonlocal关键字\n\n- 当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了。以下实例修改全局变量 num：\n\n```python\nnum = 1\ndef fun1():\n    global num  # 需要使用 global 关键字声明\n    print(num) \n    num = 123\n    print(num)\nfun1()\nprint(num)\n```\n\n以上实例输出结果：\n\n```python\n1\n123\n123\n```\n\n- 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：\n\n```python\ndef outer():\n    num = 10\n    def inner():\n        nonlocal num   # nonlocal关键字声明\n        num = 100\n        print(num)\n    inner()\n    print(num)\nouter()\n```\n\n以上实例输出结果：\n\n```python\n100\n100\n```\n\n# 27. 标准库概览\n\n## 27.1 操作系统接口\n\nos模块提供了不少与操作系统相关联的函数。\n\n```python\n>>> import os\n>>> os.getcwd()      # 返回当前的工作目录\n'C:\\\\Python34'\n>>> os.chdir('/server/accesslogs')   # 修改当前的工作目录\n>>> os.system('mkdir today')   # 执行系统命令 mkdir \n0\n```\n\n建议使用 \"import os\" 风格而非 \"from os import \\*\"。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。\n\n在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用:\n\n```python\n>>> import os\n>>> dir(os)\n<returns a list of all module functions>\n>>> help(os)\n<returns an extensive manual page created from the module's docstrings>\n```\n\n针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口:\n\n```python\n>>> import shutil\n>>> shutil.copyfile('data.db', 'archive.db')\n>>> shutil.move('/build/executables', 'installdir')\n```\n\n## 27.2 文件通配符\n\nglob模块提供了一个函数用于从目录通配符搜索中生成文件列表:\n\n```python\n>>> import glob\n>>> glob.glob('*.py')\n['primes.py', 'random.py', 'quote.py']\n```\n\n## 27.3 命令行参数\n\n通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 \"python demo.py one two three\" 后可以得到以下输出结果:\n\n```python\n>>> import sys\n>>> print(sys.argv)\n['demo.py', 'one', 'two', 'three']\n```\n\n## 27.4 错误输出重定向和程序终止\n\nsys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。\n\n```python\n>>> sys.stderr.write('Warning, log file not found starting a new one\\n')\nWarning, log file not found starting a new one\n```\n\n大多脚本的定向终止都使用 \"`sys.exit()`\"。\n\n## 27.5 字符串正则匹配\n\nre模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:\n\n```python\n>>> import re\n>>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n['foot', 'fell', 'fastest']\n>>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n'cat in the hat'\n```\n\n如果只需要简单的功能，应该首先考虑字符串方法，因为它们非常简单，易于阅读和调试:\n\n```python\n>>> 'tea for too'.replace('too', 'two')\n'tea for two'\n```\n\n## 27.6 数学\n\n- math模块为浮点运算提供了对底层C函数库的访问:\n\n```python\n>>> import math\n>>> math.cos(math.pi / 4)\n0.70710678118654757\n>>> math.log(1024, 2)\n10.0\n```\n\n- random提供了生成随机数的工具。\n\n```python\n>>> import random\n>>> random.choice(['apple', 'pear', 'banana'])\n'apple'\n>>> random.sample(range(100), 10)   # sampling without replacement\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n>>> random.random()    # random float\n0.17970987693706186\n>>> random.randrange(6)    # random integer chosen from range(6)\n4\n```\n\n## 27.7 访问 互联网\n\n有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib.request 以及用于发送电子邮件的 smtplib:\n\n```python\n>>> from urllib.request import urlopen\n>>> for line in urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):\n...     line = line.decode('utf-8')  # Decoding the binary data to text.\n...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time\n...         print(line)\n\n<BR>Nov. 25, 09:43:32 PM EST\n\n>>> import smtplib\n>>> server = smtplib.SMTP('localhost')\n>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n... \"\"\"To: jcaesar@example.org\n... From: soothsayer@example.org\n...\n... Beware the Ides of March.\n... \"\"\")\n>>> server.quit()\n```\n\n注意第二个例子需要本地有一个在运行的邮件服务器。\n\n## 27.8 日期和时间\n\ndatetime模块为日期和时间处理同时提供了简单和复杂的方法。\n\n支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。\n\n该模块还支持时区处理:\n\n```python\n>>> # dates are easily constructed and formatted\n>>> from datetime import date\n>>> now = date.today()\n>>> now\ndatetime.date(2003, 12, 2)\n>>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n\n>>> # dates support calendar arithmetic\n>>> birthday = date(1964, 7, 31)\n>>> age = now - birthday\n>>> age.days\n14368\n```\n\n## 27.9 数据压缩\n\n以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。\n\n```python\n>>> import zlib\n>>> s = b'witch which has which witches wrist watch'\n>>> len(s)\n41\n>>> t = zlib.compress(s)\n>>> len(t)\n37\n>>> zlib.decompress(t)\nb'witch which has which witches wrist watch'\n>>> zlib.crc32(s)\n226805979\n```\n\n## 27.10 性能度量\n\n有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。\n\n例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。\n\n```python\n>>> from timeit import Timer\n>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n0.57535828626024577\n>>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n0.54962537085770791\n```\n\n相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。\n\n## 27.11 测试模块\n\n开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试\n\ndoctest模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。\n\n测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。\n\n通过用户提供的例子，它强化了文档，允许 doctest 模块确认代码的结果是否与文档一致:\n\n```python\ndef average(values):\n    \"\"\"Computes the arithmetic mean of a list of numbers.\n\n    >>> print(average([20, 30, 70]))\n    40.0\n    \"\"\"\n    return sum(values) / len(values)\n\nimport doctest\ndoctest.testmod()   # 自动验证嵌入测试\n```\n\nunittest模块不像 doctest模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:\n\n```python\nimport unittest\n\nclass TestStatisticalFunctions(unittest.TestCase):\n\n    def test_average(self):\n        self.assertEqual(average([20, 30, 70]), 40.0)\n        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n        self.assertRaises(ZeroDivisionError, average, [])\n        self.assertRaises(TypeError, average, 20, 30, 70)\n\nunittest.main() # Calling from the command line invokes all tests\n```\n\n# Ref\n\n- [Python3 教程 | 菜鸟教程](https://www.runoob.com/python3/python3-tutorial.html)","tags":["develop language"],"categories":["AI"]},{"title":"Python2 基础","url":"/article/Python2.html","content":"\n# 1. 基础语法\n\n## 1.1 行和缩进\n\n学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。\n\n缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。\n\n## 1.2 多行语句\n\nPython语句中一般以新行作为语句的结束符。\n\n但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示：\n```python\ntotal = item_one + \\\n        item_two + \\\n        item_three\n```\n\n语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：\n```python\ndays = ['Monday', 'Tuesday', 'Wednesday',\n        'Thursday', 'Friday']\n```\n\n## 1.3 Python空行\n\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n\n空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n\n记住：**空行也是程序代码的一部分**。\n\n## 1.4 同一行显示多条语句\n\nPython可以在同一行中使用多条语句，语句之间使用**分号(`;`)**分割，以下是一个简单的实例：\n\n```pyhton\nimport sys; x = 'runoob'; sys.stdout.write(x + '\\n')\n```\n\n## 1.5 print输出\n\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号` ,`。\n```python\nx=\"a\"\ny=\"b\"\n# 换行输出\nprint x\nprint y\n\nprint '---------'\n# 不换行输出\nprint x,\nprint y,\n\n# 不换行输出\nprint x,y\n```\n\n# 2. 变量类型\n\n## 2.1 变量赋值\n\nPython 中的变量赋值不需要类型声明。\n\n每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。\n\n**每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。**\n\n等号 `=` 用来给变量赋值。\n\n等号`=` 运算符左边是一个变量名，等号 `=` 运算符右边是存储在变量中的值。\n\n## 2.2 多个变量赋值\n\nPython允许你同时为多个变量赋值。例如：\n\n```python\na = b = c = 1\n```\n\n以上实例，创建一个整型对象，值为1，**三个变量被分配到相同的内存空间上**。\n\n也可以为多个对象指定多个变量。例如：\n\n```python\na, b, c = 1, 2, \"john\"\n```\n\n以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 \"john\" 分配给变量 c。\n\n## 2.3 标准数据类型\n\n在内存中存储的数据可以有多种类型。\n\n例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。\n\nPython 定义了一些标准类型，用于存储各种类型的数据。\n\nPython有五个标准的数据类型：\n\n- Numbers（数字）\n- String（字符串）\n- List（列表）\n- Tuple（元祖）\n- Dictionary（字典）\n\n## 2.4 Python 数字\n\n数字数据类型用于存储数值。\n\n**他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。**\n\n当你指定一个值时，Number 对象就会被创建。\n\n也可以使用del语句删除一些对象的引用。\n\ndel语句的语法是：\n\n```python\ndel var1[,var2[,var3[....,varN]]]\n```\n\n还可以通过使用del语句删除单个或多个对象的引用。例如：\n```python\ndel var\ndel var_a, var_b\n```\n\nPython支持四种不同的数字类型：\n\n- int（有符号整型）\n- long（长整型，也可以代表八进制和十六进制）\n- float（浮点型）\n- complex（复数）\n\nTips：\n\n- 长整型也可以使用小写 l，但是还是建议使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。\n- Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。\n\n> **注意：** long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。\n> \n\n## 2.5 Python 字符串\n\n字符串或串(String)是由数字、字母、下划线组成的一串字符。它是编程语言中表示文本的数据类型。\n\npython的字串列表有2种取值顺序:\n\n- 从左到右索引默认0开始的，最大范围是字符串长度少1\n- 从右到左索引默认-1开始的，最大范围是字符串开头\n\n![](Python2/python-string-slice.png)\n\n如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。\n\n[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。 ==>  **左闭右开**\n\n比如:\n\n```python\n>>> s = 'abcdef'\n>>> s[1:5]\n'bcde'\n>>> s[-3:]\n'def'\n```\n\n**加号（+）是字符串连接运算符，星号（*）是重复操作。**如下实例：\n\n```python\nstr = 'Hello World!'\n \nprint str           # 输出完整字符串\nprint str[0]        # 输出字符串中的第一个字符\nprint str[2:5]      # 输出字符串中第三个至第六个之间的字符串\nprint str[2:]       # 输出从第三个字符开始的字符串\nprint str * 2       # 输出字符串两次\nprint str + \"TEST\"  # 输出连接的字符串\n```\n\n以上实例输出结果：\n```python\nHello World!\nH\nllo\nllo World!\nHello World!Hello World!\nHello World!TEST\n```\n\nPython 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n![](Python2/python_list_slice_2.png)\n\n## 2.6 Python 列表\n\nList（列表） 是 Python 中使用最频繁的数据类型。\n\n列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。\n\n列表用 `[ ]`  标识，是 python 最通用的复合数据类型。\n\n列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。\n\n![](Python2/list_slicing1_new1.png)\n\n**加号 + 是列表连接运算符，星号 * 是重复操作。**如下实例：\n\n```python\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntinylist = [123, 'john']\n \nprint list               # 输出完整列表\nprint list[0]            # 输出列表的第一个元素\nprint list[1:3]          # 输出第二个至第三个元素 \nprint list[2:]           # 输出从第三个开始至列表末尾的所有元素\nprint tinylist * 2       # 输出列表两次\nprint list + tinylist    # 打印组合的列表\n```\n\n以上实例输出结果：\n```python\n['runoob', 786, 2.23, 'john', 70.2]\nrunoob\n[786, 2.23]\n[2.23, 'john', 70.2]\n[123, 'john', 123, 'john']\n['runoob', 786, 2.23, 'john', 70.2, 123, 'john']\n```\n\n## 2.7 Python 元组\n元组是另一个数据类型，类似于 List（列表）。\n\n元组用 `( ) ` 标识。内部元素用逗号隔开。**但是元组不能二次赋值，相当于只读列表。**\n\n```python\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\ntinytuple = (123, 'john')\n \nprint tuple               # 输出完整元组\nprint tuple[0]            # 输出元组的第一个元素\nprint tuple[1:3]          # 输出第二个至第四个（不包含）的元素 \nprint tuple[2:]           # 输出从第三个开始至列表末尾的所有元素\nprint tinytuple * 2       # 输出元组两次\nprint tuple + tinytuple   # 打印组合的元组\n```\n\n以上实例输出结果：\n\n```python\n('runoob', 786, 2.23, 'john', 70.2)\nrunoob\n(786, 2.23)\n(2.23, 'john', 70.2)\n(123, 'john', 123, 'john')\n('runoob', 786, 2.23, 'john', 70.2, 123, 'john')\n```\n\n**以下对元组的操作是无效的，因为元组不允许更新，而列表是允许更新的：**\n\n```python\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntuple[2] = 1000    # 元组中是非法应用\nlist[2] = 1000     # 列表中是合法应用\n```\n\n元组是不允许更新的，所以以上代码执行错误，结果如下：\n\n```python\nTraceback (most recent call last):\n  File \"test.py\", line 6, in <module>\n    tuple[2] = 1000    # 元组中是非法应用\nTypeError: 'tuple' object does not support item assignment\n```\n\n## 2.8 Python 字典\n字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。**列表是有序的对象集合，字典是无序的对象集合。**\n\n两者之间的区别在于：字典当中的**元素是通过键来存取的，而不是通过偏移存取。**\n\n字典用 `{ }` 标识。字典由 **索引(key)** 和它对应的 **值value** 组成。\n\n```python\ndict = {}\ndict['one'] = \"This is one\"\ndict[2] = \"This is two\"\n \ntinydict = {'name': 'runoob','code':6734, 'dept': 'sales'}\n \n \nprint dict['one']          # 输出键为'one' 的值\nprint dict[2]              # 输出键为 2 的值\nprint tinydict             # 输出完整的字典\nprint tinydict.keys()      # 输出所有键\nprint tinydict.values()    # 输出所有值\n```\n\n输出结果为：\n\n```python\nThis is one\nThis is two\n{'dept': 'sales', 'code': 6734, 'name': 'runoob'}\n['dept', 'code', 'name']\n['sales', 6734, 'runoob']\n```\n\n## 2.9 Python 数据类型转换\n有时候，我们需要对数据内置的类型进行转换，**数据类型的转换，你只需要将数据类型作为函数名即可**。\n\n以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。\n\n|函数|描述|备注|\n|-|-|-|\n|int(x [,base])|将x转换为一个整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|long(x [,base])|将x转换为一个长整数|x -- 字符串或数字。base -- 可选，进制数，默认十进制。|\n|float(x)|将x转换到一个浮点数||\n|complex(real [,imag])|创建一个复数|real -- int, long, float或字符串；imag -- int, long, float；|\n|str(x)|将对象 x 转换为字符串||\n|repr(x)|将对象 x 转换为表达式字符串||\n|eval(str)|用来计算在字符串中的有效Python表达式,并返回一个对象||\n|tuple(s)|将序列 s 转换为一个元组||\n|list(s)|将序列 s 转换为一个列表||\n|set(s)|转换为可变集合||\n|dict(d)|创建一个字典。d 必须是一个序列 (key,value)元组。||\n|frozenset(s)|转换为不可变集合||\n|chr(x)|将一个整数转换为一个字符||\n|unichr(x)|将一个整数转换为Unicode字符||\n|ord(x)|将一个字符转换为它的整数值||\n|hex(x)|将一个整数转换为一个十六进制字符串||\n|oct(x)|将一个整数转换为一个八进制字符串||\n\n# 3. 运算符\n\nPython语言支持以下类型的运算符:\n\n- 算术运算符\n- 比较（关系）运算符\n- 赋值运算符\n- 逻辑运算符\n- 位运算符\n- 成员运算符\n- 身份运算符\n- 运算符优先级\n\n## 3.1 算术运算符\n\n以下假设变量： a=10，b=20：\n\n|运算符|描述|实例|\n|-|-|-|\n|%|取模 - 返回除法的余数|b % a 输出结果 0|\n|\\*\\*|幂 - 返回x的y次幂|a\\*\\*b 为10的20次方， 输出结果 100000000000000000000|\n|//|取整除 - 返回商的整数部分（**向下取整**）|9//2 输出 4 ; -9//2 输出 -5|\n\n> **注意：**  `Python2.x` 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。\n> 在 `Python 3.x` 中 / 除法不再这么做了，对于整数之间的相除，结果也会是浮点数。\n\n## 3.2 位运算符\n\n按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n\n下表中变量 a 为 60，b 为 13，二进制格式如下：\n\n```python\na = 0011 1100\n\nb = 0000 1101\n\n-----------------\n\na&b = 0000 1100\n\na|b = 0011 1101\n\na^b = 0011 0001\n\n~a  = 1100 0011\n```\n|运算符|描述|实例|\n|-|-|-|\n|&|按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0|(a & b) 输出结果 12 ，二进制解释： 0000 1100|\n|\\||按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。|(a | b) 输出结果 61 ，二进制解释： 0011 1101|\n|^|按位异或运算符：当两对应的二进位相异时，结果为1|(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|\n|~|按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|\n|<<|左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。|a << 2 输出结果 240 ，二进制解释： 1111 0000|\n|>>|右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|\n\n## 3.3 逻辑运算符\n\nPython语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n> **注意：** 关注and、or的返回值问题\n\n|运算符|逻辑表达式|描述|实例|\n|-|-|-|-|\n|and|x and y|布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它**返回 y 的计算值**。|(a and b) 返回 20。|\n|or|x or y|布尔\"或\" - **如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。**|(a or b) 返回 10。|\n|not|not x|布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。|not(a and b) 返回 False|\n\n## 3.4 成员运算符\n\n|运算符|描述|实例|\n|-|-|-|\n|in|如果在指定的序列中找到值返回 True，否则返回 False。|x 在 y 序列中 , 如果 x 在 y 序列中返回 True。|\n|not in|如果在指定的序列中没有找到值返回 True，否则返回 False。|x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。|\n\n## 3.5 身份运算符\n\n身份运算符用于比较两个对象的存储单元\n\n|运算符|描述|实例|\n|-|-|-|\n|is|is 是判断两个标识符是不是引用自一个对象|x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False|\n|is not|is not 是判断两个标识符是不是引用自不同对象|x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。|\n\n>注： id() 函数用于获取对象内存地址。\n>id() 函数返回对象的唯一标识符，标识符是一个整数。CPython 中 id() 函数用于获取对象的内存地址\n>id 语法：id([object])，参数说明：object -- 对象。\n\n### is 与 == 区别：\n\n**is **用于判断两个变量引用对象是否为**同一个(同一块内存空间)**，**==**用于判断引用变量的**值是否相等**。\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a \nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\n## 3.6 运算符优先级\n\n以下表格列出了从最高到最低优先级的所有运算符：\n\n|运算符|描述|\n|-|-|\n|\\*\\*|指数 (最高优先级)|\n|~ + -|按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)|\n|\\* / % //|乘，除，取模和取整除|\n|+ -|加法减法|\n|>> <<|右移，左移运算符|\n|&|位 'AND'|\n|^ |\t位运算符|\n|<= < > >=|比较运算符|\n|<> == !=|等于运算符|\n|= %= /= //= -= += \\*= \\*\\*=|赋值运算符|\n|is is not|身份运算符|\n|in not in|成员运算符|\n|not and or|逻辑运算符|\n\n# 4. 条件语句\n\nPython条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。\n\n可以通过下图来简单了解条件语句的执行过程:\n\n![](Python2/if-condition.jpg)\n\nPython程序语言指定任何非0和非空（null）值为true，0 或者 null为false。\n\n> tips: null是false\n\nPython 编程中 if 语句用于控制程序的执行，基本形式为：\n\n```python\nif 判断条件：\n    执行语句……\nelse：\n    执行语句……\n```\n\n其中\"判断条件\"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。\n\nelse 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。\n\nGif 演示：\n\n![](Python2/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif)\n\nif 语句的判断条件可以用>（大于）、<(小于)、==（等于）、>=（大于等于）、<=（小于等于）来表示其关系。\n\n当判断条件为多个值时，可以使用以下形式：\n\n```python\nif 判断条件1:\n    执行语句1……\nelif 判断条件2:\n    执行语句2……\nelif 判断条件3:\n    执行语句3……\nelse:\n    执行语句4……\n```\n\n**由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现**，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。\n\n当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于>（大于）、<（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。\n\n### 简单的语句组\n\n也可以在同一行的位置上使用if条件判断语句，如下实例：\n\n```python\nvar = 100 \n \nif ( var  == 100 ) : print \"变量 var 的值为100\" \n \nprint \"Good bye!\"\n```\n\n以上代码执行输出结果如下：\n\n```python\n变量 var 的值为100\nGood bye!\n```\n\n\n# 5. 循环语句\n\n程序在一般情况下是按顺序执行的。编程语言提供了各种控制结构，允许更复杂的执行路径。\n循环语句允许我们执行一个语句或语句组多次，下面是在大多数编程语言中的循环语句的一般形式：\n\n![](Python2/loop.png)\n\n## 5.1 循环类型\n\nPython 提供了 for 循环和 while 循环**（在 Python 中没有 do..while 循环）**:\n\n|循环类型|描述|\n|-|-|\n|while 循环|在给定的判断条件为 true 时执行循环体，否则退出循环体。|\n|for 循环|重复执行语句|\n|嵌套循环|你可以在while循环体中嵌套for循环|\n\n## 5.2 循环控制语句\n\n循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：\n\n|控制语句|描述|\n|-|-|\n|break 语句|在语句块执行过程中终止循环，并且跳出整个循环|\n|continue 语句|在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。|\n|pass 语句|pass是空语句，是为了保持程序结构的完整性。|\n\n# 6. While循环语句\n\n## 6.1 基本形式\nPython 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：\n\n```python\nwhile 判断条件(condition)：\n    执行语句(statements)……\n```\n\n执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。\n\n当判断条件假 false 时，循环结束。\n\n执行流程图如下：\n\n![](Python2/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg)\n\n## 6.2 Gif 演示 Python while 语句执行过程\n\n![](Python2/006faQNTgw1f5wnm06h3ug30ci08cake.gif)\n\n复杂一点\n\n![](Python2/loop-over-python-list-animation.gif)\n\nwhile 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外\"判断条件\"还可以是个常值，表示循环必定成立。\n\n## 6.3 无限循环\n\n如果条件判断语句永远为 true，循环将会无限的执行下去。\n\n> 注意：无限循环可以使用 CTRL+C 来中断循环。\n\n## 6.4 循环使用 else 语句\n\n在 python 中，while … else 在**循环条件为 false 时执行 else 语句块**：\n\n```python\ncount = 0\nwhile count < 5:\n   print count, \" is  less than 5\"\n   count = count + 1\nelse:\n   print count, \" is not less than 5\"\n```\n\n以上实例输出结果为：\n```python\n0 is less than 5\n1 is less than 5\n2 is less than 5\n3 is less than 5\n4 is less than 5\n5 is not less than 5\n```\n\n## 6.5 简单语句组\n\n类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：\n\n```python\nflag = 1\n \nwhile (flag): print 'Given flag is really true!'\n \nprint \"Good bye!\"\n```\n\n> 注意：以上的无限循环可以使用 CTRL+C 来中断循环。\n\n\n\n# 7. for循环语句\n\n# 8. 循环嵌套\n# 9. break语句\n# 10. continue语句\n# 11. pass语句\n# 12. Number（数字）\n# 13. 字符串\n# 14. 列表（List）\n# 15. 元祖\n# 16. 字典（Dictionary）\n# 17. 日期和时间\n# 18. 函数\n# 19. 模块\n# 20. 文件I/O\n# 21. File 方法\n# 22. 异常处理\n# 23. OS 文件/目录方法\n# 24. 内置函数\n\n\n\n\n\n\n\n\n\n","tags":["develop language"],"categories":["AI"]},{"title":"Python 简介","url":"/article/Python-introduction.html","content":"\n\n# 1. Python 起源\n\n## 1.1 解释器\n\n**计算机不能直接理解任何除机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**。  \n编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器**以解释方式运行的时候**，也称之为**解释器**。  \n![](Python-introduction/编译型和解释型语言工作对比.png)  \n\n- **编译型语言**：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++。  \n- **解释型语言**：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行。  \n\n## 1.2 Python 特点\n\n* Python 是**完全面向对象的语言**\n  * **函数**、**模块**、**数字**、**字符串**都是对象，**在 Python 中一切皆对象**\n  * 完全支持继承、重载、多重继承\n  * 支持重载运算符，也支持泛型设计\n* Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字**、**字符串**、**列表**、**字典**、**文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理**、**网络通信**、**文本处理**、**数据库接口**、**图形系统**、**XML 处理** 等额外的功能。\n* Python 社区提供了**大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算**、**人工智能**、**机器学习**、**Web 开发**、**数据库接口**、**图形系统** 多个领域。\n\n## 1.3 Python 的优缺点\n\n- **优点**\n  - 简单、易学\n  - 免费、开源\n  - **面向对象**\n  - 丰富的库\n  - 可扩展性\n    - 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 `C` 或 `C++` 编写，然后在 `Python` 程序中使用它们\n  - ……\n- **缺点**\n  - 运行速度\n  - 国内市场较小\n  - 中文资料匮乏\n\n# 2. Python 程序\n\n1. Python 源程序就是**一个特殊格式的文本文件**，可以**使用任意文本编辑软件**做 `Python` 的开发\n2. Python 程序的 **文件扩展名** 通常都是 `.py`\n\n**Tips:（报错提示）**\n\n- error 错误\n- name 名字\n- defined 已经定义\n- syntax 语法\n- invalid 无效\n- Indentation 索引\n- unexpected 意外的，不期望的\n- character 字符\n- line 行\n- encoding 编码\n- declared 声明\n- details 细节，详细信息\n- ASCII 一种字符编码\n\n# 3. `Python 2.x` 与 `3​​.x` 版本简介\n\n目前市场上有两个 Python 的版本并存着，分别是 `Python 2.x` 和 `Python 3.x`\n\n> 新的 Python 程序建议使用 `Python 3.0` 版本的语法\n\n* Python 2.x 是 **过去的版本**\n  * 解释器名称是 **python**\n* Python 3.x 是 **现在和未来 主流的版本**\n  * 解释器名称是 **python3**\n  * 相对于 `Python` 的早期版本，这是一个 **较大的升级**\n  * 为了不带入过多的累赘，`Python 3.0` 在设计的时候 **没有考虑向下兼容**\n    * 许多早期 `Python` 版本设计的程序都无法在 `Python 3.0` 上正常执行\n  * Python 3.0 发布于 **2008 年**\n  * 到目前为止，Python 3.0 的稳定版本已经有很多年了\n    * Python 3.3 发布于 2012\n    * Python 3.4 发布于 2014\n    * Python 3.5 发布于 2015\n    * Python 3.6 发布于 2016\n* 为了照顾现有的程序，官方提供了一个过渡版本 —— **Python 2.6**\n  * 基本使用了 `Python 2.x` 的语法和库\n  * 同时考虑了向 `Python 3.0` 的迁移，**允许使用部分** `Python 3.0` 的语法与函数\n  * 2010 年中推出的 `Python 2.7` 被确定为 **最后一个Python 2.x 版本**\n\n> 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议\n>\n> * 先使用 `Python 3.0` 版本进行开发\n> * 然后使用 `Python 2.6`、`Python 2.7` 来执行，并且做一些兼容性的处理\n\n# 4. 执行 Python 程序的三种方式\n\n## 4.1  解释器 `python` / `python3`\n\n### 1) Python 的解释器\n\n```bash\n# 使用 python 2.x 解释器\n$ python xxx.py\n\n# 使用 python 3.x 解释器\n$ python3 xxx.py\n```\n\n### 2) 其他解释器\n\n**Python 的解释器** 如今有多个语言的实现，包括：\n\n- `CPython` —— 官方版本的 C 语言实现\n- `Jython` —— 可以运行在 Java 平台\n- `IronPython` —— 可以运行在 .NET 和 Mono 平台\n- `PyPy` —— Python 实现的，支持 JIT 即时编译\n\n## 4.2 交互式运行 Python 程序\n\n- 直接在终端中运行解释器，而不输入要执行的文件名\n- 在 Python 的 `Shell` 中直接输入 **Python 的代码**，会立即看到程序执行结果\n\n### 1) 交互式运行 Python 的优缺点\n\n- **优点**\n  - 适合于学习/验证 Python 语法或者局部代码\n- **缺点**\n  - 代码不能保存\n  - 不适合运行太大的程序\n\n### 2) 退出 官方的解释器\n\n- 1> 直接输入 `exit()`\n\n```python\n>>> exit()\n```\n\n- 2> 使用热键退出\n  在 python 解释器中，按热键 `ctrl + d` 可以退出解释器\n\n### 3) IPython\n\n- IPython 中 的 “I” 代表 **交互 interactive**\n\n**特点**\n\n- IPython 是一个 python 的 **交互式 shell**，比默认的 `python shell` 好用得多\n  - 支持自动补全\n  - 自动缩进\n  - 支持 `bash shell` 命令\n  - 内置了许多很有用的功能和函数\n- IPython 是基于 BSD 开源的\n\n**版本**\n\n- Python 2.x 使用的解释器是 **ipython**\n- Python 3.x 使用的解释器是 **ipython3**\n\n**要退出解释器可以有以下两种方式：**\n\n- 1> 直接输入 `exit`\n\n```python\nIn [1]: exit\n```\n\n- 2> 使用热键退出\n  在 IPython 解释器中，按热键 `ctrl + d`，`IPython` 会询问是否退出解释器\n\n## 4.3. Python 的 IDE —— `PyCharm`\n\n### 1） 集成开发环境（IDE）\n\n集成开发环境（`IDE`，Integrated Development Environment）—— **集成了开发软件需要的所有工具**，一般包括以下工具：\n\n- 图形用户界面\n- 代码编辑器（支持 **代码补全**／**自动缩进**）\n- 编译器／解释器\n- 调试器（**断点**／**单步执行**）\n- ……\n\n### 2）PyCharm 介绍\n\n- `PyCharm` 是 Python 的一款非常优秀的集成开发环境\n- `PyCharm` 除了具有一般 IDE 所必备功能外，还可以在 `Windows`、`Linux`、`macOS` 下使用\n- `PyCharm` 适合开发大型项目\n  - 一个项目通常会包含 **很多源文件**\n  - 每个 **源文件** 的代码行数是有限的，通常在几百行之内\n  - 每个 **源文件** 各司其职，共同完成复杂的业务功能","tags":["develop language"],"categories":["AI"]},{"title":"Perceptron","url":"/article/Perceptron.html","content":"\n\n# 1 感知器模型\n## 1.1 起源\n感知器模型与算法由美国科学家 Frank Rosenblatt 于 1958 年提出，最早用于解决图像分类问题。我们把向量 $ \\begin{equation} x = (x_1, x_2, ... , x_n)^T \\end{equation} $ 称为模式（Pattern）或特征（Feature）向量，比如 $ \\begin{equation} x_i \\end{equation} $ 表示图像中第 i 个像素的亮度。标量 y 称为类别标号（Class label）。感知器可以把一个模式 x 区分为两个不同的类别 $ \\begin{equation} (y = -1, +1) \\end{equation} $ ，这个过程称为分类（Classification）。\n\n## 1.2 定义\n假设输入空间（特征空间）是 $ \\begin{equation} \\mathcal{X} \\in R^n \\end{equation} $ ，输出空间是 $ \\begin{equation} \\mathcal{Y} \\in \\lbrace -1, 1 \\rbrace \\end{equation} $ ，其中输入 $ \\begin{equation} x \\in \\mathcal{X} \\end{equation} $ 表示实例的特征向量，对应于输入空间（特征空间）的点，输出 $ \\begin{equation} y \\in \\mathcal{Y} \\end{equation} $ 表示实例的类别，有输入空间到输出空间的函数：\n$$ \\begin{equation} \ng(x; w, b) = sgn(w^Tx + b) \n\\end{equation} $$\n称为感知器。其中 **g** 称为决策函数，**sgn** 称为符号函数：\n$$ \\begin{equation} \nsgn(x) = \n\\begin{cases}\n\\ \\ \\ 1, &x \\geqslant 0\\\\\n-1, &x < 0\n\\end{cases}\n\\end{equation} $$\n由判别函数得到一个方程：\n$$ \\begin{equation} \n\\mathcal{f} (x; w, b) = w^Tx + b = 0\n\\end{equation} $$\n该方程是一个线性方程，表示 d 维空间的一个超平面（hyper-plane），称为决策面（Decision Boundary），把该空间划分两半，位于该决策面一侧的样本 **x** 为正样本（**y** = 1）、位于另一侧的样本为负样本（**y**  = -1），**w** 为该超平面的法向量，**b** 为位置偏置。图 1 展示了 d = 2 时的情况。\n![图1 线性决策面](Perceptron/图1_线性决策面.jpg)\n<center><p>图1 线性决策面</p></center>\n由于 d 维感知器的决策面是一个超平面，因此一个感知器只能对可以用超平面分隔的样本进行区分，如果样本的分布不能用线性超平面区分（线性不可分），那么单个感知器就无法起作用。比如图 2 中的红色与蓝色样本，是线性不可分的。\n![图2 线性不可分](Perceptron/图2_线性不可分.jpg)\n\n<center><p>图2 线性不可分</p></center>\n\n\n# 2 感知器学习算法\n\n## 2.1 定义\n感知器模型由参数 $ \\begin{equation} \\Theta  = (w, b ) \\end{equation} $ 决定。但是在很多问题中，这些参数无法由人工决定。比如，图像分类中，权值 $ \\begin{equation} w_i \\end{equation} $ 表示第i个像素的权值，这个权值很难由人工分析确定。因此需要有一种方法能自动确定这些参数。在机器学习中，如果给定一组已知类别标号的样本集 $ \\begin{equation} D = \\lbrace (x^{(i)}, y^{(i)}) \\rbrace (i = 1, 2, ..., n) \\end{equation} $ ，那么可以从这组样本中学习（Learning）/训练（Training）出模型的参数 $ \\begin{equation} \\Theta \\end{equation} $ 。\n**感知器学习算法**（Perceptron Learning Algorithm，PLA）是 Rosenblatt 给出的一个用于学习感知器模型的算法。该算法是一个迭代算法，首先初化模型参数为 **w** = 0，**b** = 0，假设第 t 步得到的模型参数为 $ \\begin{equation} \\Theta  = (w, b ) \\end{equation} $ ，在 t + 1 步，从 **D** 中选取一个样本 $ \\begin{equation} (x^{(j)}, y^{(j)}) \\end{equation} $ ，用当前模型参数代入感知器中对该样本进行分类，得到分类结果为 $ \\begin{equation} \\bar y \\end{equation} $ 。如果分类正确（ $ \\begin{equation} \\bar y = y^{(j)} \\end{equation} $ ），那么权值不变；如果分类错误（ $ \\begin{equation} \\bar y \\neq y^{(j)} \\end{equation} $ ），根据类别标号  $ \\begin{equation} y = y^{(j)} \\end{equation} $  对权值做如下更新：\n$$\\begin{equation}\\begin{split} \n&w \\leftarrow w + y^{(j)}x^{(j)} \\\\ \n&b \\leftarrow b + y^{(j)}\n\\end{split}\\end{equation}$$  \n\n## 2.2 PLA算法（伪代码）\n下面的伪代码展示了感知器的学习过程：  \n![PLA算法伪代码](Perceptron/PLA算法伪代码.jpg)\n当训练样本集D是线性可分时，上述算法在有限步内能输出一个能对D中所有样本正确分类的模型$ \\begin{equation} g(x; w, b) \\end{equation} $。  \n\n## 2.3 PLA算法实现\n1. 算法思想：对样本集进行**重复迭代**，以实现**逐点修正**。\n\t- ① 获取样本集中本次迭代的样本的预测值  $ \\begin{equation} \\bar y \\end{equation} $ 。\n\t- ② 将预测值 $ \\begin{equation} \\bar y \\end{equation} $ 和该样本的真实值 $ \\begin{equation} y^{(i)} \\end{equation} $ 进行比较。\n\t\t- 分类正确，对样本集中的下一个样本进行预测，即跳转到 ① 处执行，直至样本集中的样本全部迭代，然后跳转至③。\n\t\t- 分类错误，标记出现错误分类，然后对 $ \\begin{equation} \\vec w \\end{equation} $  和 **b** 进行更新，完成后跳转到 ① 处执行，直至样本集中的样本全部迭代，然后跳转至③。\n\t- ③ 若样本集中的所有样本全部迭代，且**未出现错误分类**，即说明当前的权重和偏差值正确，输出此时的 $ \\begin{equation} \\vec w \\end{equation} $  和 **b** 。\n2. Java实现：\n\n- PLA算法核心\n```Java\n// 重复迭代样本集实现逐点修正\nwhile (true){\n    boolean flag = true;    // 错误分类标记（用于判断当前w、b是否可以实现二分类）\n    Collections.shuffle(data);  // 对测试集进行随机排序\n    for (Data d : data) {   // 迭代样本集\n        int y_hat = forecast(weight, b, d); // 预测值\n        int y = d.getY();   // 真实值\n        if (y * y_hat <= 0){  // 判断当前分类是否正确，>0正确\n            flag = false;   // 出现错误分类\n            weight = update(weight, d); // 更新权重\n            b += d.getY();  // 更新偏差值\n        }\n    }\n    if (flag)\t// 本次迭代未出现错误分类\n        break;\n}\n```\n\n- forecast(Weight weight, int b, Data data)方法\n```Java\n/**\n * 计算y_hat(预测值)\n * @param weight    权重\n * @param b         偏差值\n * @param data      数据集\n * @return          返回预测值\n */\npublic static int forecast(Weight weight, int b, Data data){\n    return ((weight.getW1() * data.getX1()) + (weight.getW2() * data.getX2()) + b);\n}\n\n```\n\n- update(Weight weight, Data data)方法\n```Java\n/**\n * 更新权重\n * @param weight    原权重值\n * @param data      数据集\n * @return          返回更新后的权重\n */\npublic static Weight update(Weight weight, Data data){\n    // 获取样本数据\n    int x1 = data.getX1();\n    int x2 = data.getX2();\n\n    // 获取实际值\n    int y = data.getY();\n\n    // 更新权重\n    int newW1 = weight.getW1() + (y * x1);\n    int newW2 = weight.getW2() + (y * x2);\n    weight.setW1(newW1);\n    weight.setW2(newW2);\n    return weight;\n}\n```\n\n- 运行结果\n\n（1）运行结果1  \n![运行结果1](Perceptron/PLA（java实现）运行结果1.jpg)\n\n（2）运行结果2\n![运行结果2](Perceptron/PLA（java实现）运行结果2.jpg)\n\n（3）运行结果3\n![运行结果3](Perceptron/PLA（java实现）运行结果3.jpg)\n\n（4）运行结果4\n![运行结果4](Perceptron/PLA（java实现）运行结果4.jpg)\n\n# 3 总结\n\n- 感知器主要可以解决线性可分的问题，他可以用来解决**二分类问题**，其具有如下的优点和缺点：\n\t- 优点：相较于其他模型，感知器模型简单，易于实现。\n\t- 缺点：\n\t\t- PLA算法每一次运行的结果不一致（不稳定），所以无法完美的处理线性不可分的训练集（数据）。\n\t\t- 感知机中的损失函数（衡量预测值与真实值之间的误差）的目标只是减小所有误分类点与超平面，最终很有可能导致部分样本点距离超平面很近。所以通过PLA得到的只是一个近似最优解的解，并不能得到最优解。\n- 导致PLA算法第一个缺点的主要原因是因为该算法的基本原理是**逐点修正**。首先，在超平面上随意取一条分类面，统计分类错误的点，然后随机对某个错误点进行修正，也就是改变直线的位置，使该错误点得以修正；接着再随机选一个错误点进行纠正，分类面不断变化，直到所有的点都完全分类正确了，就得到了最佳的分类面。正是因为每次运行PLA算法进行的是一种随机修正，所以得到的结果不一样。\n- PLA算法的第二个确定可以通过**SVM**（支持向量机）解决，另外SVM也可以很好地解决线性不可分问题。\n\n\n\n\n\n\n\n","tags":["ML","algorithm","Perceptron","linear classification"],"categories":["AI"]}]